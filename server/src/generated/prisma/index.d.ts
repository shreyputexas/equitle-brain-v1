
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model UserPreference
 * 
 */
export type UserPreference = $Result.DefaultSelection<Prisma.$UserPreferencePayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Communication
 * 
 */
export type Communication = $Result.DefaultSelection<Prisma.$CommunicationPayload>
/**
 * Model Investor
 * 
 */
export type Investor = $Result.DefaultSelection<Prisma.$InvestorPayload>
/**
 * Model Fund
 * 
 */
export type Fund = $Result.DefaultSelection<Prisma.$FundPayload>
/**
 * Model InvestorEntity
 * 
 */
export type InvestorEntity = $Result.DefaultSelection<Prisma.$InvestorEntityPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model SyncJob
 * 
 */
export type SyncJob = $Result.DefaultSelection<Prisma.$SyncJobPayload>
/**
 * Model TeamsMessage
 * 
 */
export type TeamsMessage = $Result.DefaultSelection<Prisma.$TeamsMessagePayload>
/**
 * Model TeamsChannel
 * 
 */
export type TeamsChannel = $Result.DefaultSelection<Prisma.$TeamsChannelPayload>
/**
 * Model SlackMessage
 * 
 */
export type SlackMessage = $Result.DefaultSelection<Prisma.$SlackMessagePayload>
/**
 * Model SlackChannel
 * 
 */
export type SlackChannel = $Result.DefaultSelection<Prisma.$SlackChannelPayload>
/**
 * Model ZoomMeeting
 * 
 */
export type ZoomMeeting = $Result.DefaultSelection<Prisma.$ZoomMeetingPayload>
/**
 * Model ZoomParticipant
 * 
 */
export type ZoomParticipant = $Result.DefaultSelection<Prisma.$ZoomParticipantPayload>
/**
 * Model SalesforceAccount
 * 
 */
export type SalesforceAccount = $Result.DefaultSelection<Prisma.$SalesforceAccountPayload>
/**
 * Model SalesforceContact
 * 
 */
export type SalesforceContact = $Result.DefaultSelection<Prisma.$SalesforceContactPayload>
/**
 * Model SalesforceOpportunity
 * 
 */
export type SalesforceOpportunity = $Result.DefaultSelection<Prisma.$SalesforceOpportunityPayload>
/**
 * Model LPGroup
 * 
 */
export type LPGroup = $Result.DefaultSelection<Prisma.$LPGroupPayload>
/**
 * Model InvestorGroupMember
 * 
 */
export type InvestorGroupMember = $Result.DefaultSelection<Prisma.$InvestorGroupMemberPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreference`: Exposes CRUD operations for the **UserPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreference.findMany()
    * ```
    */
  get userPreference(): Prisma.UserPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communication`: Exposes CRUD operations for the **Communication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communications
    * const communications = await prisma.communication.findMany()
    * ```
    */
  get communication(): Prisma.CommunicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **Investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.InvestorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fund`: Exposes CRUD operations for the **Fund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funds
    * const funds = await prisma.fund.findMany()
    * ```
    */
  get fund(): Prisma.FundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investorEntity`: Exposes CRUD operations for the **InvestorEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorEntities
    * const investorEntities = await prisma.investorEntity.findMany()
    * ```
    */
  get investorEntity(): Prisma.InvestorEntityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncJob`: Exposes CRUD operations for the **SyncJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncJobs
    * const syncJobs = await prisma.syncJob.findMany()
    * ```
    */
  get syncJob(): Prisma.SyncJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamsMessage`: Exposes CRUD operations for the **TeamsMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamsMessages
    * const teamsMessages = await prisma.teamsMessage.findMany()
    * ```
    */
  get teamsMessage(): Prisma.TeamsMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamsChannel`: Exposes CRUD operations for the **TeamsChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamsChannels
    * const teamsChannels = await prisma.teamsChannel.findMany()
    * ```
    */
  get teamsChannel(): Prisma.TeamsChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slackMessage`: Exposes CRUD operations for the **SlackMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SlackMessages
    * const slackMessages = await prisma.slackMessage.findMany()
    * ```
    */
  get slackMessage(): Prisma.SlackMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.slackChannel`: Exposes CRUD operations for the **SlackChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SlackChannels
    * const slackChannels = await prisma.slackChannel.findMany()
    * ```
    */
  get slackChannel(): Prisma.SlackChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zoomMeeting`: Exposes CRUD operations for the **ZoomMeeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZoomMeetings
    * const zoomMeetings = await prisma.zoomMeeting.findMany()
    * ```
    */
  get zoomMeeting(): Prisma.ZoomMeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zoomParticipant`: Exposes CRUD operations for the **ZoomParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZoomParticipants
    * const zoomParticipants = await prisma.zoomParticipant.findMany()
    * ```
    */
  get zoomParticipant(): Prisma.ZoomParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesforceAccount`: Exposes CRUD operations for the **SalesforceAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesforceAccounts
    * const salesforceAccounts = await prisma.salesforceAccount.findMany()
    * ```
    */
  get salesforceAccount(): Prisma.SalesforceAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesforceContact`: Exposes CRUD operations for the **SalesforceContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesforceContacts
    * const salesforceContacts = await prisma.salesforceContact.findMany()
    * ```
    */
  get salesforceContact(): Prisma.SalesforceContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesforceOpportunity`: Exposes CRUD operations for the **SalesforceOpportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesforceOpportunities
    * const salesforceOpportunities = await prisma.salesforceOpportunity.findMany()
    * ```
    */
  get salesforceOpportunity(): Prisma.SalesforceOpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lPGroup`: Exposes CRUD operations for the **LPGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LPGroups
    * const lPGroups = await prisma.lPGroup.findMany()
    * ```
    */
  get lPGroup(): Prisma.LPGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investorGroupMember`: Exposes CRUD operations for the **InvestorGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestorGroupMembers
    * const investorGroupMembers = await prisma.investorGroupMember.findMany()
    * ```
    */
  get investorGroupMember(): Prisma.InvestorGroupMemberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    UserPreference: 'UserPreference',
    Integration: 'Integration',
    Deal: 'Deal',
    Contact: 'Contact',
    Activity: 'Activity',
    Document: 'Document',
    Communication: 'Communication',
    Investor: 'Investor',
    Fund: 'Fund',
    InvestorEntity: 'InvestorEntity',
    Report: 'Report',
    SyncJob: 'SyncJob',
    TeamsMessage: 'TeamsMessage',
    TeamsChannel: 'TeamsChannel',
    SlackMessage: 'SlackMessage',
    SlackChannel: 'SlackChannel',
    ZoomMeeting: 'ZoomMeeting',
    ZoomParticipant: 'ZoomParticipant',
    SalesforceAccount: 'SalesforceAccount',
    SalesforceContact: 'SalesforceContact',
    SalesforceOpportunity: 'SalesforceOpportunity',
    LPGroup: 'LPGroup',
    InvestorGroupMember: 'InvestorGroupMember'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "profile" | "userPreference" | "integration" | "deal" | "contact" | "activity" | "document" | "communication" | "investor" | "fund" | "investorEntity" | "report" | "syncJob" | "teamsMessage" | "teamsChannel" | "slackMessage" | "slackChannel" | "zoomMeeting" | "zoomParticipant" | "salesforceAccount" | "salesforceContact" | "salesforceOpportunity" | "lPGroup" | "investorGroupMember"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      UserPreference: {
        payload: Prisma.$UserPreferencePayload<ExtArgs>
        fields: Prisma.UserPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findFirst: {
            args: Prisma.UserPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findMany: {
            args: Prisma.UserPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          create: {
            args: Prisma.UserPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          createMany: {
            args: Prisma.UserPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          delete: {
            args: Prisma.UserPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          update: {
            args: Prisma.UserPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          deleteMany: {
            args: Prisma.UserPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          upsert: {
            args: Prisma.UserPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          aggregate: {
            args: Prisma.UserPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreference>
          }
          groupBy: {
            args: Prisma.UserPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DealUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Communication: {
        payload: Prisma.$CommunicationPayload<ExtArgs>
        fields: Prisma.CommunicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findFirst: {
            args: Prisma.CommunicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findMany: {
            args: Prisma.CommunicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          create: {
            args: Prisma.CommunicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          createMany: {
            args: Prisma.CommunicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          delete: {
            args: Prisma.CommunicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          update: {
            args: Prisma.CommunicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          upsert: {
            args: Prisma.CommunicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          aggregate: {
            args: Prisma.CommunicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunication>
          }
          groupBy: {
            args: Prisma.CommunicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunicationCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationCountAggregateOutputType> | number
          }
        }
      }
      Investor: {
        payload: Prisma.$InvestorPayload<ExtArgs>
        fields: Prisma.InvestorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findFirst: {
            args: Prisma.InvestorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          findMany: {
            args: Prisma.InvestorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          create: {
            args: Prisma.InvestorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          createMany: {
            args: Prisma.InvestorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          delete: {
            args: Prisma.InvestorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          update: {
            args: Prisma.InvestorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          deleteMany: {
            args: Prisma.InvestorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>[]
          }
          upsert: {
            args: Prisma.InvestorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.InvestorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      Fund: {
        payload: Prisma.$FundPayload<ExtArgs>
        fields: Prisma.FundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          findFirst: {
            args: Prisma.FundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          findMany: {
            args: Prisma.FundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>[]
          }
          create: {
            args: Prisma.FundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          createMany: {
            args: Prisma.FundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>[]
          }
          delete: {
            args: Prisma.FundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          update: {
            args: Prisma.FundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          deleteMany: {
            args: Prisma.FundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>[]
          }
          upsert: {
            args: Prisma.FundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FundPayload>
          }
          aggregate: {
            args: Prisma.FundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFund>
          }
          groupBy: {
            args: Prisma.FundGroupByArgs<ExtArgs>
            result: $Utils.Optional<FundGroupByOutputType>[]
          }
          count: {
            args: Prisma.FundCountArgs<ExtArgs>
            result: $Utils.Optional<FundCountAggregateOutputType> | number
          }
        }
      }
      InvestorEntity: {
        payload: Prisma.$InvestorEntityPayload<ExtArgs>
        fields: Prisma.InvestorEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>
          }
          findFirst: {
            args: Prisma.InvestorEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>
          }
          findMany: {
            args: Prisma.InvestorEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>[]
          }
          create: {
            args: Prisma.InvestorEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>
          }
          createMany: {
            args: Prisma.InvestorEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>[]
          }
          delete: {
            args: Prisma.InvestorEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>
          }
          update: {
            args: Prisma.InvestorEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>
          }
          deleteMany: {
            args: Prisma.InvestorEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorEntityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>[]
          }
          upsert: {
            args: Prisma.InvestorEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorEntityPayload>
          }
          aggregate: {
            args: Prisma.InvestorEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorEntity>
          }
          groupBy: {
            args: Prisma.InvestorEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorEntityCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorEntityCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      SyncJob: {
        payload: Prisma.$SyncJobPayload<ExtArgs>
        fields: Prisma.SyncJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>
          }
          findFirst: {
            args: Prisma.SyncJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>
          }
          findMany: {
            args: Prisma.SyncJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>[]
          }
          create: {
            args: Prisma.SyncJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>
          }
          createMany: {
            args: Prisma.SyncJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>[]
          }
          delete: {
            args: Prisma.SyncJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>
          }
          update: {
            args: Prisma.SyncJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>
          }
          deleteMany: {
            args: Prisma.SyncJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>[]
          }
          upsert: {
            args: Prisma.SyncJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncJobPayload>
          }
          aggregate: {
            args: Prisma.SyncJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncJob>
          }
          groupBy: {
            args: Prisma.SyncJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncJobCountArgs<ExtArgs>
            result: $Utils.Optional<SyncJobCountAggregateOutputType> | number
          }
        }
      }
      TeamsMessage: {
        payload: Prisma.$TeamsMessagePayload<ExtArgs>
        fields: Prisma.TeamsMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamsMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamsMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>
          }
          findFirst: {
            args: Prisma.TeamsMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamsMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>
          }
          findMany: {
            args: Prisma.TeamsMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>[]
          }
          create: {
            args: Prisma.TeamsMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>
          }
          createMany: {
            args: Prisma.TeamsMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamsMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>[]
          }
          delete: {
            args: Prisma.TeamsMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>
          }
          update: {
            args: Prisma.TeamsMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>
          }
          deleteMany: {
            args: Prisma.TeamsMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamsMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamsMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>[]
          }
          upsert: {
            args: Prisma.TeamsMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsMessagePayload>
          }
          aggregate: {
            args: Prisma.TeamsMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamsMessage>
          }
          groupBy: {
            args: Prisma.TeamsMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamsMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamsMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TeamsMessageCountAggregateOutputType> | number
          }
        }
      }
      TeamsChannel: {
        payload: Prisma.$TeamsChannelPayload<ExtArgs>
        fields: Prisma.TeamsChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamsChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamsChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>
          }
          findFirst: {
            args: Prisma.TeamsChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamsChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>
          }
          findMany: {
            args: Prisma.TeamsChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>[]
          }
          create: {
            args: Prisma.TeamsChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>
          }
          createMany: {
            args: Prisma.TeamsChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamsChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>[]
          }
          delete: {
            args: Prisma.TeamsChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>
          }
          update: {
            args: Prisma.TeamsChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>
          }
          deleteMany: {
            args: Prisma.TeamsChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamsChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamsChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>[]
          }
          upsert: {
            args: Prisma.TeamsChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamsChannelPayload>
          }
          aggregate: {
            args: Prisma.TeamsChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamsChannel>
          }
          groupBy: {
            args: Prisma.TeamsChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamsChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamsChannelCountArgs<ExtArgs>
            result: $Utils.Optional<TeamsChannelCountAggregateOutputType> | number
          }
        }
      }
      SlackMessage: {
        payload: Prisma.$SlackMessagePayload<ExtArgs>
        fields: Prisma.SlackMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlackMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlackMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>
          }
          findFirst: {
            args: Prisma.SlackMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlackMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>
          }
          findMany: {
            args: Prisma.SlackMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>[]
          }
          create: {
            args: Prisma.SlackMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>
          }
          createMany: {
            args: Prisma.SlackMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlackMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>[]
          }
          delete: {
            args: Prisma.SlackMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>
          }
          update: {
            args: Prisma.SlackMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>
          }
          deleteMany: {
            args: Prisma.SlackMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlackMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlackMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>[]
          }
          upsert: {
            args: Prisma.SlackMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackMessagePayload>
          }
          aggregate: {
            args: Prisma.SlackMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlackMessage>
          }
          groupBy: {
            args: Prisma.SlackMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlackMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlackMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SlackMessageCountAggregateOutputType> | number
          }
        }
      }
      SlackChannel: {
        payload: Prisma.$SlackChannelPayload<ExtArgs>
        fields: Prisma.SlackChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlackChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlackChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>
          }
          findFirst: {
            args: Prisma.SlackChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlackChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>
          }
          findMany: {
            args: Prisma.SlackChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>[]
          }
          create: {
            args: Prisma.SlackChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>
          }
          createMany: {
            args: Prisma.SlackChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SlackChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>[]
          }
          delete: {
            args: Prisma.SlackChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>
          }
          update: {
            args: Prisma.SlackChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>
          }
          deleteMany: {
            args: Prisma.SlackChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlackChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SlackChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>[]
          }
          upsert: {
            args: Prisma.SlackChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlackChannelPayload>
          }
          aggregate: {
            args: Prisma.SlackChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlackChannel>
          }
          groupBy: {
            args: Prisma.SlackChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlackChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlackChannelCountArgs<ExtArgs>
            result: $Utils.Optional<SlackChannelCountAggregateOutputType> | number
          }
        }
      }
      ZoomMeeting: {
        payload: Prisma.$ZoomMeetingPayload<ExtArgs>
        fields: Prisma.ZoomMeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoomMeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoomMeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>
          }
          findFirst: {
            args: Prisma.ZoomMeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoomMeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>
          }
          findMany: {
            args: Prisma.ZoomMeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>[]
          }
          create: {
            args: Prisma.ZoomMeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>
          }
          createMany: {
            args: Prisma.ZoomMeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoomMeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>[]
          }
          delete: {
            args: Prisma.ZoomMeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>
          }
          update: {
            args: Prisma.ZoomMeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>
          }
          deleteMany: {
            args: Prisma.ZoomMeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoomMeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoomMeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>[]
          }
          upsert: {
            args: Prisma.ZoomMeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomMeetingPayload>
          }
          aggregate: {
            args: Prisma.ZoomMeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZoomMeeting>
          }
          groupBy: {
            args: Prisma.ZoomMeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoomMeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoomMeetingCountArgs<ExtArgs>
            result: $Utils.Optional<ZoomMeetingCountAggregateOutputType> | number
          }
        }
      }
      ZoomParticipant: {
        payload: Prisma.$ZoomParticipantPayload<ExtArgs>
        fields: Prisma.ZoomParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoomParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoomParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>
          }
          findFirst: {
            args: Prisma.ZoomParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoomParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>
          }
          findMany: {
            args: Prisma.ZoomParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>[]
          }
          create: {
            args: Prisma.ZoomParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>
          }
          createMany: {
            args: Prisma.ZoomParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoomParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>[]
          }
          delete: {
            args: Prisma.ZoomParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>
          }
          update: {
            args: Prisma.ZoomParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ZoomParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoomParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZoomParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ZoomParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZoomParticipantPayload>
          }
          aggregate: {
            args: Prisma.ZoomParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZoomParticipant>
          }
          groupBy: {
            args: Prisma.ZoomParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoomParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoomParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ZoomParticipantCountAggregateOutputType> | number
          }
        }
      }
      SalesforceAccount: {
        payload: Prisma.$SalesforceAccountPayload<ExtArgs>
        fields: Prisma.SalesforceAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesforceAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesforceAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>
          }
          findFirst: {
            args: Prisma.SalesforceAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesforceAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>
          }
          findMany: {
            args: Prisma.SalesforceAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>[]
          }
          create: {
            args: Prisma.SalesforceAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>
          }
          createMany: {
            args: Prisma.SalesforceAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesforceAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>[]
          }
          delete: {
            args: Prisma.SalesforceAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>
          }
          update: {
            args: Prisma.SalesforceAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>
          }
          deleteMany: {
            args: Prisma.SalesforceAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesforceAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesforceAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>[]
          }
          upsert: {
            args: Prisma.SalesforceAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceAccountPayload>
          }
          aggregate: {
            args: Prisma.SalesforceAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesforceAccount>
          }
          groupBy: {
            args: Prisma.SalesforceAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesforceAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesforceAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SalesforceAccountCountAggregateOutputType> | number
          }
        }
      }
      SalesforceContact: {
        payload: Prisma.$SalesforceContactPayload<ExtArgs>
        fields: Prisma.SalesforceContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesforceContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesforceContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>
          }
          findFirst: {
            args: Prisma.SalesforceContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesforceContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>
          }
          findMany: {
            args: Prisma.SalesforceContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>[]
          }
          create: {
            args: Prisma.SalesforceContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>
          }
          createMany: {
            args: Prisma.SalesforceContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesforceContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>[]
          }
          delete: {
            args: Prisma.SalesforceContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>
          }
          update: {
            args: Prisma.SalesforceContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>
          }
          deleteMany: {
            args: Prisma.SalesforceContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesforceContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesforceContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>[]
          }
          upsert: {
            args: Prisma.SalesforceContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceContactPayload>
          }
          aggregate: {
            args: Prisma.SalesforceContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesforceContact>
          }
          groupBy: {
            args: Prisma.SalesforceContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesforceContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesforceContactCountArgs<ExtArgs>
            result: $Utils.Optional<SalesforceContactCountAggregateOutputType> | number
          }
        }
      }
      SalesforceOpportunity: {
        payload: Prisma.$SalesforceOpportunityPayload<ExtArgs>
        fields: Prisma.SalesforceOpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesforceOpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesforceOpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>
          }
          findFirst: {
            args: Prisma.SalesforceOpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesforceOpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>
          }
          findMany: {
            args: Prisma.SalesforceOpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>[]
          }
          create: {
            args: Prisma.SalesforceOpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>
          }
          createMany: {
            args: Prisma.SalesforceOpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesforceOpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>[]
          }
          delete: {
            args: Prisma.SalesforceOpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>
          }
          update: {
            args: Prisma.SalesforceOpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>
          }
          deleteMany: {
            args: Prisma.SalesforceOpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesforceOpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesforceOpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>[]
          }
          upsert: {
            args: Prisma.SalesforceOpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesforceOpportunityPayload>
          }
          aggregate: {
            args: Prisma.SalesforceOpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesforceOpportunity>
          }
          groupBy: {
            args: Prisma.SalesforceOpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesforceOpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesforceOpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<SalesforceOpportunityCountAggregateOutputType> | number
          }
        }
      }
      LPGroup: {
        payload: Prisma.$LPGroupPayload<ExtArgs>
        fields: Prisma.LPGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LPGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LPGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>
          }
          findFirst: {
            args: Prisma.LPGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LPGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>
          }
          findMany: {
            args: Prisma.LPGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>[]
          }
          create: {
            args: Prisma.LPGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>
          }
          createMany: {
            args: Prisma.LPGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LPGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>[]
          }
          delete: {
            args: Prisma.LPGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>
          }
          update: {
            args: Prisma.LPGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>
          }
          deleteMany: {
            args: Prisma.LPGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LPGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LPGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>[]
          }
          upsert: {
            args: Prisma.LPGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LPGroupPayload>
          }
          aggregate: {
            args: Prisma.LPGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLPGroup>
          }
          groupBy: {
            args: Prisma.LPGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<LPGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.LPGroupCountArgs<ExtArgs>
            result: $Utils.Optional<LPGroupCountAggregateOutputType> | number
          }
        }
      }
      InvestorGroupMember: {
        payload: Prisma.$InvestorGroupMemberPayload<ExtArgs>
        fields: Prisma.InvestorGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestorGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestorGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.InvestorGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestorGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>
          }
          findMany: {
            args: Prisma.InvestorGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>[]
          }
          create: {
            args: Prisma.InvestorGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>
          }
          createMany: {
            args: Prisma.InvestorGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestorGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.InvestorGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>
          }
          update: {
            args: Prisma.InvestorGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.InvestorGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestorGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestorGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.InvestorGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestorGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.InvestorGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestorGroupMember>
          }
          groupBy: {
            args: Prisma.InvestorGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestorGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupMemberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profile?: ProfileOmit
    userPreference?: UserPreferenceOmit
    integration?: IntegrationOmit
    deal?: DealOmit
    contact?: ContactOmit
    activity?: ActivityOmit
    document?: DocumentOmit
    communication?: CommunicationOmit
    investor?: InvestorOmit
    fund?: FundOmit
    investorEntity?: InvestorEntityOmit
    report?: ReportOmit
    syncJob?: SyncJobOmit
    teamsMessage?: TeamsMessageOmit
    teamsChannel?: TeamsChannelOmit
    slackMessage?: SlackMessageOmit
    slackChannel?: SlackChannelOmit
    zoomMeeting?: ZoomMeetingOmit
    zoomParticipant?: ZoomParticipantOmit
    salesforceAccount?: SalesforceAccountOmit
    salesforceContact?: SalesforceContactOmit
    salesforceOpportunity?: SalesforceOpportunityOmit
    lPGroup?: LPGroupOmit
    investorGroupMember?: InvestorGroupMemberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    integrations: number
    deals: number
    activities: number
    ownedContacts: number
    communications: number
    documents: number
    teamsMessages: number
    teamsChannels: number
    slackMessages: number
    slackChannels: number
    zoomMeetings: number
    zoomParticipants: number
    salesforceAccounts: number
    salesforceContacts: number
    salesforceOpportunities: number
    funds: number
    investors: number
    lpGroups: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integrations?: boolean | UserCountOutputTypeCountIntegrationsArgs
    deals?: boolean | UserCountOutputTypeCountDealsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    ownedContacts?: boolean | UserCountOutputTypeCountOwnedContactsArgs
    communications?: boolean | UserCountOutputTypeCountCommunicationsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    teamsMessages?: boolean | UserCountOutputTypeCountTeamsMessagesArgs
    teamsChannels?: boolean | UserCountOutputTypeCountTeamsChannelsArgs
    slackMessages?: boolean | UserCountOutputTypeCountSlackMessagesArgs
    slackChannels?: boolean | UserCountOutputTypeCountSlackChannelsArgs
    zoomMeetings?: boolean | UserCountOutputTypeCountZoomMeetingsArgs
    zoomParticipants?: boolean | UserCountOutputTypeCountZoomParticipantsArgs
    salesforceAccounts?: boolean | UserCountOutputTypeCountSalesforceAccountsArgs
    salesforceContacts?: boolean | UserCountOutputTypeCountSalesforceContactsArgs
    salesforceOpportunities?: boolean | UserCountOutputTypeCountSalesforceOpportunitiesArgs
    funds?: boolean | UserCountOutputTypeCountFundsArgs
    investors?: boolean | UserCountOutputTypeCountInvestorsArgs
    lpGroups?: boolean | UserCountOutputTypeCountLpGroupsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsChannelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSlackMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlackMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSlackChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlackChannelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZoomMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoomMeetingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountZoomParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoomParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesforceAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesforceContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceContactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesforceOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceOpportunityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FundWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvestorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLpGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LPGroupWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    contacts: number
    documents: number
    activities: number
    communications: number
    teamsMessages: number
    slackMessages: number
    zoomMeetings: number
    salesforceAccounts: number
    salesforceOpportunities: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | DealCountOutputTypeCountContactsArgs
    documents?: boolean | DealCountOutputTypeCountDocumentsArgs
    activities?: boolean | DealCountOutputTypeCountActivitiesArgs
    communications?: boolean | DealCountOutputTypeCountCommunicationsArgs
    teamsMessages?: boolean | DealCountOutputTypeCountTeamsMessagesArgs
    slackMessages?: boolean | DealCountOutputTypeCountSlackMessagesArgs
    zoomMeetings?: boolean | DealCountOutputTypeCountZoomMeetingsArgs
    salesforceAccounts?: boolean | DealCountOutputTypeCountSalesforceAccountsArgs
    salesforceOpportunities?: boolean | DealCountOutputTypeCountSalesforceOpportunitiesArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountTeamsMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsMessageWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountSlackMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlackMessageWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountZoomMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoomMeetingWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountSalesforceAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceAccountWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountSalesforceOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceOpportunityWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    activities: number
    communications: number
    teamsMessages: number
    slackMessages: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ContactCountOutputTypeCountActivitiesArgs
    communications?: boolean | ContactCountOutputTypeCountCommunicationsArgs
    teamsMessages?: boolean | ContactCountOutputTypeCountTeamsMessagesArgs
    slackMessages?: boolean | ContactCountOutputTypeCountSlackMessagesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTeamsMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsMessageWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountSlackMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlackMessageWhereInput
  }


  /**
   * Count Type InvestorCountOutputType
   */

  export type InvestorCountOutputType = {
    entities: number
    groupMemberships: number
  }

  export type InvestorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | InvestorCountOutputTypeCountEntitiesArgs
    groupMemberships?: boolean | InvestorCountOutputTypeCountGroupMembershipsArgs
  }

  // Custom InputTypes
  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorCountOutputType
     */
    select?: InvestorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorEntityWhereInput
  }

  /**
   * InvestorCountOutputType without action
   */
  export type InvestorCountOutputTypeCountGroupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorGroupMemberWhereInput
  }


  /**
   * Count Type ZoomMeetingCountOutputType
   */

  export type ZoomMeetingCountOutputType = {
    participants: number
  }

  export type ZoomMeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ZoomMeetingCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * ZoomMeetingCountOutputType without action
   */
  export type ZoomMeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeetingCountOutputType
     */
    select?: ZoomMeetingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoomMeetingCountOutputType without action
   */
  export type ZoomMeetingCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoomParticipantWhereInput
  }


  /**
   * Count Type SalesforceAccountCountOutputType
   */

  export type SalesforceAccountCountOutputType = {
    contacts: number
    opportunities: number
  }

  export type SalesforceAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | SalesforceAccountCountOutputTypeCountContactsArgs
    opportunities?: boolean | SalesforceAccountCountOutputTypeCountOpportunitiesArgs
  }

  // Custom InputTypes
  /**
   * SalesforceAccountCountOutputType without action
   */
  export type SalesforceAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccountCountOutputType
     */
    select?: SalesforceAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesforceAccountCountOutputType without action
   */
  export type SalesforceAccountCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceContactWhereInput
  }

  /**
   * SalesforceAccountCountOutputType without action
   */
  export type SalesforceAccountCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceOpportunityWhereInput
  }


  /**
   * Count Type LPGroupCountOutputType
   */

  export type LPGroupCountOutputType = {
    members: number
  }

  export type LPGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | LPGroupCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * LPGroupCountOutputType without action
   */
  export type LPGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroupCountOutputType
     */
    select?: LPGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LPGroupCountOutputType without action
   */
  export type LPGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorGroupMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    firm: string | null
    role: string | null
    phone: string | null
    location: string | null
    avatar: string | null
    emailVerified: boolean | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    firm: string | null
    role: string | null
    phone: string | null
    location: string | null
    avatar: string | null
    emailVerified: boolean | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    firm: number
    role: number
    phone: number
    location: number
    avatar: number
    emailVerified: number
    isActive: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    firm?: true
    role?: true
    phone?: true
    location?: true
    avatar?: true
    emailVerified?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    firm?: true
    role?: true
    phone?: true
    location?: true
    avatar?: true
    emailVerified?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    firm?: true
    role?: true
    phone?: true
    location?: true
    avatar?: true
    emailVerified?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    firm: string | null
    role: string | null
    phone: string | null
    location: string | null
    avatar: string | null
    emailVerified: boolean
    isActive: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firm?: boolean
    role?: boolean
    phone?: boolean
    location?: boolean
    avatar?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    integrations?: boolean | User$integrationsArgs<ExtArgs>
    deals?: boolean | User$dealsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    ownedContacts?: boolean | User$ownedContactsArgs<ExtArgs>
    communications?: boolean | User$communicationsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    teamsMessages?: boolean | User$teamsMessagesArgs<ExtArgs>
    teamsChannels?: boolean | User$teamsChannelsArgs<ExtArgs>
    slackMessages?: boolean | User$slackMessagesArgs<ExtArgs>
    slackChannels?: boolean | User$slackChannelsArgs<ExtArgs>
    zoomMeetings?: boolean | User$zoomMeetingsArgs<ExtArgs>
    zoomParticipants?: boolean | User$zoomParticipantsArgs<ExtArgs>
    salesforceAccounts?: boolean | User$salesforceAccountsArgs<ExtArgs>
    salesforceContacts?: boolean | User$salesforceContactsArgs<ExtArgs>
    salesforceOpportunities?: boolean | User$salesforceOpportunitiesArgs<ExtArgs>
    funds?: boolean | User$fundsArgs<ExtArgs>
    investors?: boolean | User$investorsArgs<ExtArgs>
    lpGroups?: boolean | User$lpGroupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firm?: boolean
    role?: boolean
    phone?: boolean
    location?: boolean
    avatar?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firm?: boolean
    role?: boolean
    phone?: boolean
    location?: boolean
    avatar?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    firm?: boolean
    role?: boolean
    phone?: boolean
    location?: boolean
    avatar?: boolean
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "firm" | "role" | "phone" | "location" | "avatar" | "emailVerified" | "isActive" | "lastLogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    integrations?: boolean | User$integrationsArgs<ExtArgs>
    deals?: boolean | User$dealsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    ownedContacts?: boolean | User$ownedContactsArgs<ExtArgs>
    communications?: boolean | User$communicationsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    teamsMessages?: boolean | User$teamsMessagesArgs<ExtArgs>
    teamsChannels?: boolean | User$teamsChannelsArgs<ExtArgs>
    slackMessages?: boolean | User$slackMessagesArgs<ExtArgs>
    slackChannels?: boolean | User$slackChannelsArgs<ExtArgs>
    zoomMeetings?: boolean | User$zoomMeetingsArgs<ExtArgs>
    zoomParticipants?: boolean | User$zoomParticipantsArgs<ExtArgs>
    salesforceAccounts?: boolean | User$salesforceAccountsArgs<ExtArgs>
    salesforceContacts?: boolean | User$salesforceContactsArgs<ExtArgs>
    salesforceOpportunities?: boolean | User$salesforceOpportunitiesArgs<ExtArgs>
    funds?: boolean | User$fundsArgs<ExtArgs>
    investors?: boolean | User$investorsArgs<ExtArgs>
    lpGroups?: boolean | User$lpGroupsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      ownedContacts: Prisma.$ContactPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      preferences: Prisma.$UserPreferencePayload<ExtArgs> | null
      teamsMessages: Prisma.$TeamsMessagePayload<ExtArgs>[]
      teamsChannels: Prisma.$TeamsChannelPayload<ExtArgs>[]
      slackMessages: Prisma.$SlackMessagePayload<ExtArgs>[]
      slackChannels: Prisma.$SlackChannelPayload<ExtArgs>[]
      zoomMeetings: Prisma.$ZoomMeetingPayload<ExtArgs>[]
      zoomParticipants: Prisma.$ZoomParticipantPayload<ExtArgs>[]
      salesforceAccounts: Prisma.$SalesforceAccountPayload<ExtArgs>[]
      salesforceContacts: Prisma.$SalesforceContactPayload<ExtArgs>[]
      salesforceOpportunities: Prisma.$SalesforceOpportunityPayload<ExtArgs>[]
      funds: Prisma.$FundPayload<ExtArgs>[]
      investors: Prisma.$InvestorPayload<ExtArgs>[]
      lpGroups: Prisma.$LPGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      firm: string | null
      role: string | null
      phone: string | null
      location: string | null
      avatar: string | null
      emailVerified: boolean
      isActive: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    integrations<T extends User$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deals<T extends User$dealsArgs<ExtArgs> = {}>(args?: Subset<T, User$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedContacts<T extends User$ownedContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends User$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teamsMessages<T extends User$teamsMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamsChannels<T extends User$teamsChannelsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slackMessages<T extends User$slackMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$slackMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slackChannels<T extends User$slackChannelsArgs<ExtArgs> = {}>(args?: Subset<T, User$slackChannelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zoomMeetings<T extends User$zoomMeetingsArgs<ExtArgs> = {}>(args?: Subset<T, User$zoomMeetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zoomParticipants<T extends User$zoomParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$zoomParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesforceAccounts<T extends User$salesforceAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$salesforceAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesforceContacts<T extends User$salesforceContactsArgs<ExtArgs> = {}>(args?: Subset<T, User$salesforceContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesforceOpportunities<T extends User$salesforceOpportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$salesforceOpportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    funds<T extends User$fundsArgs<ExtArgs> = {}>(args?: Subset<T, User$fundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    investors<T extends User$investorsArgs<ExtArgs> = {}>(args?: Subset<T, User$investorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lpGroups<T extends User$lpGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$lpGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly firm: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.integrations
   */
  export type User$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * User.deals
   */
  export type User$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.ownedContacts
   */
  export type User$ownedContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * User.communications
   */
  export type User$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
  }

  /**
   * User.teamsMessages
   */
  export type User$teamsMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    where?: TeamsMessageWhereInput
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    cursor?: TeamsMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsMessageScalarFieldEnum | TeamsMessageScalarFieldEnum[]
  }

  /**
   * User.teamsChannels
   */
  export type User$teamsChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    where?: TeamsChannelWhereInput
    orderBy?: TeamsChannelOrderByWithRelationInput | TeamsChannelOrderByWithRelationInput[]
    cursor?: TeamsChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsChannelScalarFieldEnum | TeamsChannelScalarFieldEnum[]
  }

  /**
   * User.slackMessages
   */
  export type User$slackMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    where?: SlackMessageWhereInput
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    cursor?: SlackMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlackMessageScalarFieldEnum | SlackMessageScalarFieldEnum[]
  }

  /**
   * User.slackChannels
   */
  export type User$slackChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    where?: SlackChannelWhereInput
    orderBy?: SlackChannelOrderByWithRelationInput | SlackChannelOrderByWithRelationInput[]
    cursor?: SlackChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlackChannelScalarFieldEnum | SlackChannelScalarFieldEnum[]
  }

  /**
   * User.zoomMeetings
   */
  export type User$zoomMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    where?: ZoomMeetingWhereInput
    orderBy?: ZoomMeetingOrderByWithRelationInput | ZoomMeetingOrderByWithRelationInput[]
    cursor?: ZoomMeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoomMeetingScalarFieldEnum | ZoomMeetingScalarFieldEnum[]
  }

  /**
   * User.zoomParticipants
   */
  export type User$zoomParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    where?: ZoomParticipantWhereInput
    orderBy?: ZoomParticipantOrderByWithRelationInput | ZoomParticipantOrderByWithRelationInput[]
    cursor?: ZoomParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoomParticipantScalarFieldEnum | ZoomParticipantScalarFieldEnum[]
  }

  /**
   * User.salesforceAccounts
   */
  export type User$salesforceAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    where?: SalesforceAccountWhereInput
    orderBy?: SalesforceAccountOrderByWithRelationInput | SalesforceAccountOrderByWithRelationInput[]
    cursor?: SalesforceAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceAccountScalarFieldEnum | SalesforceAccountScalarFieldEnum[]
  }

  /**
   * User.salesforceContacts
   */
  export type User$salesforceContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    where?: SalesforceContactWhereInput
    orderBy?: SalesforceContactOrderByWithRelationInput | SalesforceContactOrderByWithRelationInput[]
    cursor?: SalesforceContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceContactScalarFieldEnum | SalesforceContactScalarFieldEnum[]
  }

  /**
   * User.salesforceOpportunities
   */
  export type User$salesforceOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    where?: SalesforceOpportunityWhereInput
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    cursor?: SalesforceOpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceOpportunityScalarFieldEnum | SalesforceOpportunityScalarFieldEnum[]
  }

  /**
   * User.funds
   */
  export type User$fundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    where?: FundWhereInput
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    cursor?: FundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * User.investors
   */
  export type User$investorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    cursor?: InvestorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * User.lpGroups
   */
  export type User$lpGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    where?: LPGroupWhereInput
    orderBy?: LPGroupOrderByWithRelationInput | LPGroupOrderByWithRelationInput[]
    cursor?: LPGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LPGroupScalarFieldEnum | LPGroupScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    bio: string | null
    joinDate: Date | null
    timezone: string | null
    language: string | null
    theme: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    bio: string | null
    joinDate: Date | null
    timezone: string | null
    language: string | null
    theme: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    bio: number
    joinDate: number
    timezone: number
    language: number
    theme: number
    notifications: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    bio?: true
    joinDate?: true
    timezone?: true
    language?: true
    theme?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    bio?: true
    joinDate?: true
    timezone?: true
    language?: true
    theme?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    bio?: true
    joinDate?: true
    timezone?: true
    language?: true
    theme?: true
    notifications?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    title: string | null
    bio: string | null
    joinDate: Date
    timezone: string
    language: string
    theme: string
    notifications: JsonValue | null
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    bio?: boolean
    joinDate?: boolean
    timezone?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    bio?: boolean
    joinDate?: boolean
    timezone?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    bio?: boolean
    joinDate?: boolean
    timezone?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    bio?: boolean
    joinDate?: boolean
    timezone?: boolean
    language?: boolean
    theme?: boolean
    notifications?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "bio" | "joinDate" | "timezone" | "language" | "theme" | "notifications" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string | null
      bio: string | null
      joinDate: Date
      timezone: string
      language: string
      theme: string
      notifications: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly title: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly joinDate: FieldRef<"Profile", 'DateTime'>
    readonly timezone: FieldRef<"Profile", 'String'>
    readonly language: FieldRef<"Profile", 'String'>
    readonly theme: FieldRef<"Profile", 'String'>
    readonly notifications: FieldRef<"Profile", 'Json'>
    readonly settings: FieldRef<"Profile", 'Json'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserPreference
   */

  export type AggregateUserPreference = {
    _count: UserPreferenceCountAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  export type UserPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotify: boolean | null
    pushNotify: boolean | null
    smsNotify: boolean | null
    calendarNotify: boolean | null
    dealNotify: boolean | null
    autoSave: boolean | null
    darkMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    emailNotify: boolean | null
    pushNotify: boolean | null
    smsNotify: boolean | null
    calendarNotify: boolean | null
    dealNotify: boolean | null
    autoSave: boolean | null
    darkMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    emailNotify: number
    pushNotify: number
    smsNotify: number
    calendarNotify: number
    dealNotify: number
    autoSave: number
    darkMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    emailNotify?: true
    pushNotify?: true
    smsNotify?: true
    calendarNotify?: true
    dealNotify?: true
    autoSave?: true
    darkMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    emailNotify?: true
    pushNotify?: true
    smsNotify?: true
    calendarNotify?: true
    dealNotify?: true
    autoSave?: true
    darkMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    emailNotify?: true
    pushNotify?: true
    smsNotify?: true
    calendarNotify?: true
    dealNotify?: true
    autoSave?: true
    darkMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreference to aggregate.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type GetUserPreferenceAggregateType<T extends UserPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreference[P]>
      : GetScalarType<T[P], AggregateUserPreference[P]>
  }




  export type UserPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithAggregationInput | UserPreferenceOrderByWithAggregationInput[]
    by: UserPreferenceScalarFieldEnum[] | UserPreferenceScalarFieldEnum
    having?: UserPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferenceCountAggregateInputType | true
    _min?: UserPreferenceMinAggregateInputType
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type UserPreferenceGroupByOutputType = {
    id: string
    userId: string
    emailNotify: boolean
    pushNotify: boolean
    smsNotify: boolean
    calendarNotify: boolean
    dealNotify: boolean
    autoSave: boolean
    darkMode: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserPreferenceCountAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  type GetUserPreferenceGroupByPayload<T extends UserPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "emailNotify" | "pushNotify" | "smsNotify" | "calendarNotify" | "dealNotify" | "autoSave" | "darkMode" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreference"]>
  export type UserPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      emailNotify: boolean
      pushNotify: boolean
      smsNotify: boolean
      calendarNotify: boolean
      dealNotify: boolean
      autoSave: boolean
      darkMode: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreference"]>
    composites: {}
  }

  type UserPreferenceGetPayload<S extends boolean | null | undefined | UserPreferenceDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencePayload, S>

  type UserPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferenceCountAggregateInputType | true
    }

  export interface UserPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreference'], meta: { name: 'UserPreference' } }
    /**
     * Find zero or one UserPreference that matches the filter.
     * @param {UserPreferenceFindUniqueArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferenceFindUniqueArgs>(args: SelectSubset<T, UserPreferenceFindUniqueArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferenceFindUniqueOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferenceFindFirstArgs>(args?: SelectSubset<T, UserPreferenceFindFirstArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreference.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferenceFindManyArgs>(args?: SelectSubset<T, UserPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreference.
     * @param {UserPreferenceCreateArgs} args - Arguments to create a UserPreference.
     * @example
     * // Create one UserPreference
     * const UserPreference = await prisma.userPreference.create({
     *   data: {
     *     // ... data to create a UserPreference
     *   }
     * })
     * 
     */
    create<T extends UserPreferenceCreateArgs>(args: SelectSubset<T, UserPreferenceCreateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferenceCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferenceCreateManyArgs>(args?: SelectSubset<T, UserPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferenceCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreference.
     * @param {UserPreferenceDeleteArgs} args - Arguments to delete one UserPreference.
     * @example
     * // Delete one UserPreference
     * const UserPreference = await prisma.userPreference.delete({
     *   where: {
     *     // ... filter to delete one UserPreference
     *   }
     * })
     * 
     */
    delete<T extends UserPreferenceDeleteArgs>(args: SelectSubset<T, UserPreferenceDeleteArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreference.
     * @param {UserPreferenceUpdateArgs} args - Arguments to update one UserPreference.
     * @example
     * // Update one UserPreference
     * const userPreference = await prisma.userPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferenceUpdateArgs>(args: SelectSubset<T, UserPreferenceUpdateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferenceDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferenceDeleteManyArgs>(args?: SelectSubset<T, UserPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferenceUpdateManyArgs>(args: SelectSubset<T, UserPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferenceUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreference.
     * @param {UserPreferenceUpsertArgs} args - Arguments to update or create a UserPreference.
     * @example
     * // Update or create a UserPreference
     * const userPreference = await prisma.userPreference.upsert({
     *   create: {
     *     // ... data to create a UserPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreference we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferenceUpsertArgs>(args: SelectSubset<T, UserPreferenceUpsertArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreference.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferenceCountArgs>(
      args?: Subset<T, UserPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferenceAggregateArgs>(args: Subset<T, UserPreferenceAggregateArgs>): Prisma.PrismaPromise<GetUserPreferenceAggregateType<T>>

    /**
     * Group by UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreference model
   */
  readonly fields: UserPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreference model
   */
  interface UserPreferenceFieldRefs {
    readonly id: FieldRef<"UserPreference", 'String'>
    readonly userId: FieldRef<"UserPreference", 'String'>
    readonly emailNotify: FieldRef<"UserPreference", 'Boolean'>
    readonly pushNotify: FieldRef<"UserPreference", 'Boolean'>
    readonly smsNotify: FieldRef<"UserPreference", 'Boolean'>
    readonly calendarNotify: FieldRef<"UserPreference", 'Boolean'>
    readonly dealNotify: FieldRef<"UserPreference", 'Boolean'>
    readonly autoSave: FieldRef<"UserPreference", 'Boolean'>
    readonly darkMode: FieldRef<"UserPreference", 'Boolean'>
    readonly createdAt: FieldRef<"UserPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreference findUnique
   */
  export type UserPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findUniqueOrThrow
   */
  export type UserPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findFirst
   */
  export type UserPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findFirstOrThrow
   */
  export type UserPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findMany
   */
  export type UserPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference create
   */
  export type UserPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreference.
     */
    data: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
  }

  /**
   * UserPreference createMany
   */
  export type UserPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreference createManyAndReturn
   */
  export type UserPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreference update
   */
  export type UserPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreference.
     */
    data: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
    /**
     * Choose, which UserPreference to update.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference updateMany
   */
  export type UserPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreference updateManyAndReturn
   */
  export type UserPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreference upsert
   */
  export type UserPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreference to update in case it exists.
     */
    where: UserPreferenceWhereUniqueInput
    /**
     * In case the UserPreference found by the `where` argument doesn't exist, create a new UserPreference with this data.
     */
    create: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
    /**
     * In case the UserPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
  }

  /**
   * UserPreference delete
   */
  export type UserPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter which UserPreference to delete.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference deleteMany
   */
  export type UserPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreference without action
   */
  export type UserPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    type: string | null
    isActive: boolean | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    lastSync: Date | null
    syncStatus: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    type: string | null
    isActive: boolean | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    lastSync: Date | null
    syncStatus: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    type: number
    isActive: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    scope: number
    profile: number
    settings: number
    lastSync: number
    syncStatus: number
    errorMessage: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    type?: true
    isActive?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    lastSync?: true
    syncStatus?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    type?: true
    isActive?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    lastSync?: true
    syncStatus?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    type?: true
    isActive?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    scope?: true
    profile?: true
    settings?: true
    lastSync?: true
    syncStatus?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    userId: string
    provider: string
    type: string
    isActive: boolean
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    scope: string[]
    profile: JsonValue | null
    settings: JsonValue | null
    lastSync: Date | null
    syncStatus: string
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    type?: boolean
    isActive?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    profile?: boolean
    settings?: boolean
    lastSync?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    type?: boolean
    isActive?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    profile?: boolean
    settings?: boolean
    lastSync?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    type?: boolean
    isActive?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    profile?: boolean
    settings?: boolean
    lastSync?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    type?: boolean
    isActive?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    profile?: boolean
    settings?: boolean
    lastSync?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "type" | "isActive" | "accessToken" | "refreshToken" | "expiresAt" | "scope" | "profile" | "settings" | "lastSync" | "syncStatus" | "errorMessage" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      type: string
      isActive: boolean
      accessToken: string | null
      refreshToken: string | null
      expiresAt: Date | null
      scope: string[]
      profile: Prisma.JsonValue | null
      settings: Prisma.JsonValue | null
      lastSync: Date | null
      syncStatus: string
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {IntegrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly userId: FieldRef<"Integration", 'String'>
    readonly provider: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'String'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly accessToken: FieldRef<"Integration", 'String'>
    readonly refreshToken: FieldRef<"Integration", 'String'>
    readonly expiresAt: FieldRef<"Integration", 'DateTime'>
    readonly scope: FieldRef<"Integration", 'String[]'>
    readonly profile: FieldRef<"Integration", 'Json'>
    readonly settings: FieldRef<"Integration", 'Json'>
    readonly lastSync: FieldRef<"Integration", 'DateTime'>
    readonly syncStatus: FieldRef<"Integration", 'String'>
    readonly errorMessage: FieldRef<"Integration", 'String'>
    readonly metadata: FieldRef<"Integration", 'Json'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration updateManyAndReturn
   */
  export type IntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    value: number | null
    probability: number | null
  }

  export type DealSumAggregateOutputType = {
    value: number | null
    probability: number | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    description: string | null
    sector: string | null
    stage: string | null
    status: string | null
    value: number | null
    probability: number | null
    leadPartner: string | null
    priority: string | null
    targetClose: Date | null
    actualClose: Date | null
    nextStep: string | null
    lastActivity: Date | null
    source: string | null
    geography: string | null
    dealSize: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    company: string | null
    description: string | null
    sector: string | null
    stage: string | null
    status: string | null
    value: number | null
    probability: number | null
    leadPartner: string | null
    priority: string | null
    targetClose: Date | null
    actualClose: Date | null
    nextStep: string | null
    lastActivity: Date | null
    source: string | null
    geography: string | null
    dealSize: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    userId: number
    company: number
    description: number
    sector: number
    stage: number
    status: number
    value: number
    probability: number
    leadPartner: number
    team: number
    tags: number
    priority: number
    targetClose: number
    actualClose: number
    nextStep: number
    lastActivity: number
    source: number
    geography: number
    dealSize: number
    metrics: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealSumAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    description?: true
    sector?: true
    stage?: true
    status?: true
    value?: true
    probability?: true
    leadPartner?: true
    priority?: true
    targetClose?: true
    actualClose?: true
    nextStep?: true
    lastActivity?: true
    source?: true
    geography?: true
    dealSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    description?: true
    sector?: true
    stage?: true
    status?: true
    value?: true
    probability?: true
    leadPartner?: true
    priority?: true
    targetClose?: true
    actualClose?: true
    nextStep?: true
    lastActivity?: true
    source?: true
    geography?: true
    dealSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    userId?: true
    company?: true
    description?: true
    sector?: true
    stage?: true
    status?: true
    value?: true
    probability?: true
    leadPartner?: true
    team?: true
    tags?: true
    priority?: true
    targetClose?: true
    actualClose?: true
    nextStep?: true
    lastActivity?: true
    source?: true
    geography?: true
    dealSize?: true
    metrics?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    userId: string
    company: string
    description: string | null
    sector: string | null
    stage: string
    status: string
    value: number | null
    probability: number | null
    leadPartner: string | null
    team: string[]
    tags: string[]
    priority: string
    targetClose: Date | null
    actualClose: Date | null
    nextStep: string | null
    lastActivity: Date | null
    source: string | null
    geography: string | null
    dealSize: string | null
    metrics: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    description?: boolean
    sector?: boolean
    stage?: boolean
    status?: boolean
    value?: boolean
    probability?: boolean
    leadPartner?: boolean
    team?: boolean
    tags?: boolean
    priority?: boolean
    targetClose?: boolean
    actualClose?: boolean
    nextStep?: boolean
    lastActivity?: boolean
    source?: boolean
    geography?: boolean
    dealSize?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Deal$contactsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    activities?: boolean | Deal$activitiesArgs<ExtArgs>
    communications?: boolean | Deal$communicationsArgs<ExtArgs>
    teamsMessages?: boolean | Deal$teamsMessagesArgs<ExtArgs>
    slackMessages?: boolean | Deal$slackMessagesArgs<ExtArgs>
    zoomMeetings?: boolean | Deal$zoomMeetingsArgs<ExtArgs>
    salesforceAccounts?: boolean | Deal$salesforceAccountsArgs<ExtArgs>
    salesforceOpportunities?: boolean | Deal$salesforceOpportunitiesArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    description?: boolean
    sector?: boolean
    stage?: boolean
    status?: boolean
    value?: boolean
    probability?: boolean
    leadPartner?: boolean
    team?: boolean
    tags?: boolean
    priority?: boolean
    targetClose?: boolean
    actualClose?: boolean
    nextStep?: boolean
    lastActivity?: boolean
    source?: boolean
    geography?: boolean
    dealSize?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    company?: boolean
    description?: boolean
    sector?: boolean
    stage?: boolean
    status?: boolean
    value?: boolean
    probability?: boolean
    leadPartner?: boolean
    team?: boolean
    tags?: boolean
    priority?: boolean
    targetClose?: boolean
    actualClose?: boolean
    nextStep?: boolean
    lastActivity?: boolean
    source?: boolean
    geography?: boolean
    dealSize?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    userId?: boolean
    company?: boolean
    description?: boolean
    sector?: boolean
    stage?: boolean
    status?: boolean
    value?: boolean
    probability?: boolean
    leadPartner?: boolean
    team?: boolean
    tags?: boolean
    priority?: boolean
    targetClose?: boolean
    actualClose?: boolean
    nextStep?: boolean
    lastActivity?: boolean
    source?: boolean
    geography?: boolean
    dealSize?: boolean
    metrics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "company" | "description" | "sector" | "stage" | "status" | "value" | "probability" | "leadPartner" | "team" | "tags" | "priority" | "targetClose" | "actualClose" | "nextStep" | "lastActivity" | "source" | "geography" | "dealSize" | "metrics" | "createdAt" | "updatedAt", ExtArgs["result"]["deal"]>
  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Deal$contactsArgs<ExtArgs>
    documents?: boolean | Deal$documentsArgs<ExtArgs>
    activities?: boolean | Deal$activitiesArgs<ExtArgs>
    communications?: boolean | Deal$communicationsArgs<ExtArgs>
    teamsMessages?: boolean | Deal$teamsMessagesArgs<ExtArgs>
    slackMessages?: boolean | Deal$slackMessagesArgs<ExtArgs>
    zoomMeetings?: boolean | Deal$zoomMeetingsArgs<ExtArgs>
    salesforceAccounts?: boolean | Deal$salesforceAccountsArgs<ExtArgs>
    salesforceOpportunities?: boolean | Deal$salesforceOpportunitiesArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DealIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
      teamsMessages: Prisma.$TeamsMessagePayload<ExtArgs>[]
      slackMessages: Prisma.$SlackMessagePayload<ExtArgs>[]
      zoomMeetings: Prisma.$ZoomMeetingPayload<ExtArgs>[]
      salesforceAccounts: Prisma.$SalesforceAccountPayload<ExtArgs>[]
      salesforceOpportunities: Prisma.$SalesforceOpportunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      company: string
      description: string | null
      sector: string | null
      stage: string
      status: string
      value: number | null
      probability: number | null
      leadPartner: string | null
      team: string[]
      tags: string[]
      priority: string
      targetClose: Date | null
      actualClose: Date | null
      nextStep: string | null
      lastActivity: Date | null
      source: string | null
      geography: string | null
      dealSize: string | null
      metrics: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deals and returns the data saved in the database.
     * @param {DealCreateManyAndReturnArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealCreateManyAndReturnArgs>(args?: SelectSubset<T, DealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals and returns the data updated in the database.
     * @param {DealUpdateManyAndReturnArgs} args - Arguments to update many Deals.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DealUpdateManyAndReturnArgs>(args: SelectSubset<T, DealUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contacts<T extends Deal$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Deal$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends Deal$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends Deal$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamsMessages<T extends Deal$teamsMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$teamsMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slackMessages<T extends Deal$slackMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$slackMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zoomMeetings<T extends Deal$zoomMeetingsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$zoomMeetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesforceAccounts<T extends Deal$salesforceAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$salesforceAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesforceOpportunities<T extends Deal$salesforceOpportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Deal$salesforceOpportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly userId: FieldRef<"Deal", 'String'>
    readonly company: FieldRef<"Deal", 'String'>
    readonly description: FieldRef<"Deal", 'String'>
    readonly sector: FieldRef<"Deal", 'String'>
    readonly stage: FieldRef<"Deal", 'String'>
    readonly status: FieldRef<"Deal", 'String'>
    readonly value: FieldRef<"Deal", 'Float'>
    readonly probability: FieldRef<"Deal", 'Float'>
    readonly leadPartner: FieldRef<"Deal", 'String'>
    readonly team: FieldRef<"Deal", 'String[]'>
    readonly tags: FieldRef<"Deal", 'String[]'>
    readonly priority: FieldRef<"Deal", 'String'>
    readonly targetClose: FieldRef<"Deal", 'DateTime'>
    readonly actualClose: FieldRef<"Deal", 'DateTime'>
    readonly nextStep: FieldRef<"Deal", 'String'>
    readonly lastActivity: FieldRef<"Deal", 'DateTime'>
    readonly source: FieldRef<"Deal", 'String'>
    readonly geography: FieldRef<"Deal", 'String'>
    readonly dealSize: FieldRef<"Deal", 'String'>
    readonly metrics: FieldRef<"Deal", 'Json'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal createManyAndReturn
   */
  export type DealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
  }

  /**
   * Deal updateManyAndReturn
   */
  export type DealUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to delete.
     */
    limit?: number
  }

  /**
   * Deal.contacts
   */
  export type Deal$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Deal.documents
   */
  export type Deal$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Deal.activities
   */
  export type Deal$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Deal.communications
   */
  export type Deal$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Deal.teamsMessages
   */
  export type Deal$teamsMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    where?: TeamsMessageWhereInput
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    cursor?: TeamsMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsMessageScalarFieldEnum | TeamsMessageScalarFieldEnum[]
  }

  /**
   * Deal.slackMessages
   */
  export type Deal$slackMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    where?: SlackMessageWhereInput
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    cursor?: SlackMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlackMessageScalarFieldEnum | SlackMessageScalarFieldEnum[]
  }

  /**
   * Deal.zoomMeetings
   */
  export type Deal$zoomMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    where?: ZoomMeetingWhereInput
    orderBy?: ZoomMeetingOrderByWithRelationInput | ZoomMeetingOrderByWithRelationInput[]
    cursor?: ZoomMeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoomMeetingScalarFieldEnum | ZoomMeetingScalarFieldEnum[]
  }

  /**
   * Deal.salesforceAccounts
   */
  export type Deal$salesforceAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    where?: SalesforceAccountWhereInput
    orderBy?: SalesforceAccountOrderByWithRelationInput | SalesforceAccountOrderByWithRelationInput[]
    cursor?: SalesforceAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceAccountScalarFieldEnum | SalesforceAccountScalarFieldEnum[]
  }

  /**
   * Deal.salesforceOpportunities
   */
  export type Deal$salesforceOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    where?: SalesforceOpportunityWhereInput
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    cursor?: SalesforceOpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceOpportunityScalarFieldEnum | SalesforceOpportunityScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    relationshipScore: number | null
  }

  export type ContactSumAggregateOutputType = {
    relationshipScore: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    googleContactId: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    title: string | null
    role: string | null
    linkedinUrl: string | null
    avatar: string | null
    notes: string | null
    relationshipScore: number | null
    lastContact: Date | null
    status: string | null
    isKeyContact: boolean | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    googleContactId: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    title: string | null
    role: string | null
    linkedinUrl: string | null
    avatar: string | null
    notes: string | null
    relationshipScore: number | null
    lastContact: Date | null
    status: string | null
    isKeyContact: boolean | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    googleContactId: number
    name: number
    email: number
    phone: number
    company: number
    title: number
    role: number
    linkedinUrl: number
    avatar: number
    notes: number
    tags: number
    relationshipScore: number
    lastContact: number
    status: number
    isKeyContact: number
    source: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    relationshipScore?: true
  }

  export type ContactSumAggregateInputType = {
    relationshipScore?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    googleContactId?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    title?: true
    role?: true
    linkedinUrl?: true
    avatar?: true
    notes?: true
    relationshipScore?: true
    lastContact?: true
    status?: true
    isKeyContact?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    googleContactId?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    title?: true
    role?: true
    linkedinUrl?: true
    avatar?: true
    notes?: true
    relationshipScore?: true
    lastContact?: true
    status?: true
    isKeyContact?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    googleContactId?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    title?: true
    role?: true
    linkedinUrl?: true
    avatar?: true
    notes?: true
    tags?: true
    relationshipScore?: true
    lastContact?: true
    status?: true
    isKeyContact?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    googleContactId: string | null
    name: string
    email: string | null
    phone: string | null
    company: string | null
    title: string | null
    role: string | null
    linkedinUrl: string | null
    avatar: string | null
    notes: string | null
    tags: string[]
    relationshipScore: number | null
    lastContact: Date | null
    status: string
    isKeyContact: boolean
    source: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    googleContactId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    role?: boolean
    linkedinUrl?: boolean
    avatar?: boolean
    notes?: boolean
    tags?: boolean
    relationshipScore?: boolean
    lastContact?: boolean
    status?: boolean
    isKeyContact?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Contact$dealArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    communications?: boolean | Contact$communicationsArgs<ExtArgs>
    teamsMessages?: boolean | Contact$teamsMessagesArgs<ExtArgs>
    slackMessages?: boolean | Contact$slackMessagesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    googleContactId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    role?: boolean
    linkedinUrl?: boolean
    avatar?: boolean
    notes?: boolean
    tags?: boolean
    relationshipScore?: boolean
    lastContact?: boolean
    status?: boolean
    isKeyContact?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Contact$dealArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    googleContactId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    role?: boolean
    linkedinUrl?: boolean
    avatar?: boolean
    notes?: boolean
    tags?: boolean
    relationshipScore?: boolean
    lastContact?: boolean
    status?: boolean
    isKeyContact?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Contact$dealArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    googleContactId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    title?: boolean
    role?: boolean
    linkedinUrl?: boolean
    avatar?: boolean
    notes?: boolean
    tags?: boolean
    relationshipScore?: boolean
    lastContact?: boolean
    status?: boolean
    isKeyContact?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "googleContactId" | "name" | "email" | "phone" | "company" | "title" | "role" | "linkedinUrl" | "avatar" | "notes" | "tags" | "relationshipScore" | "lastContact" | "status" | "isKeyContact" | "source" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Contact$dealArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    communications?: boolean | Contact$communicationsArgs<ExtArgs>
    teamsMessages?: boolean | Contact$teamsMessagesArgs<ExtArgs>
    slackMessages?: boolean | Contact$slackMessagesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Contact$dealArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Contact$dealArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
      teamsMessages: Prisma.$TeamsMessagePayload<ExtArgs>[]
      slackMessages: Prisma.$SlackMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      googleContactId: string | null
      name: string
      email: string | null
      phone: string | null
      company: string | null
      title: string | null
      role: string | null
      linkedinUrl: string | null
      avatar: string | null
      notes: string | null
      tags: string[]
      relationshipScore: number | null
      lastContact: Date | null
      status: string
      isKeyContact: boolean
      source: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends Contact$dealArgs<ExtArgs> = {}>(args?: Subset<T, Contact$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activities<T extends Contact$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    communications<T extends Contact$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamsMessages<T extends Contact$teamsMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$teamsMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slackMessages<T extends Contact$slackMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$slackMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly userId: FieldRef<"Contact", 'String'>
    readonly dealId: FieldRef<"Contact", 'String'>
    readonly googleContactId: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly title: FieldRef<"Contact", 'String'>
    readonly role: FieldRef<"Contact", 'String'>
    readonly linkedinUrl: FieldRef<"Contact", 'String'>
    readonly avatar: FieldRef<"Contact", 'String'>
    readonly notes: FieldRef<"Contact", 'String'>
    readonly tags: FieldRef<"Contact", 'String[]'>
    readonly relationshipScore: FieldRef<"Contact", 'Float'>
    readonly lastContact: FieldRef<"Contact", 'DateTime'>
    readonly status: FieldRef<"Contact", 'String'>
    readonly isKeyContact: FieldRef<"Contact", 'Boolean'>
    readonly source: FieldRef<"Contact", 'String'>
    readonly metadata: FieldRef<"Contact", 'Json'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.deal
   */
  export type Contact$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Contact.activities
   */
  export type Contact$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Contact.communications
   */
  export type Contact$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Contact.teamsMessages
   */
  export type Contact$teamsMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    where?: TeamsMessageWhereInput
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    cursor?: TeamsMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamsMessageScalarFieldEnum | TeamsMessageScalarFieldEnum[]
  }

  /**
   * Contact.slackMessages
   */
  export type Contact$slackMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    where?: SlackMessageWhereInput
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    cursor?: SlackMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SlackMessageScalarFieldEnum | SlackMessageScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    duration: number | null
  }

  export type ActivitySumAggregateOutputType = {
    duration: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    type: string | null
    title: string | null
    description: string | null
    content: string | null
    date: Date | null
    duration: number | null
    location: string | null
    status: string | null
    priority: string | null
    outcome: string | null
    nextSteps: string | null
    externalId: string | null
    syncedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    type: string | null
    title: string | null
    description: string | null
    content: string | null
    date: Date | null
    duration: number | null
    location: string | null
    status: string | null
    priority: string | null
    outcome: string | null
    nextSteps: string | null
    externalId: string | null
    syncedFrom: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    contactId: number
    type: number
    title: number
    description: number
    content: number
    date: number
    duration: number
    location: number
    attendees: number
    status: number
    priority: number
    outcome: number
    nextSteps: number
    metadata: number
    externalId: number
    syncedFrom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    duration?: true
  }

  export type ActivitySumAggregateInputType = {
    duration?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    type?: true
    title?: true
    description?: true
    content?: true
    date?: true
    duration?: true
    location?: true
    status?: true
    priority?: true
    outcome?: true
    nextSteps?: true
    externalId?: true
    syncedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    type?: true
    title?: true
    description?: true
    content?: true
    date?: true
    duration?: true
    location?: true
    status?: true
    priority?: true
    outcome?: true
    nextSteps?: true
    externalId?: true
    syncedFrom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    type?: true
    title?: true
    description?: true
    content?: true
    date?: true
    duration?: true
    location?: true
    attendees?: true
    status?: true
    priority?: true
    outcome?: true
    nextSteps?: true
    metadata?: true
    externalId?: true
    syncedFrom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    contactId: string | null
    type: string
    title: string
    description: string | null
    content: string | null
    date: Date
    duration: number | null
    location: string | null
    attendees: string[]
    status: string
    priority: string
    outcome: string | null
    nextSteps: string | null
    metadata: JsonValue | null
    externalId: string | null
    syncedFrom: string | null
    createdAt: Date
    updatedAt: Date
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    date?: boolean
    duration?: boolean
    location?: boolean
    attendees?: boolean
    status?: boolean
    priority?: boolean
    outcome?: boolean
    nextSteps?: boolean
    metadata?: boolean
    externalId?: boolean
    syncedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    date?: boolean
    duration?: boolean
    location?: boolean
    attendees?: boolean
    status?: boolean
    priority?: boolean
    outcome?: boolean
    nextSteps?: boolean
    metadata?: boolean
    externalId?: boolean
    syncedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    date?: boolean
    duration?: boolean
    location?: boolean
    attendees?: boolean
    status?: boolean
    priority?: boolean
    outcome?: boolean
    nextSteps?: boolean
    metadata?: boolean
    externalId?: boolean
    syncedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    date?: boolean
    duration?: boolean
    location?: boolean
    attendees?: boolean
    status?: boolean
    priority?: boolean
    outcome?: boolean
    nextSteps?: boolean
    metadata?: boolean
    externalId?: boolean
    syncedFrom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "contactId" | "type" | "title" | "description" | "content" | "date" | "duration" | "location" | "attendees" | "status" | "priority" | "outcome" | "nextSteps" | "metadata" | "externalId" | "syncedFrom" | "createdAt" | "updatedAt", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Activity$dealArgs<ExtArgs>
    contact?: boolean | Activity$contactArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      contactId: string | null
      type: string
      title: string
      description: string | null
      content: string | null
      date: Date
      duration: number | null
      location: string | null
      attendees: string[]
      status: string
      priority: string
      outcome: string | null
      nextSteps: string | null
      metadata: Prisma.JsonValue | null
      externalId: string | null
      syncedFrom: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends Activity$dealArgs<ExtArgs> = {}>(args?: Subset<T, Activity$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Activity$contactArgs<ExtArgs> = {}>(args?: Subset<T, Activity$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly dealId: FieldRef<"Activity", 'String'>
    readonly contactId: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'String'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly content: FieldRef<"Activity", 'String'>
    readonly date: FieldRef<"Activity", 'DateTime'>
    readonly duration: FieldRef<"Activity", 'Int'>
    readonly location: FieldRef<"Activity", 'String'>
    readonly attendees: FieldRef<"Activity", 'String[]'>
    readonly status: FieldRef<"Activity", 'String'>
    readonly priority: FieldRef<"Activity", 'String'>
    readonly outcome: FieldRef<"Activity", 'String'>
    readonly nextSteps: FieldRef<"Activity", 'String'>
    readonly metadata: FieldRef<"Activity", 'Json'>
    readonly externalId: FieldRef<"Activity", 'String'>
    readonly syncedFrom: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.deal
   */
  export type Activity$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Activity.contact
   */
  export type Activity$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type DocumentSumAggregateOutputType = {
    size: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    name: string | null
    description: string | null
    type: string | null
    category: string | null
    size: number | null
    url: string | null
    googleDriveId: string | null
    path: string | null
    version: string | null
    isConfidential: boolean | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    name: string | null
    description: string | null
    type: string | null
    category: string | null
    size: number | null
    url: string | null
    googleDriveId: string | null
    path: string | null
    version: string | null
    isConfidential: boolean | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    name: number
    description: number
    type: number
    category: number
    size: number
    url: number
    googleDriveId: number
    path: number
    version: number
    isConfidential: number
    uploadedBy: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    size?: true
  }

  export type DocumentSumAggregateInputType = {
    size?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    name?: true
    description?: true
    type?: true
    category?: true
    size?: true
    url?: true
    googleDriveId?: true
    path?: true
    version?: true
    isConfidential?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    name?: true
    description?: true
    type?: true
    category?: true
    size?: true
    url?: true
    googleDriveId?: true
    path?: true
    version?: true
    isConfidential?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    name?: true
    description?: true
    type?: true
    category?: true
    size?: true
    url?: true
    googleDriveId?: true
    path?: true
    version?: true
    isConfidential?: true
    uploadedBy?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    name: string
    description: string | null
    type: string
    category: string | null
    size: number | null
    url: string | null
    googleDriveId: string | null
    path: string | null
    version: string
    isConfidential: boolean
    uploadedBy: string | null
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    size?: boolean
    url?: boolean
    googleDriveId?: boolean
    path?: boolean
    version?: boolean
    isConfidential?: boolean
    uploadedBy?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    size?: boolean
    url?: boolean
    googleDriveId?: boolean
    path?: boolean
    version?: boolean
    isConfidential?: boolean
    uploadedBy?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    size?: boolean
    url?: boolean
    googleDriveId?: boolean
    path?: boolean
    version?: boolean
    isConfidential?: boolean
    uploadedBy?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    size?: boolean
    url?: boolean
    googleDriveId?: boolean
    path?: boolean
    version?: boolean
    isConfidential?: boolean
    uploadedBy?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "name" | "description" | "type" | "category" | "size" | "url" | "googleDriveId" | "path" | "version" | "isConfidential" | "uploadedBy" | "tags" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Document$dealArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      name: string
      description: string | null
      type: string
      category: string | null
      size: number | null
      url: string | null
      googleDriveId: string | null
      path: string | null
      version: string
      isConfidential: boolean
      uploadedBy: string | null
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends Document$dealArgs<ExtArgs> = {}>(args?: Subset<T, Document$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly dealId: FieldRef<"Document", 'String'>
    readonly name: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly size: FieldRef<"Document", 'Int'>
    readonly url: FieldRef<"Document", 'String'>
    readonly googleDriveId: FieldRef<"Document", 'String'>
    readonly path: FieldRef<"Document", 'String'>
    readonly version: FieldRef<"Document", 'String'>
    readonly isConfidential: FieldRef<"Document", 'Boolean'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly tags: FieldRef<"Document", 'String[]'>
    readonly metadata: FieldRef<"Document", 'Json'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.deal
   */
  export type Document$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Communication
   */

  export type AggregateCommunication = {
    _count: CommunicationCountAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  export type CommunicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    type: string | null
    subject: string | null
    content: string | null
    htmlContent: string | null
    fromEmail: string | null
    threadId: string | null
    messageId: string | null
    status: string | null
    direction: string | null
    isRead: boolean | null
    isImportant: boolean | null
    sentAt: Date | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    type: string | null
    subject: string | null
    content: string | null
    htmlContent: string | null
    fromEmail: string | null
    threadId: string | null
    messageId: string | null
    status: string | null
    direction: string | null
    isRead: boolean | null
    isImportant: boolean | null
    sentAt: Date | null
    receivedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    contactId: number
    type: number
    subject: number
    content: number
    htmlContent: number
    fromEmail: number
    toEmails: number
    ccEmails: number
    bccEmails: number
    threadId: number
    messageId: number
    status: number
    direction: number
    isRead: number
    isImportant: number
    labels: number
    attachments: number
    metadata: number
    sentAt: number
    receivedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunicationMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    type?: true
    subject?: true
    content?: true
    htmlContent?: true
    fromEmail?: true
    threadId?: true
    messageId?: true
    status?: true
    direction?: true
    isRead?: true
    isImportant?: true
    sentAt?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    type?: true
    subject?: true
    content?: true
    htmlContent?: true
    fromEmail?: true
    threadId?: true
    messageId?: true
    status?: true
    direction?: true
    isRead?: true
    isImportant?: true
    sentAt?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    type?: true
    subject?: true
    content?: true
    htmlContent?: true
    fromEmail?: true
    toEmails?: true
    ccEmails?: true
    bccEmails?: true
    threadId?: true
    messageId?: true
    status?: true
    direction?: true
    isRead?: true
    isImportant?: true
    labels?: true
    attachments?: true
    metadata?: true
    sentAt?: true
    receivedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communication to aggregate.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communications
    **/
    _count?: true | CommunicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationMaxAggregateInputType
  }

  export type GetCommunicationAggregateType<T extends CommunicationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunication[P]>
      : GetScalarType<T[P], AggregateCommunication[P]>
  }




  export type CommunicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithAggregationInput | CommunicationOrderByWithAggregationInput[]
    by: CommunicationScalarFieldEnum[] | CommunicationScalarFieldEnum
    having?: CommunicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationCountAggregateInputType | true
    _min?: CommunicationMinAggregateInputType
    _max?: CommunicationMaxAggregateInputType
  }

  export type CommunicationGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    contactId: string | null
    type: string
    subject: string | null
    content: string | null
    htmlContent: string | null
    fromEmail: string | null
    toEmails: string[]
    ccEmails: string[]
    bccEmails: string[]
    threadId: string | null
    messageId: string | null
    status: string
    direction: string
    isRead: boolean
    isImportant: boolean
    labels: string[]
    attachments: JsonValue | null
    metadata: JsonValue | null
    sentAt: Date | null
    receivedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CommunicationCountAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  type GetCommunicationGroupByPayload<T extends CommunicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    htmlContent?: boolean
    fromEmail?: boolean
    toEmails?: boolean
    ccEmails?: boolean
    bccEmails?: boolean
    threadId?: boolean
    messageId?: boolean
    status?: boolean
    direction?: boolean
    isRead?: boolean
    isImportant?: boolean
    labels?: boolean
    attachments?: boolean
    metadata?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Communication$dealArgs<ExtArgs>
    contact?: boolean | Communication$contactArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    htmlContent?: boolean
    fromEmail?: boolean
    toEmails?: boolean
    ccEmails?: boolean
    bccEmails?: boolean
    threadId?: boolean
    messageId?: boolean
    status?: boolean
    direction?: boolean
    isRead?: boolean
    isImportant?: boolean
    labels?: boolean
    attachments?: boolean
    metadata?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Communication$dealArgs<ExtArgs>
    contact?: boolean | Communication$contactArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    htmlContent?: boolean
    fromEmail?: boolean
    toEmails?: boolean
    ccEmails?: boolean
    bccEmails?: boolean
    threadId?: boolean
    messageId?: boolean
    status?: boolean
    direction?: boolean
    isRead?: boolean
    isImportant?: boolean
    labels?: boolean
    attachments?: boolean
    metadata?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Communication$dealArgs<ExtArgs>
    contact?: boolean | Communication$contactArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>

  export type CommunicationSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    htmlContent?: boolean
    fromEmail?: boolean
    toEmails?: boolean
    ccEmails?: boolean
    bccEmails?: boolean
    threadId?: boolean
    messageId?: boolean
    status?: boolean
    direction?: boolean
    isRead?: boolean
    isImportant?: boolean
    labels?: boolean
    attachments?: boolean
    metadata?: boolean
    sentAt?: boolean
    receivedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "contactId" | "type" | "subject" | "content" | "htmlContent" | "fromEmail" | "toEmails" | "ccEmails" | "bccEmails" | "threadId" | "messageId" | "status" | "direction" | "isRead" | "isImportant" | "labels" | "attachments" | "metadata" | "sentAt" | "receivedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["communication"]>
  export type CommunicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Communication$dealArgs<ExtArgs>
    contact?: boolean | Communication$contactArgs<ExtArgs>
  }
  export type CommunicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Communication$dealArgs<ExtArgs>
    contact?: boolean | Communication$contactArgs<ExtArgs>
  }
  export type CommunicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | Communication$dealArgs<ExtArgs>
    contact?: boolean | Communication$contactArgs<ExtArgs>
  }

  export type $CommunicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Communication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      contactId: string | null
      type: string
      subject: string | null
      content: string | null
      htmlContent: string | null
      fromEmail: string | null
      toEmails: string[]
      ccEmails: string[]
      bccEmails: string[]
      threadId: string | null
      messageId: string | null
      status: string
      direction: string
      isRead: boolean
      isImportant: boolean
      labels: string[]
      attachments: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      sentAt: Date | null
      receivedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communication"]>
    composites: {}
  }

  type CommunicationGetPayload<S extends boolean | null | undefined | CommunicationDefaultArgs> = $Result.GetResult<Prisma.$CommunicationPayload, S>

  type CommunicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunicationCountAggregateInputType | true
    }

  export interface CommunicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Communication'], meta: { name: 'Communication' } }
    /**
     * Find zero or one Communication that matches the filter.
     * @param {CommunicationFindUniqueArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationFindUniqueArgs>(args: SelectSubset<T, CommunicationFindUniqueArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Communication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunicationFindUniqueOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationFindFirstArgs>(args?: SelectSubset<T, CommunicationFindFirstArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communications
     * const communications = await prisma.communication.findMany()
     * 
     * // Get first 10 Communications
     * const communications = await prisma.communication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationWithIdOnly = await prisma.communication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationFindManyArgs>(args?: SelectSubset<T, CommunicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Communication.
     * @param {CommunicationCreateArgs} args - Arguments to create a Communication.
     * @example
     * // Create one Communication
     * const Communication = await prisma.communication.create({
     *   data: {
     *     // ... data to create a Communication
     *   }
     * })
     * 
     */
    create<T extends CommunicationCreateArgs>(args: SelectSubset<T, CommunicationCreateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communications.
     * @param {CommunicationCreateManyArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationCreateManyArgs>(args?: SelectSubset<T, CommunicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communications and returns the data saved in the database.
     * @param {CommunicationCreateManyAndReturnArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communications and only return the `id`
     * const communicationWithIdOnly = await prisma.communication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunicationCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Communication.
     * @param {CommunicationDeleteArgs} args - Arguments to delete one Communication.
     * @example
     * // Delete one Communication
     * const Communication = await prisma.communication.delete({
     *   where: {
     *     // ... filter to delete one Communication
     *   }
     * })
     * 
     */
    delete<T extends CommunicationDeleteArgs>(args: SelectSubset<T, CommunicationDeleteArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Communication.
     * @param {CommunicationUpdateArgs} args - Arguments to update one Communication.
     * @example
     * // Update one Communication
     * const communication = await prisma.communication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationUpdateArgs>(args: SelectSubset<T, CommunicationUpdateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communications.
     * @param {CommunicationDeleteManyArgs} args - Arguments to filter Communications to delete.
     * @example
     * // Delete a few Communications
     * const { count } = await prisma.communication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationDeleteManyArgs>(args?: SelectSubset<T, CommunicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationUpdateManyArgs>(args: SelectSubset<T, CommunicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications and returns the data updated in the database.
     * @param {CommunicationUpdateManyAndReturnArgs} args - Arguments to update many Communications.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communications and only return the `id`
     * const communicationWithIdOnly = await prisma.communication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunicationUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Communication.
     * @param {CommunicationUpsertArgs} args - Arguments to update or create a Communication.
     * @example
     * // Update or create a Communication
     * const communication = await prisma.communication.upsert({
     *   create: {
     *     // ... data to create a Communication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Communication we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationUpsertArgs>(args: SelectSubset<T, CommunicationUpsertArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationCountArgs} args - Arguments to filter Communications to count.
     * @example
     * // Count the number of Communications
     * const count = await prisma.communication.count({
     *   where: {
     *     // ... the filter for the Communications we want to count
     *   }
     * })
    **/
    count<T extends CommunicationCountArgs>(
      args?: Subset<T, CommunicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationAggregateArgs>(args: Subset<T, CommunicationAggregateArgs>): Prisma.PrismaPromise<GetCommunicationAggregateType<T>>

    /**
     * Group by Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Communication model
   */
  readonly fields: CommunicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Communication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends Communication$dealArgs<ExtArgs> = {}>(args?: Subset<T, Communication$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Communication$contactArgs<ExtArgs> = {}>(args?: Subset<T, Communication$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Communication model
   */
  interface CommunicationFieldRefs {
    readonly id: FieldRef<"Communication", 'String'>
    readonly userId: FieldRef<"Communication", 'String'>
    readonly dealId: FieldRef<"Communication", 'String'>
    readonly contactId: FieldRef<"Communication", 'String'>
    readonly type: FieldRef<"Communication", 'String'>
    readonly subject: FieldRef<"Communication", 'String'>
    readonly content: FieldRef<"Communication", 'String'>
    readonly htmlContent: FieldRef<"Communication", 'String'>
    readonly fromEmail: FieldRef<"Communication", 'String'>
    readonly toEmails: FieldRef<"Communication", 'String[]'>
    readonly ccEmails: FieldRef<"Communication", 'String[]'>
    readonly bccEmails: FieldRef<"Communication", 'String[]'>
    readonly threadId: FieldRef<"Communication", 'String'>
    readonly messageId: FieldRef<"Communication", 'String'>
    readonly status: FieldRef<"Communication", 'String'>
    readonly direction: FieldRef<"Communication", 'String'>
    readonly isRead: FieldRef<"Communication", 'Boolean'>
    readonly isImportant: FieldRef<"Communication", 'Boolean'>
    readonly labels: FieldRef<"Communication", 'String[]'>
    readonly attachments: FieldRef<"Communication", 'Json'>
    readonly metadata: FieldRef<"Communication", 'Json'>
    readonly sentAt: FieldRef<"Communication", 'DateTime'>
    readonly receivedAt: FieldRef<"Communication", 'DateTime'>
    readonly createdAt: FieldRef<"Communication", 'DateTime'>
    readonly updatedAt: FieldRef<"Communication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Communication findUnique
   */
  export type CommunicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findUniqueOrThrow
   */
  export type CommunicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findFirst
   */
  export type CommunicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findFirstOrThrow
   */
  export type CommunicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findMany
   */
  export type CommunicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communications to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication create
   */
  export type CommunicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Communication.
     */
    data: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
  }

  /**
   * Communication createMany
   */
  export type CommunicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Communication createManyAndReturn
   */
  export type CommunicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Communication update
   */
  export type CommunicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Communication.
     */
    data: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
    /**
     * Choose, which Communication to update.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication updateMany
   */
  export type CommunicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to update.
     */
    limit?: number
  }

  /**
   * Communication updateManyAndReturn
   */
  export type CommunicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Communication upsert
   */
  export type CommunicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Communication to update in case it exists.
     */
    where: CommunicationWhereUniqueInput
    /**
     * In case the Communication found by the `where` argument doesn't exist, create a new Communication with this data.
     */
    create: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
    /**
     * In case the Communication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
  }

  /**
   * Communication delete
   */
  export type CommunicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter which Communication to delete.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication deleteMany
   */
  export type CommunicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communications to delete
     */
    where?: CommunicationWhereInput
    /**
     * Limit how many Communications to delete.
     */
    limit?: number
  }

  /**
   * Communication.deal
   */
  export type Communication$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Communication.contact
   */
  export type Communication$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Communication without action
   */
  export type CommunicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Communication
     */
    omit?: CommunicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
  }


  /**
   * Model Investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorAvgAggregateOutputType = {
    totalCommitment: number | null
    totalCalled: number | null
    aum: number | null
  }

  export type InvestorSumAggregateOutputType = {
    totalCommitment: number | null
    totalCalled: number | null
    aum: number | null
  }

  export type InvestorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: string | null
    status: string | null
    totalCommitment: number | null
    totalCalled: number | null
    description: string | null
    website: string | null
    location: string | null
    founded: Date | null
    aum: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: string | null
    status: string | null
    totalCommitment: number | null
    totalCalled: number | null
    description: string | null
    website: string | null
    location: string | null
    founded: Date | null
    aum: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    type: number
    status: number
    totalCommitment: number
    totalCalled: number
    description: number
    website: number
    location: number
    founded: number
    aum: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorAvgAggregateInputType = {
    totalCommitment?: true
    totalCalled?: true
    aum?: true
  }

  export type InvestorSumAggregateInputType = {
    totalCommitment?: true
    totalCalled?: true
    aum?: true
  }

  export type InvestorMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    status?: true
    totalCommitment?: true
    totalCalled?: true
    description?: true
    website?: true
    location?: true
    founded?: true
    aum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    status?: true
    totalCommitment?: true
    totalCalled?: true
    description?: true
    website?: true
    location?: true
    founded?: true
    aum?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    status?: true
    totalCommitment?: true
    totalCalled?: true
    description?: true
    website?: true
    location?: true
    founded?: true
    aum?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investor to aggregate.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type InvestorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorWhereInput
    orderBy?: InvestorOrderByWithAggregationInput | InvestorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: InvestorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _avg?: InvestorAvgAggregateInputType
    _sum?: InvestorSumAggregateInputType
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: string
    userId: string
    name: string
    type: string
    status: string
    totalCommitment: number | null
    totalCalled: number | null
    description: string | null
    website: string | null
    location: string | null
    founded: Date | null
    aum: number | null
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends InvestorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type InvestorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    totalCommitment?: boolean
    totalCalled?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    founded?: boolean
    aum?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    entities?: boolean | Investor$entitiesArgs<ExtArgs>
    groupMemberships?: boolean | Investor$groupMembershipsArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    totalCommitment?: boolean
    totalCalled?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    founded?: boolean
    aum?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    totalCommitment?: boolean
    totalCalled?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    founded?: boolean
    aum?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>

  export type InvestorSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    totalCommitment?: boolean
    totalCalled?: boolean
    description?: boolean
    website?: boolean
    location?: boolean
    founded?: boolean
    aum?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "type" | "status" | "totalCommitment" | "totalCalled" | "description" | "website" | "location" | "founded" | "aum" | "tags" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["investor"]>
  export type InvestorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    entities?: boolean | Investor$entitiesArgs<ExtArgs>
    groupMemberships?: boolean | Investor$groupMembershipsArgs<ExtArgs>
    _count?: boolean | InvestorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvestorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvestorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvestorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Investor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      entities: Prisma.$InvestorEntityPayload<ExtArgs>[]
      groupMemberships: Prisma.$InvestorGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      type: string
      status: string
      totalCommitment: number | null
      totalCalled: number | null
      description: string | null
      website: string | null
      location: string | null
      founded: Date | null
      aum: number | null
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }

  type InvestorGetPayload<S extends boolean | null | undefined | InvestorDefaultArgs> = $Result.GetResult<Prisma.$InvestorPayload, S>

  type InvestorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface InvestorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Investor'], meta: { name: 'Investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {InvestorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorFindUniqueArgs>(args: SelectSubset<T, InvestorFindUniqueArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorFindFirstArgs>(args?: SelectSubset<T, InvestorFindFirstArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorFindManyArgs>(args?: SelectSubset<T, InvestorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investor.
     * @param {InvestorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
     */
    create<T extends InvestorCreateArgs>(args: SelectSubset<T, InvestorCreateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investors.
     * @param {InvestorCreateManyArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorCreateManyArgs>(args?: SelectSubset<T, InvestorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Investors and returns the data saved in the database.
     * @param {InvestorCreateManyAndReturnArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Investors and only return the `id`
     * const investorWithIdOnly = await prisma.investor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Investor.
     * @param {InvestorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
     */
    delete<T extends InvestorDeleteArgs>(args: SelectSubset<T, InvestorDeleteArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investor.
     * @param {InvestorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorUpdateArgs>(args: SelectSubset<T, InvestorUpdateArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investors.
     * @param {InvestorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorDeleteManyArgs>(args?: SelectSubset<T, InvestorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorUpdateManyArgs>(args: SelectSubset<T, InvestorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors and returns the data updated in the database.
     * @param {InvestorUpdateManyAndReturnArgs} args - Arguments to update many Investors.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Investors and only return the `id`
     * const investorWithIdOnly = await prisma.investor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Investor.
     * @param {InvestorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
     */
    upsert<T extends InvestorUpsertArgs>(args: SelectSubset<T, InvestorUpsertArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends InvestorCountArgs>(
      args?: Subset<T, InvestorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Investor model
   */
  readonly fields: InvestorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entities<T extends Investor$entitiesArgs<ExtArgs> = {}>(args?: Subset<T, Investor$entitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMemberships<T extends Investor$groupMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Investor$groupMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Investor model
   */
  interface InvestorFieldRefs {
    readonly id: FieldRef<"Investor", 'String'>
    readonly userId: FieldRef<"Investor", 'String'>
    readonly name: FieldRef<"Investor", 'String'>
    readonly type: FieldRef<"Investor", 'String'>
    readonly status: FieldRef<"Investor", 'String'>
    readonly totalCommitment: FieldRef<"Investor", 'Float'>
    readonly totalCalled: FieldRef<"Investor", 'Float'>
    readonly description: FieldRef<"Investor", 'String'>
    readonly website: FieldRef<"Investor", 'String'>
    readonly location: FieldRef<"Investor", 'String'>
    readonly founded: FieldRef<"Investor", 'DateTime'>
    readonly aum: FieldRef<"Investor", 'Float'>
    readonly tags: FieldRef<"Investor", 'String[]'>
    readonly metadata: FieldRef<"Investor", 'Json'>
    readonly createdAt: FieldRef<"Investor", 'DateTime'>
    readonly updatedAt: FieldRef<"Investor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Investor findUnique
   */
  export type InvestorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findUniqueOrThrow
   */
  export type InvestorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor findFirst
   */
  export type InvestorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findFirstOrThrow
   */
  export type InvestorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investor to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor findMany
   */
  export type InvestorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter, which Investors to fetch.
     */
    where?: InvestorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Investors to fetch.
     */
    orderBy?: InvestorOrderByWithRelationInput | InvestorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Investors.
     */
    cursor?: InvestorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * Investor create
   */
  export type InvestorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to create a Investor.
     */
    data: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
  }

  /**
   * Investor createMany
   */
  export type InvestorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Investor createManyAndReturn
   */
  export type InvestorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The data used to create many Investors.
     */
    data: InvestorCreateManyInput | InvestorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investor update
   */
  export type InvestorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The data needed to update a Investor.
     */
    data: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
    /**
     * Choose, which Investor to update.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor updateMany
   */
  export type InvestorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to update.
     */
    limit?: number
  }

  /**
   * Investor updateManyAndReturn
   */
  export type InvestorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * The data used to update Investors.
     */
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyInput>
    /**
     * Filter which Investors to update
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Investor upsert
   */
  export type InvestorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * The filter to search for the Investor to update in case it exists.
     */
    where: InvestorWhereUniqueInput
    /**
     * In case the Investor found by the `where` argument doesn't exist, create a new Investor with this data.
     */
    create: XOR<InvestorCreateInput, InvestorUncheckedCreateInput>
    /**
     * In case the Investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorUpdateInput, InvestorUncheckedUpdateInput>
  }

  /**
   * Investor delete
   */
  export type InvestorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
    /**
     * Filter which Investor to delete.
     */
    where: InvestorWhereUniqueInput
  }

  /**
   * Investor deleteMany
   */
  export type InvestorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Investors to delete
     */
    where?: InvestorWhereInput
    /**
     * Limit how many Investors to delete.
     */
    limit?: number
  }

  /**
   * Investor.entities
   */
  export type Investor$entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    where?: InvestorEntityWhereInput
    orderBy?: InvestorEntityOrderByWithRelationInput | InvestorEntityOrderByWithRelationInput[]
    cursor?: InvestorEntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorEntityScalarFieldEnum | InvestorEntityScalarFieldEnum[]
  }

  /**
   * Investor.groupMemberships
   */
  export type Investor$groupMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    where?: InvestorGroupMemberWhereInput
    orderBy?: InvestorGroupMemberOrderByWithRelationInput | InvestorGroupMemberOrderByWithRelationInput[]
    cursor?: InvestorGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorGroupMemberScalarFieldEnum | InvestorGroupMemberScalarFieldEnum[]
  }

  /**
   * Investor without action
   */
  export type InvestorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Investor
     */
    select?: InvestorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Investor
     */
    omit?: InvestorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorInclude<ExtArgs> | null
  }


  /**
   * Model Fund
   */

  export type AggregateFund = {
    _count: FundCountAggregateOutputType | null
    _avg: FundAvgAggregateOutputType | null
    _sum: FundSumAggregateOutputType | null
    _min: FundMinAggregateOutputType | null
    _max: FundMaxAggregateOutputType | null
  }

  export type FundAvgAggregateOutputType = {
    targetSize: number | null
    minimumCommitment: number | null
    managementFee: number | null
    carriedInterest: number | null
    vintage: number | null
    investmentPeriod: number | null
    fundTerm: number | null
    raisedAmount: number | null
    investorCount: number | null
  }

  export type FundSumAggregateOutputType = {
    targetSize: number | null
    minimumCommitment: number | null
    managementFee: number | null
    carriedInterest: number | null
    vintage: number | null
    investmentPeriod: number | null
    fundTerm: number | null
    raisedAmount: number | null
    investorCount: number | null
  }

  export type FundMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: string | null
    strategy: string | null
    targetSize: number | null
    minimumCommitment: number | null
    managementFee: number | null
    carriedInterest: number | null
    currency: string | null
    vintage: number | null
    investmentPeriod: number | null
    fundTerm: number | null
    geoFocus: string | null
    sectorFocus: string | null
    description: string | null
    status: string | null
    raisedAmount: number | null
    investorCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FundMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    type: string | null
    strategy: string | null
    targetSize: number | null
    minimumCommitment: number | null
    managementFee: number | null
    carriedInterest: number | null
    currency: string | null
    vintage: number | null
    investmentPeriod: number | null
    fundTerm: number | null
    geoFocus: string | null
    sectorFocus: string | null
    description: string | null
    status: string | null
    raisedAmount: number | null
    investorCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FundCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    type: number
    strategy: number
    targetSize: number
    minimumCommitment: number
    managementFee: number
    carriedInterest: number
    currency: number
    vintage: number
    investmentPeriod: number
    fundTerm: number
    geoFocus: number
    sectorFocus: number
    description: number
    status: number
    raisedAmount: number
    investorCount: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FundAvgAggregateInputType = {
    targetSize?: true
    minimumCommitment?: true
    managementFee?: true
    carriedInterest?: true
    vintage?: true
    investmentPeriod?: true
    fundTerm?: true
    raisedAmount?: true
    investorCount?: true
  }

  export type FundSumAggregateInputType = {
    targetSize?: true
    minimumCommitment?: true
    managementFee?: true
    carriedInterest?: true
    vintage?: true
    investmentPeriod?: true
    fundTerm?: true
    raisedAmount?: true
    investorCount?: true
  }

  export type FundMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    strategy?: true
    targetSize?: true
    minimumCommitment?: true
    managementFee?: true
    carriedInterest?: true
    currency?: true
    vintage?: true
    investmentPeriod?: true
    fundTerm?: true
    geoFocus?: true
    sectorFocus?: true
    description?: true
    status?: true
    raisedAmount?: true
    investorCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FundMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    strategy?: true
    targetSize?: true
    minimumCommitment?: true
    managementFee?: true
    carriedInterest?: true
    currency?: true
    vintage?: true
    investmentPeriod?: true
    fundTerm?: true
    geoFocus?: true
    sectorFocus?: true
    description?: true
    status?: true
    raisedAmount?: true
    investorCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FundCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    type?: true
    strategy?: true
    targetSize?: true
    minimumCommitment?: true
    managementFee?: true
    carriedInterest?: true
    currency?: true
    vintage?: true
    investmentPeriod?: true
    fundTerm?: true
    geoFocus?: true
    sectorFocus?: true
    description?: true
    status?: true
    raisedAmount?: true
    investorCount?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fund to aggregate.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funds
    **/
    _count?: true | FundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FundMaxAggregateInputType
  }

  export type GetFundAggregateType<T extends FundAggregateArgs> = {
        [P in keyof T & keyof AggregateFund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFund[P]>
      : GetScalarType<T[P], AggregateFund[P]>
  }




  export type FundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FundWhereInput
    orderBy?: FundOrderByWithAggregationInput | FundOrderByWithAggregationInput[]
    by: FundScalarFieldEnum[] | FundScalarFieldEnum
    having?: FundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FundCountAggregateInputType | true
    _avg?: FundAvgAggregateInputType
    _sum?: FundSumAggregateInputType
    _min?: FundMinAggregateInputType
    _max?: FundMaxAggregateInputType
  }

  export type FundGroupByOutputType = {
    id: string
    userId: string
    name: string
    type: string
    strategy: string | null
    targetSize: number
    minimumCommitment: number | null
    managementFee: number | null
    carriedInterest: number | null
    currency: string
    vintage: number | null
    investmentPeriod: number | null
    fundTerm: number | null
    geoFocus: string | null
    sectorFocus: string | null
    description: string | null
    status: string
    raisedAmount: number
    investorCount: number
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FundCountAggregateOutputType | null
    _avg: FundAvgAggregateOutputType | null
    _sum: FundSumAggregateOutputType | null
    _min: FundMinAggregateOutputType | null
    _max: FundMaxAggregateOutputType | null
  }

  type GetFundGroupByPayload<T extends FundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FundGroupByOutputType[P]>
            : GetScalarType<T[P], FundGroupByOutputType[P]>
        }
      >
    >


  export type FundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    strategy?: boolean
    targetSize?: boolean
    minimumCommitment?: boolean
    managementFee?: boolean
    carriedInterest?: boolean
    currency?: boolean
    vintage?: boolean
    investmentPeriod?: boolean
    fundTerm?: boolean
    geoFocus?: boolean
    sectorFocus?: boolean
    description?: boolean
    status?: boolean
    raisedAmount?: boolean
    investorCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fund"]>

  export type FundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    strategy?: boolean
    targetSize?: boolean
    minimumCommitment?: boolean
    managementFee?: boolean
    carriedInterest?: boolean
    currency?: boolean
    vintage?: boolean
    investmentPeriod?: boolean
    fundTerm?: boolean
    geoFocus?: boolean
    sectorFocus?: boolean
    description?: boolean
    status?: boolean
    raisedAmount?: boolean
    investorCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fund"]>

  export type FundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    strategy?: boolean
    targetSize?: boolean
    minimumCommitment?: boolean
    managementFee?: boolean
    carriedInterest?: boolean
    currency?: boolean
    vintage?: boolean
    investmentPeriod?: boolean
    fundTerm?: boolean
    geoFocus?: boolean
    sectorFocus?: boolean
    description?: boolean
    status?: boolean
    raisedAmount?: boolean
    investorCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fund"]>

  export type FundSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    type?: boolean
    strategy?: boolean
    targetSize?: boolean
    minimumCommitment?: boolean
    managementFee?: boolean
    carriedInterest?: boolean
    currency?: boolean
    vintage?: boolean
    investmentPeriod?: boolean
    fundTerm?: boolean
    geoFocus?: boolean
    sectorFocus?: boolean
    description?: boolean
    status?: boolean
    raisedAmount?: boolean
    investorCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "type" | "strategy" | "targetSize" | "minimumCommitment" | "managementFee" | "carriedInterest" | "currency" | "vintage" | "investmentPeriod" | "fundTerm" | "geoFocus" | "sectorFocus" | "description" | "status" | "raisedAmount" | "investorCount" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["fund"]>
  export type FundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fund"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      type: string
      strategy: string | null
      targetSize: number
      minimumCommitment: number | null
      managementFee: number | null
      carriedInterest: number | null
      currency: string
      vintage: number | null
      investmentPeriod: number | null
      fundTerm: number | null
      geoFocus: string | null
      sectorFocus: string | null
      description: string | null
      status: string
      raisedAmount: number
      investorCount: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fund"]>
    composites: {}
  }

  type FundGetPayload<S extends boolean | null | undefined | FundDefaultArgs> = $Result.GetResult<Prisma.$FundPayload, S>

  type FundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FundCountAggregateInputType | true
    }

  export interface FundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fund'], meta: { name: 'Fund' } }
    /**
     * Find zero or one Fund that matches the filter.
     * @param {FundFindUniqueArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FundFindUniqueArgs>(args: SelectSubset<T, FundFindUniqueArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FundFindUniqueOrThrowArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FundFindUniqueOrThrowArgs>(args: SelectSubset<T, FundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundFindFirstArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FundFindFirstArgs>(args?: SelectSubset<T, FundFindFirstArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundFindFirstOrThrowArgs} args - Arguments to find a Fund
     * @example
     * // Get one Fund
     * const fund = await prisma.fund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FundFindFirstOrThrowArgs>(args?: SelectSubset<T, FundFindFirstOrThrowArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Funds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funds
     * const funds = await prisma.fund.findMany()
     * 
     * // Get first 10 Funds
     * const funds = await prisma.fund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fundWithIdOnly = await prisma.fund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FundFindManyArgs>(args?: SelectSubset<T, FundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fund.
     * @param {FundCreateArgs} args - Arguments to create a Fund.
     * @example
     * // Create one Fund
     * const Fund = await prisma.fund.create({
     *   data: {
     *     // ... data to create a Fund
     *   }
     * })
     * 
     */
    create<T extends FundCreateArgs>(args: SelectSubset<T, FundCreateArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Funds.
     * @param {FundCreateManyArgs} args - Arguments to create many Funds.
     * @example
     * // Create many Funds
     * const fund = await prisma.fund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FundCreateManyArgs>(args?: SelectSubset<T, FundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Funds and returns the data saved in the database.
     * @param {FundCreateManyAndReturnArgs} args - Arguments to create many Funds.
     * @example
     * // Create many Funds
     * const fund = await prisma.fund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Funds and only return the `id`
     * const fundWithIdOnly = await prisma.fund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FundCreateManyAndReturnArgs>(args?: SelectSubset<T, FundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fund.
     * @param {FundDeleteArgs} args - Arguments to delete one Fund.
     * @example
     * // Delete one Fund
     * const Fund = await prisma.fund.delete({
     *   where: {
     *     // ... filter to delete one Fund
     *   }
     * })
     * 
     */
    delete<T extends FundDeleteArgs>(args: SelectSubset<T, FundDeleteArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fund.
     * @param {FundUpdateArgs} args - Arguments to update one Fund.
     * @example
     * // Update one Fund
     * const fund = await prisma.fund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FundUpdateArgs>(args: SelectSubset<T, FundUpdateArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Funds.
     * @param {FundDeleteManyArgs} args - Arguments to filter Funds to delete.
     * @example
     * // Delete a few Funds
     * const { count } = await prisma.fund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FundDeleteManyArgs>(args?: SelectSubset<T, FundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funds
     * const fund = await prisma.fund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FundUpdateManyArgs>(args: SelectSubset<T, FundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funds and returns the data updated in the database.
     * @param {FundUpdateManyAndReturnArgs} args - Arguments to update many Funds.
     * @example
     * // Update many Funds
     * const fund = await prisma.fund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Funds and only return the `id`
     * const fundWithIdOnly = await prisma.fund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FundUpdateManyAndReturnArgs>(args: SelectSubset<T, FundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fund.
     * @param {FundUpsertArgs} args - Arguments to update or create a Fund.
     * @example
     * // Update or create a Fund
     * const fund = await prisma.fund.upsert({
     *   create: {
     *     // ... data to create a Fund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fund we want to update
     *   }
     * })
     */
    upsert<T extends FundUpsertArgs>(args: SelectSubset<T, FundUpsertArgs<ExtArgs>>): Prisma__FundClient<$Result.GetResult<Prisma.$FundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Funds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundCountArgs} args - Arguments to filter Funds to count.
     * @example
     * // Count the number of Funds
     * const count = await prisma.fund.count({
     *   where: {
     *     // ... the filter for the Funds we want to count
     *   }
     * })
    **/
    count<T extends FundCountArgs>(
      args?: Subset<T, FundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FundAggregateArgs>(args: Subset<T, FundAggregateArgs>): Prisma.PrismaPromise<GetFundAggregateType<T>>

    /**
     * Group by Fund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FundGroupByArgs['orderBy'] }
        : { orderBy?: FundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fund model
   */
  readonly fields: FundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fund model
   */
  interface FundFieldRefs {
    readonly id: FieldRef<"Fund", 'String'>
    readonly userId: FieldRef<"Fund", 'String'>
    readonly name: FieldRef<"Fund", 'String'>
    readonly type: FieldRef<"Fund", 'String'>
    readonly strategy: FieldRef<"Fund", 'String'>
    readonly targetSize: FieldRef<"Fund", 'Float'>
    readonly minimumCommitment: FieldRef<"Fund", 'Float'>
    readonly managementFee: FieldRef<"Fund", 'Float'>
    readonly carriedInterest: FieldRef<"Fund", 'Float'>
    readonly currency: FieldRef<"Fund", 'String'>
    readonly vintage: FieldRef<"Fund", 'Int'>
    readonly investmentPeriod: FieldRef<"Fund", 'Int'>
    readonly fundTerm: FieldRef<"Fund", 'Int'>
    readonly geoFocus: FieldRef<"Fund", 'String'>
    readonly sectorFocus: FieldRef<"Fund", 'String'>
    readonly description: FieldRef<"Fund", 'String'>
    readonly status: FieldRef<"Fund", 'String'>
    readonly raisedAmount: FieldRef<"Fund", 'Float'>
    readonly investorCount: FieldRef<"Fund", 'Int'>
    readonly metadata: FieldRef<"Fund", 'Json'>
    readonly createdAt: FieldRef<"Fund", 'DateTime'>
    readonly updatedAt: FieldRef<"Fund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fund findUnique
   */
  export type FundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund findUniqueOrThrow
   */
  export type FundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund findFirst
   */
  export type FundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funds.
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funds.
     */
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * Fund findFirstOrThrow
   */
  export type FundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Fund to fetch.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funds.
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funds.
     */
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * Fund findMany
   */
  export type FundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter, which Funds to fetch.
     */
    where?: FundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funds to fetch.
     */
    orderBy?: FundOrderByWithRelationInput | FundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funds.
     */
    cursor?: FundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funds.
     */
    skip?: number
    distinct?: FundScalarFieldEnum | FundScalarFieldEnum[]
  }

  /**
   * Fund create
   */
  export type FundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * The data needed to create a Fund.
     */
    data: XOR<FundCreateInput, FundUncheckedCreateInput>
  }

  /**
   * Fund createMany
   */
  export type FundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funds.
     */
    data: FundCreateManyInput | FundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fund createManyAndReturn
   */
  export type FundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * The data used to create many Funds.
     */
    data: FundCreateManyInput | FundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fund update
   */
  export type FundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * The data needed to update a Fund.
     */
    data: XOR<FundUpdateInput, FundUncheckedUpdateInput>
    /**
     * Choose, which Fund to update.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund updateMany
   */
  export type FundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funds.
     */
    data: XOR<FundUpdateManyMutationInput, FundUncheckedUpdateManyInput>
    /**
     * Filter which Funds to update
     */
    where?: FundWhereInput
    /**
     * Limit how many Funds to update.
     */
    limit?: number
  }

  /**
   * Fund updateManyAndReturn
   */
  export type FundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * The data used to update Funds.
     */
    data: XOR<FundUpdateManyMutationInput, FundUncheckedUpdateManyInput>
    /**
     * Filter which Funds to update
     */
    where?: FundWhereInput
    /**
     * Limit how many Funds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fund upsert
   */
  export type FundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * The filter to search for the Fund to update in case it exists.
     */
    where: FundWhereUniqueInput
    /**
     * In case the Fund found by the `where` argument doesn't exist, create a new Fund with this data.
     */
    create: XOR<FundCreateInput, FundUncheckedCreateInput>
    /**
     * In case the Fund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FundUpdateInput, FundUncheckedUpdateInput>
  }

  /**
   * Fund delete
   */
  export type FundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
    /**
     * Filter which Fund to delete.
     */
    where: FundWhereUniqueInput
  }

  /**
   * Fund deleteMany
   */
  export type FundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funds to delete
     */
    where?: FundWhereInput
    /**
     * Limit how many Funds to delete.
     */
    limit?: number
  }

  /**
   * Fund without action
   */
  export type FundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fund
     */
    select?: FundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fund
     */
    omit?: FundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FundInclude<ExtArgs> | null
  }


  /**
   * Model InvestorEntity
   */

  export type AggregateInvestorEntity = {
    _count: InvestorEntityCountAggregateOutputType | null
    _avg: InvestorEntityAvgAggregateOutputType | null
    _sum: InvestorEntitySumAggregateOutputType | null
    _min: InvestorEntityMinAggregateOutputType | null
    _max: InvestorEntityMaxAggregateOutputType | null
  }

  export type InvestorEntityAvgAggregateOutputType = {
    commitment: number | null
    called: number | null
  }

  export type InvestorEntitySumAggregateOutputType = {
    commitment: number | null
    called: number | null
  }

  export type InvestorEntityMinAggregateOutputType = {
    id: string | null
    investorId: string | null
    name: string | null
    type: string | null
    investmentType: string | null
    commitment: number | null
    called: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorEntityMaxAggregateOutputType = {
    id: string | null
    investorId: string | null
    name: string | null
    type: string | null
    investmentType: string | null
    commitment: number | null
    called: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvestorEntityCountAggregateOutputType = {
    id: number
    investorId: number
    name: number
    type: number
    investmentType: number
    commitment: number
    called: number
    status: number
    documents: number
    fundInvestments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvestorEntityAvgAggregateInputType = {
    commitment?: true
    called?: true
  }

  export type InvestorEntitySumAggregateInputType = {
    commitment?: true
    called?: true
  }

  export type InvestorEntityMinAggregateInputType = {
    id?: true
    investorId?: true
    name?: true
    type?: true
    investmentType?: true
    commitment?: true
    called?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorEntityMaxAggregateInputType = {
    id?: true
    investorId?: true
    name?: true
    type?: true
    investmentType?: true
    commitment?: true
    called?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvestorEntityCountAggregateInputType = {
    id?: true
    investorId?: true
    name?: true
    type?: true
    investmentType?: true
    commitment?: true
    called?: true
    status?: true
    documents?: true
    fundInvestments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvestorEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorEntity to aggregate.
     */
    where?: InvestorEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorEntities to fetch.
     */
    orderBy?: InvestorEntityOrderByWithRelationInput | InvestorEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorEntities
    **/
    _count?: true | InvestorEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorEntityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorEntitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorEntityMaxAggregateInputType
  }

  export type GetInvestorEntityAggregateType<T extends InvestorEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorEntity[P]>
      : GetScalarType<T[P], AggregateInvestorEntity[P]>
  }




  export type InvestorEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorEntityWhereInput
    orderBy?: InvestorEntityOrderByWithAggregationInput | InvestorEntityOrderByWithAggregationInput[]
    by: InvestorEntityScalarFieldEnum[] | InvestorEntityScalarFieldEnum
    having?: InvestorEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorEntityCountAggregateInputType | true
    _avg?: InvestorEntityAvgAggregateInputType
    _sum?: InvestorEntitySumAggregateInputType
    _min?: InvestorEntityMinAggregateInputType
    _max?: InvestorEntityMaxAggregateInputType
  }

  export type InvestorEntityGroupByOutputType = {
    id: string
    investorId: string
    name: string
    type: string
    investmentType: string
    commitment: number | null
    called: number | null
    status: string
    documents: JsonValue | null
    fundInvestments: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InvestorEntityCountAggregateOutputType | null
    _avg: InvestorEntityAvgAggregateOutputType | null
    _sum: InvestorEntitySumAggregateOutputType | null
    _min: InvestorEntityMinAggregateOutputType | null
    _max: InvestorEntityMaxAggregateOutputType | null
  }

  type GetInvestorEntityGroupByPayload<T extends InvestorEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorEntityGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorEntityGroupByOutputType[P]>
        }
      >
    >


  export type InvestorEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    name?: boolean
    type?: boolean
    investmentType?: boolean
    commitment?: boolean
    called?: boolean
    status?: boolean
    documents?: boolean
    fundInvestments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorEntity"]>

  export type InvestorEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    name?: boolean
    type?: boolean
    investmentType?: boolean
    commitment?: boolean
    called?: boolean
    status?: boolean
    documents?: boolean
    fundInvestments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorEntity"]>

  export type InvestorEntitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    name?: boolean
    type?: boolean
    investmentType?: boolean
    commitment?: boolean
    called?: boolean
    status?: boolean
    documents?: boolean
    fundInvestments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorEntity"]>

  export type InvestorEntitySelectScalar = {
    id?: boolean
    investorId?: boolean
    name?: boolean
    type?: boolean
    investmentType?: boolean
    commitment?: boolean
    called?: boolean
    status?: boolean
    documents?: boolean
    fundInvestments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvestorEntityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "investorId" | "name" | "type" | "investmentType" | "commitment" | "called" | "status" | "documents" | "fundInvestments" | "createdAt" | "updatedAt", ExtArgs["result"]["investorEntity"]>
  export type InvestorEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }
  export type InvestorEntityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }
  export type InvestorEntityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
  }

  export type $InvestorEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorEntity"
    objects: {
      investor: Prisma.$InvestorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorId: string
      name: string
      type: string
      investmentType: string
      commitment: number | null
      called: number | null
      status: string
      documents: Prisma.JsonValue | null
      fundInvestments: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["investorEntity"]>
    composites: {}
  }

  type InvestorEntityGetPayload<S extends boolean | null | undefined | InvestorEntityDefaultArgs> = $Result.GetResult<Prisma.$InvestorEntityPayload, S>

  type InvestorEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorEntityCountAggregateInputType | true
    }

  export interface InvestorEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorEntity'], meta: { name: 'InvestorEntity' } }
    /**
     * Find zero or one InvestorEntity that matches the filter.
     * @param {InvestorEntityFindUniqueArgs} args - Arguments to find a InvestorEntity
     * @example
     * // Get one InvestorEntity
     * const investorEntity = await prisma.investorEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorEntityFindUniqueArgs>(args: SelectSubset<T, InvestorEntityFindUniqueArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvestorEntity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorEntityFindUniqueOrThrowArgs} args - Arguments to find a InvestorEntity
     * @example
     * // Get one InvestorEntity
     * const investorEntity = await prisma.investorEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityFindFirstArgs} args - Arguments to find a InvestorEntity
     * @example
     * // Get one InvestorEntity
     * const investorEntity = await prisma.investorEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorEntityFindFirstArgs>(args?: SelectSubset<T, InvestorEntityFindFirstArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityFindFirstOrThrowArgs} args - Arguments to find a InvestorEntity
     * @example
     * // Get one InvestorEntity
     * const investorEntity = await prisma.investorEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvestorEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorEntities
     * const investorEntities = await prisma.investorEntity.findMany()
     * 
     * // Get first 10 InvestorEntities
     * const investorEntities = await prisma.investorEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorEntityWithIdOnly = await prisma.investorEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorEntityFindManyArgs>(args?: SelectSubset<T, InvestorEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvestorEntity.
     * @param {InvestorEntityCreateArgs} args - Arguments to create a InvestorEntity.
     * @example
     * // Create one InvestorEntity
     * const InvestorEntity = await prisma.investorEntity.create({
     *   data: {
     *     // ... data to create a InvestorEntity
     *   }
     * })
     * 
     */
    create<T extends InvestorEntityCreateArgs>(args: SelectSubset<T, InvestorEntityCreateArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvestorEntities.
     * @param {InvestorEntityCreateManyArgs} args - Arguments to create many InvestorEntities.
     * @example
     * // Create many InvestorEntities
     * const investorEntity = await prisma.investorEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorEntityCreateManyArgs>(args?: SelectSubset<T, InvestorEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorEntities and returns the data saved in the database.
     * @param {InvestorEntityCreateManyAndReturnArgs} args - Arguments to create many InvestorEntities.
     * @example
     * // Create many InvestorEntities
     * const investorEntity = await prisma.investorEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorEntities and only return the `id`
     * const investorEntityWithIdOnly = await prisma.investorEntity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvestorEntity.
     * @param {InvestorEntityDeleteArgs} args - Arguments to delete one InvestorEntity.
     * @example
     * // Delete one InvestorEntity
     * const InvestorEntity = await prisma.investorEntity.delete({
     *   where: {
     *     // ... filter to delete one InvestorEntity
     *   }
     * })
     * 
     */
    delete<T extends InvestorEntityDeleteArgs>(args: SelectSubset<T, InvestorEntityDeleteArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvestorEntity.
     * @param {InvestorEntityUpdateArgs} args - Arguments to update one InvestorEntity.
     * @example
     * // Update one InvestorEntity
     * const investorEntity = await prisma.investorEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorEntityUpdateArgs>(args: SelectSubset<T, InvestorEntityUpdateArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvestorEntities.
     * @param {InvestorEntityDeleteManyArgs} args - Arguments to filter InvestorEntities to delete.
     * @example
     * // Delete a few InvestorEntities
     * const { count } = await prisma.investorEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorEntityDeleteManyArgs>(args?: SelectSubset<T, InvestorEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorEntities
     * const investorEntity = await prisma.investorEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorEntityUpdateManyArgs>(args: SelectSubset<T, InvestorEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorEntities and returns the data updated in the database.
     * @param {InvestorEntityUpdateManyAndReturnArgs} args - Arguments to update many InvestorEntities.
     * @example
     * // Update many InvestorEntities
     * const investorEntity = await prisma.investorEntity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvestorEntities and only return the `id`
     * const investorEntityWithIdOnly = await prisma.investorEntity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorEntityUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorEntityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvestorEntity.
     * @param {InvestorEntityUpsertArgs} args - Arguments to update or create a InvestorEntity.
     * @example
     * // Update or create a InvestorEntity
     * const investorEntity = await prisma.investorEntity.upsert({
     *   create: {
     *     // ... data to create a InvestorEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorEntity we want to update
     *   }
     * })
     */
    upsert<T extends InvestorEntityUpsertArgs>(args: SelectSubset<T, InvestorEntityUpsertArgs<ExtArgs>>): Prisma__InvestorEntityClient<$Result.GetResult<Prisma.$InvestorEntityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvestorEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityCountArgs} args - Arguments to filter InvestorEntities to count.
     * @example
     * // Count the number of InvestorEntities
     * const count = await prisma.investorEntity.count({
     *   where: {
     *     // ... the filter for the InvestorEntities we want to count
     *   }
     * })
    **/
    count<T extends InvestorEntityCountArgs>(
      args?: Subset<T, InvestorEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorEntityAggregateArgs>(args: Subset<T, InvestorEntityAggregateArgs>): Prisma.PrismaPromise<GetInvestorEntityAggregateType<T>>

    /**
     * Group by InvestorEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorEntityGroupByArgs['orderBy'] }
        : { orderBy?: InvestorEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorEntity model
   */
  readonly fields: InvestorEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorEntity model
   */
  interface InvestorEntityFieldRefs {
    readonly id: FieldRef<"InvestorEntity", 'String'>
    readonly investorId: FieldRef<"InvestorEntity", 'String'>
    readonly name: FieldRef<"InvestorEntity", 'String'>
    readonly type: FieldRef<"InvestorEntity", 'String'>
    readonly investmentType: FieldRef<"InvestorEntity", 'String'>
    readonly commitment: FieldRef<"InvestorEntity", 'Float'>
    readonly called: FieldRef<"InvestorEntity", 'Float'>
    readonly status: FieldRef<"InvestorEntity", 'String'>
    readonly documents: FieldRef<"InvestorEntity", 'Json'>
    readonly fundInvestments: FieldRef<"InvestorEntity", 'Json'>
    readonly createdAt: FieldRef<"InvestorEntity", 'DateTime'>
    readonly updatedAt: FieldRef<"InvestorEntity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvestorEntity findUnique
   */
  export type InvestorEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * Filter, which InvestorEntity to fetch.
     */
    where: InvestorEntityWhereUniqueInput
  }

  /**
   * InvestorEntity findUniqueOrThrow
   */
  export type InvestorEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * Filter, which InvestorEntity to fetch.
     */
    where: InvestorEntityWhereUniqueInput
  }

  /**
   * InvestorEntity findFirst
   */
  export type InvestorEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * Filter, which InvestorEntity to fetch.
     */
    where?: InvestorEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorEntities to fetch.
     */
    orderBy?: InvestorEntityOrderByWithRelationInput | InvestorEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorEntities.
     */
    cursor?: InvestorEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorEntities.
     */
    distinct?: InvestorEntityScalarFieldEnum | InvestorEntityScalarFieldEnum[]
  }

  /**
   * InvestorEntity findFirstOrThrow
   */
  export type InvestorEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * Filter, which InvestorEntity to fetch.
     */
    where?: InvestorEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorEntities to fetch.
     */
    orderBy?: InvestorEntityOrderByWithRelationInput | InvestorEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorEntities.
     */
    cursor?: InvestorEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorEntities.
     */
    distinct?: InvestorEntityScalarFieldEnum | InvestorEntityScalarFieldEnum[]
  }

  /**
   * InvestorEntity findMany
   */
  export type InvestorEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * Filter, which InvestorEntities to fetch.
     */
    where?: InvestorEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorEntities to fetch.
     */
    orderBy?: InvestorEntityOrderByWithRelationInput | InvestorEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorEntities.
     */
    cursor?: InvestorEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorEntities.
     */
    skip?: number
    distinct?: InvestorEntityScalarFieldEnum | InvestorEntityScalarFieldEnum[]
  }

  /**
   * InvestorEntity create
   */
  export type InvestorEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorEntity.
     */
    data: XOR<InvestorEntityCreateInput, InvestorEntityUncheckedCreateInput>
  }

  /**
   * InvestorEntity createMany
   */
  export type InvestorEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorEntities.
     */
    data: InvestorEntityCreateManyInput | InvestorEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorEntity createManyAndReturn
   */
  export type InvestorEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * The data used to create many InvestorEntities.
     */
    data: InvestorEntityCreateManyInput | InvestorEntityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorEntity update
   */
  export type InvestorEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorEntity.
     */
    data: XOR<InvestorEntityUpdateInput, InvestorEntityUncheckedUpdateInput>
    /**
     * Choose, which InvestorEntity to update.
     */
    where: InvestorEntityWhereUniqueInput
  }

  /**
   * InvestorEntity updateMany
   */
  export type InvestorEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorEntities.
     */
    data: XOR<InvestorEntityUpdateManyMutationInput, InvestorEntityUncheckedUpdateManyInput>
    /**
     * Filter which InvestorEntities to update
     */
    where?: InvestorEntityWhereInput
    /**
     * Limit how many InvestorEntities to update.
     */
    limit?: number
  }

  /**
   * InvestorEntity updateManyAndReturn
   */
  export type InvestorEntityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * The data used to update InvestorEntities.
     */
    data: XOR<InvestorEntityUpdateManyMutationInput, InvestorEntityUncheckedUpdateManyInput>
    /**
     * Filter which InvestorEntities to update
     */
    where?: InvestorEntityWhereInput
    /**
     * Limit how many InvestorEntities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorEntity upsert
   */
  export type InvestorEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorEntity to update in case it exists.
     */
    where: InvestorEntityWhereUniqueInput
    /**
     * In case the InvestorEntity found by the `where` argument doesn't exist, create a new InvestorEntity with this data.
     */
    create: XOR<InvestorEntityCreateInput, InvestorEntityUncheckedCreateInput>
    /**
     * In case the InvestorEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorEntityUpdateInput, InvestorEntityUncheckedUpdateInput>
  }

  /**
   * InvestorEntity delete
   */
  export type InvestorEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
    /**
     * Filter which InvestorEntity to delete.
     */
    where: InvestorEntityWhereUniqueInput
  }

  /**
   * InvestorEntity deleteMany
   */
  export type InvestorEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorEntities to delete
     */
    where?: InvestorEntityWhereInput
    /**
     * Limit how many InvestorEntities to delete.
     */
    limit?: number
  }

  /**
   * InvestorEntity without action
   */
  export type InvestorEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorEntity
     */
    select?: InvestorEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorEntity
     */
    omit?: InvestorEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorEntityInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    type: string | null
    format: string | null
    content: string | null
    url: string | null
    status: string | null
    sentAt: Date | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    type: string | null
    format: string | null
    content: string | null
    url: string | null
    status: string | null
    sentAt: Date | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    type: number
    format: number
    content: number
    data: number
    url: number
    status: number
    recipients: number
    sentAt: number
    generatedAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    type?: true
    format?: true
    content?: true
    url?: true
    status?: true
    sentAt?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    type?: true
    format?: true
    content?: true
    url?: true
    status?: true
    sentAt?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    type?: true
    format?: true
    content?: true
    data?: true
    url?: true
    status?: true
    recipients?: true
    sentAt?: true
    generatedAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    userId: string
    title: string
    type: string
    format: string
    content: string | null
    data: JsonValue | null
    url: string | null
    status: string
    recipients: string[]
    sentAt: Date | null
    generatedAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    format?: boolean
    content?: boolean
    data?: boolean
    url?: boolean
    status?: boolean
    recipients?: boolean
    sentAt?: boolean
    generatedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    format?: boolean
    content?: boolean
    data?: boolean
    url?: boolean
    status?: boolean
    recipients?: boolean
    sentAt?: boolean
    generatedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    format?: boolean
    content?: boolean
    data?: boolean
    url?: boolean
    status?: boolean
    recipients?: boolean
    sentAt?: boolean
    generatedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    type?: boolean
    format?: boolean
    content?: boolean
    data?: boolean
    url?: boolean
    status?: boolean
    recipients?: boolean
    sentAt?: boolean
    generatedAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "type" | "format" | "content" | "data" | "url" | "status" | "recipients" | "sentAt" | "generatedAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["report"]>

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      type: string
      format: string
      content: string | null
      data: Prisma.JsonValue | null
      url: string | null
      status: string
      recipients: string[]
      sentAt: Date | null
      generatedAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly title: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly format: FieldRef<"Report", 'String'>
    readonly content: FieldRef<"Report", 'String'>
    readonly data: FieldRef<"Report", 'Json'>
    readonly url: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'String'>
    readonly recipients: FieldRef<"Report", 'String[]'>
    readonly sentAt: FieldRef<"Report", 'DateTime'>
    readonly generatedAt: FieldRef<"Report", 'DateTime'>
    readonly metadata: FieldRef<"Report", 'Json'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
  }


  /**
   * Model SyncJob
   */

  export type AggregateSyncJob = {
    _count: SyncJobCountAggregateOutputType | null
    _avg: SyncJobAvgAggregateOutputType | null
    _sum: SyncJobSumAggregateOutputType | null
    _min: SyncJobMinAggregateOutputType | null
    _max: SyncJobMaxAggregateOutputType | null
  }

  export type SyncJobAvgAggregateOutputType = {
    itemsProcessed: number | null
  }

  export type SyncJobSumAggregateOutputType = {
    itemsProcessed: number | null
  }

  export type SyncJobMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    itemsProcessed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyncJobMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    itemsProcessed: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyncJobCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    status: number
    startedAt: number
    completedAt: number
    errorMessage: number
    itemsProcessed: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SyncJobAvgAggregateInputType = {
    itemsProcessed?: true
  }

  export type SyncJobSumAggregateInputType = {
    itemsProcessed?: true
  }

  export type SyncJobMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    itemsProcessed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyncJobMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    itemsProcessed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyncJobCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    status?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    itemsProcessed?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SyncJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncJob to aggregate.
     */
    where?: SyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncJobs to fetch.
     */
    orderBy?: SyncJobOrderByWithRelationInput | SyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncJobs
    **/
    _count?: true | SyncJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncJobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncJobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncJobMaxAggregateInputType
  }

  export type GetSyncJobAggregateType<T extends SyncJobAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncJob[P]>
      : GetScalarType<T[P], AggregateSyncJob[P]>
  }




  export type SyncJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncJobWhereInput
    orderBy?: SyncJobOrderByWithAggregationInput | SyncJobOrderByWithAggregationInput[]
    by: SyncJobScalarFieldEnum[] | SyncJobScalarFieldEnum
    having?: SyncJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncJobCountAggregateInputType | true
    _avg?: SyncJobAvgAggregateInputType
    _sum?: SyncJobSumAggregateInputType
    _min?: SyncJobMinAggregateInputType
    _max?: SyncJobMaxAggregateInputType
  }

  export type SyncJobGroupByOutputType = {
    id: string
    userId: string
    type: string
    status: string
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    itemsProcessed: number | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SyncJobCountAggregateOutputType | null
    _avg: SyncJobAvgAggregateOutputType | null
    _sum: SyncJobSumAggregateOutputType | null
    _min: SyncJobMinAggregateOutputType | null
    _max: SyncJobMaxAggregateOutputType | null
  }

  type GetSyncJobGroupByPayload<T extends SyncJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncJobGroupByOutputType[P]>
            : GetScalarType<T[P], SyncJobGroupByOutputType[P]>
        }
      >
    >


  export type SyncJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    itemsProcessed?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncJob"]>

  export type SyncJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    itemsProcessed?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncJob"]>

  export type SyncJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    itemsProcessed?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncJob"]>

  export type SyncJobSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    itemsProcessed?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SyncJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "status" | "startedAt" | "completedAt" | "errorMessage" | "itemsProcessed" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["syncJob"]>

  export type $SyncJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncJob"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      status: string
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      itemsProcessed: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["syncJob"]>
    composites: {}
  }

  type SyncJobGetPayload<S extends boolean | null | undefined | SyncJobDefaultArgs> = $Result.GetResult<Prisma.$SyncJobPayload, S>

  type SyncJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncJobCountAggregateInputType | true
    }

  export interface SyncJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncJob'], meta: { name: 'SyncJob' } }
    /**
     * Find zero or one SyncJob that matches the filter.
     * @param {SyncJobFindUniqueArgs} args - Arguments to find a SyncJob
     * @example
     * // Get one SyncJob
     * const syncJob = await prisma.syncJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncJobFindUniqueArgs>(args: SelectSubset<T, SyncJobFindUniqueArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncJobFindUniqueOrThrowArgs} args - Arguments to find a SyncJob
     * @example
     * // Get one SyncJob
     * const syncJob = await prisma.syncJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncJobFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobFindFirstArgs} args - Arguments to find a SyncJob
     * @example
     * // Get one SyncJob
     * const syncJob = await prisma.syncJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncJobFindFirstArgs>(args?: SelectSubset<T, SyncJobFindFirstArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobFindFirstOrThrowArgs} args - Arguments to find a SyncJob
     * @example
     * // Get one SyncJob
     * const syncJob = await prisma.syncJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncJobFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncJobs
     * const syncJobs = await prisma.syncJob.findMany()
     * 
     * // Get first 10 SyncJobs
     * const syncJobs = await prisma.syncJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncJobWithIdOnly = await prisma.syncJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncJobFindManyArgs>(args?: SelectSubset<T, SyncJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncJob.
     * @param {SyncJobCreateArgs} args - Arguments to create a SyncJob.
     * @example
     * // Create one SyncJob
     * const SyncJob = await prisma.syncJob.create({
     *   data: {
     *     // ... data to create a SyncJob
     *   }
     * })
     * 
     */
    create<T extends SyncJobCreateArgs>(args: SelectSubset<T, SyncJobCreateArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncJobs.
     * @param {SyncJobCreateManyArgs} args - Arguments to create many SyncJobs.
     * @example
     * // Create many SyncJobs
     * const syncJob = await prisma.syncJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncJobCreateManyArgs>(args?: SelectSubset<T, SyncJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncJobs and returns the data saved in the database.
     * @param {SyncJobCreateManyAndReturnArgs} args - Arguments to create many SyncJobs.
     * @example
     * // Create many SyncJobs
     * const syncJob = await prisma.syncJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncJobs and only return the `id`
     * const syncJobWithIdOnly = await prisma.syncJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncJobCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncJob.
     * @param {SyncJobDeleteArgs} args - Arguments to delete one SyncJob.
     * @example
     * // Delete one SyncJob
     * const SyncJob = await prisma.syncJob.delete({
     *   where: {
     *     // ... filter to delete one SyncJob
     *   }
     * })
     * 
     */
    delete<T extends SyncJobDeleteArgs>(args: SelectSubset<T, SyncJobDeleteArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncJob.
     * @param {SyncJobUpdateArgs} args - Arguments to update one SyncJob.
     * @example
     * // Update one SyncJob
     * const syncJob = await prisma.syncJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncJobUpdateArgs>(args: SelectSubset<T, SyncJobUpdateArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncJobs.
     * @param {SyncJobDeleteManyArgs} args - Arguments to filter SyncJobs to delete.
     * @example
     * // Delete a few SyncJobs
     * const { count } = await prisma.syncJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncJobDeleteManyArgs>(args?: SelectSubset<T, SyncJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncJobs
     * const syncJob = await prisma.syncJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncJobUpdateManyArgs>(args: SelectSubset<T, SyncJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncJobs and returns the data updated in the database.
     * @param {SyncJobUpdateManyAndReturnArgs} args - Arguments to update many SyncJobs.
     * @example
     * // Update many SyncJobs
     * const syncJob = await prisma.syncJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncJobs and only return the `id`
     * const syncJobWithIdOnly = await prisma.syncJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncJobUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncJob.
     * @param {SyncJobUpsertArgs} args - Arguments to update or create a SyncJob.
     * @example
     * // Update or create a SyncJob
     * const syncJob = await prisma.syncJob.upsert({
     *   create: {
     *     // ... data to create a SyncJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncJob we want to update
     *   }
     * })
     */
    upsert<T extends SyncJobUpsertArgs>(args: SelectSubset<T, SyncJobUpsertArgs<ExtArgs>>): Prisma__SyncJobClient<$Result.GetResult<Prisma.$SyncJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobCountArgs} args - Arguments to filter SyncJobs to count.
     * @example
     * // Count the number of SyncJobs
     * const count = await prisma.syncJob.count({
     *   where: {
     *     // ... the filter for the SyncJobs we want to count
     *   }
     * })
    **/
    count<T extends SyncJobCountArgs>(
      args?: Subset<T, SyncJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncJobAggregateArgs>(args: Subset<T, SyncJobAggregateArgs>): Prisma.PrismaPromise<GetSyncJobAggregateType<T>>

    /**
     * Group by SyncJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncJobGroupByArgs['orderBy'] }
        : { orderBy?: SyncJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncJob model
   */
  readonly fields: SyncJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncJob model
   */
  interface SyncJobFieldRefs {
    readonly id: FieldRef<"SyncJob", 'String'>
    readonly userId: FieldRef<"SyncJob", 'String'>
    readonly type: FieldRef<"SyncJob", 'String'>
    readonly status: FieldRef<"SyncJob", 'String'>
    readonly startedAt: FieldRef<"SyncJob", 'DateTime'>
    readonly completedAt: FieldRef<"SyncJob", 'DateTime'>
    readonly errorMessage: FieldRef<"SyncJob", 'String'>
    readonly itemsProcessed: FieldRef<"SyncJob", 'Int'>
    readonly metadata: FieldRef<"SyncJob", 'Json'>
    readonly createdAt: FieldRef<"SyncJob", 'DateTime'>
    readonly updatedAt: FieldRef<"SyncJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncJob findUnique
   */
  export type SyncJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * Filter, which SyncJob to fetch.
     */
    where: SyncJobWhereUniqueInput
  }

  /**
   * SyncJob findUniqueOrThrow
   */
  export type SyncJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * Filter, which SyncJob to fetch.
     */
    where: SyncJobWhereUniqueInput
  }

  /**
   * SyncJob findFirst
   */
  export type SyncJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * Filter, which SyncJob to fetch.
     */
    where?: SyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncJobs to fetch.
     */
    orderBy?: SyncJobOrderByWithRelationInput | SyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncJobs.
     */
    cursor?: SyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncJobs.
     */
    distinct?: SyncJobScalarFieldEnum | SyncJobScalarFieldEnum[]
  }

  /**
   * SyncJob findFirstOrThrow
   */
  export type SyncJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * Filter, which SyncJob to fetch.
     */
    where?: SyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncJobs to fetch.
     */
    orderBy?: SyncJobOrderByWithRelationInput | SyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncJobs.
     */
    cursor?: SyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncJobs.
     */
    distinct?: SyncJobScalarFieldEnum | SyncJobScalarFieldEnum[]
  }

  /**
   * SyncJob findMany
   */
  export type SyncJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * Filter, which SyncJobs to fetch.
     */
    where?: SyncJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncJobs to fetch.
     */
    orderBy?: SyncJobOrderByWithRelationInput | SyncJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncJobs.
     */
    cursor?: SyncJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncJobs.
     */
    skip?: number
    distinct?: SyncJobScalarFieldEnum | SyncJobScalarFieldEnum[]
  }

  /**
   * SyncJob create
   */
  export type SyncJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncJob.
     */
    data: XOR<SyncJobCreateInput, SyncJobUncheckedCreateInput>
  }

  /**
   * SyncJob createMany
   */
  export type SyncJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncJobs.
     */
    data: SyncJobCreateManyInput | SyncJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncJob createManyAndReturn
   */
  export type SyncJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * The data used to create many SyncJobs.
     */
    data: SyncJobCreateManyInput | SyncJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SyncJob update
   */
  export type SyncJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncJob.
     */
    data: XOR<SyncJobUpdateInput, SyncJobUncheckedUpdateInput>
    /**
     * Choose, which SyncJob to update.
     */
    where: SyncJobWhereUniqueInput
  }

  /**
   * SyncJob updateMany
   */
  export type SyncJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncJobs.
     */
    data: XOR<SyncJobUpdateManyMutationInput, SyncJobUncheckedUpdateManyInput>
    /**
     * Filter which SyncJobs to update
     */
    where?: SyncJobWhereInput
    /**
     * Limit how many SyncJobs to update.
     */
    limit?: number
  }

  /**
   * SyncJob updateManyAndReturn
   */
  export type SyncJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * The data used to update SyncJobs.
     */
    data: XOR<SyncJobUpdateManyMutationInput, SyncJobUncheckedUpdateManyInput>
    /**
     * Filter which SyncJobs to update
     */
    where?: SyncJobWhereInput
    /**
     * Limit how many SyncJobs to update.
     */
    limit?: number
  }

  /**
   * SyncJob upsert
   */
  export type SyncJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncJob to update in case it exists.
     */
    where: SyncJobWhereUniqueInput
    /**
     * In case the SyncJob found by the `where` argument doesn't exist, create a new SyncJob with this data.
     */
    create: XOR<SyncJobCreateInput, SyncJobUncheckedCreateInput>
    /**
     * In case the SyncJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncJobUpdateInput, SyncJobUncheckedUpdateInput>
  }

  /**
   * SyncJob delete
   */
  export type SyncJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
    /**
     * Filter which SyncJob to delete.
     */
    where: SyncJobWhereUniqueInput
  }

  /**
   * SyncJob deleteMany
   */
  export type SyncJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncJobs to delete
     */
    where?: SyncJobWhereInput
    /**
     * Limit how many SyncJobs to delete.
     */
    limit?: number
  }

  /**
   * SyncJob without action
   */
  export type SyncJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncJob
     */
    select?: SyncJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncJob
     */
    omit?: SyncJobOmit<ExtArgs> | null
  }


  /**
   * Model TeamsMessage
   */

  export type AggregateTeamsMessage = {
    _count: TeamsMessageCountAggregateOutputType | null
    _min: TeamsMessageMinAggregateOutputType | null
    _max: TeamsMessageMaxAggregateOutputType | null
  }

  export type TeamsMessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    messageId: string | null
    chatId: string | null
    channelId: string | null
    teamId: string | null
    fromEmail: string | null
    fromName: string | null
    content: string | null
    contentType: string | null
    importance: string | null
    messageType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
  }

  export type TeamsMessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    messageId: string | null
    chatId: string | null
    channelId: string | null
    teamId: string | null
    fromEmail: string | null
    fromName: string | null
    content: string | null
    contentType: string | null
    importance: string | null
    messageType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    sentAt: Date | null
  }

  export type TeamsMessageCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    contactId: number
    messageId: number
    chatId: number
    channelId: number
    teamId: number
    fromEmail: number
    fromName: number
    content: number
    contentType: number
    importance: number
    messageType: number
    attachments: number
    mentions: number
    createdAt: number
    updatedAt: number
    sentAt: number
    _all: number
  }


  export type TeamsMessageMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    messageId?: true
    chatId?: true
    channelId?: true
    teamId?: true
    fromEmail?: true
    fromName?: true
    content?: true
    contentType?: true
    importance?: true
    messageType?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
  }

  export type TeamsMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    messageId?: true
    chatId?: true
    channelId?: true
    teamId?: true
    fromEmail?: true
    fromName?: true
    content?: true
    contentType?: true
    importance?: true
    messageType?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
  }

  export type TeamsMessageCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    messageId?: true
    chatId?: true
    channelId?: true
    teamId?: true
    fromEmail?: true
    fromName?: true
    content?: true
    contentType?: true
    importance?: true
    messageType?: true
    attachments?: true
    mentions?: true
    createdAt?: true
    updatedAt?: true
    sentAt?: true
    _all?: true
  }

  export type TeamsMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamsMessage to aggregate.
     */
    where?: TeamsMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsMessages to fetch.
     */
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamsMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamsMessages
    **/
    _count?: true | TeamsMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamsMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamsMessageMaxAggregateInputType
  }

  export type GetTeamsMessageAggregateType<T extends TeamsMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamsMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamsMessage[P]>
      : GetScalarType<T[P], AggregateTeamsMessage[P]>
  }




  export type TeamsMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsMessageWhereInput
    orderBy?: TeamsMessageOrderByWithAggregationInput | TeamsMessageOrderByWithAggregationInput[]
    by: TeamsMessageScalarFieldEnum[] | TeamsMessageScalarFieldEnum
    having?: TeamsMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamsMessageCountAggregateInputType | true
    _min?: TeamsMessageMinAggregateInputType
    _max?: TeamsMessageMaxAggregateInputType
  }

  export type TeamsMessageGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    contactId: string | null
    messageId: string
    chatId: string | null
    channelId: string | null
    teamId: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType: string
    importance: string
    messageType: string
    attachments: JsonValue | null
    mentions: string[]
    createdAt: Date
    updatedAt: Date
    sentAt: Date
    _count: TeamsMessageCountAggregateOutputType | null
    _min: TeamsMessageMinAggregateOutputType | null
    _max: TeamsMessageMaxAggregateOutputType | null
  }

  type GetTeamsMessageGroupByPayload<T extends TeamsMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamsMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamsMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamsMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TeamsMessageGroupByOutputType[P]>
        }
      >
    >


  export type TeamsMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    chatId?: boolean
    channelId?: boolean
    teamId?: boolean
    fromEmail?: boolean
    fromName?: boolean
    content?: boolean
    contentType?: boolean
    importance?: boolean
    messageType?: boolean
    attachments?: boolean
    mentions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | TeamsMessage$dealArgs<ExtArgs>
    contact?: boolean | TeamsMessage$contactArgs<ExtArgs>
  }, ExtArgs["result"]["teamsMessage"]>

  export type TeamsMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    chatId?: boolean
    channelId?: boolean
    teamId?: boolean
    fromEmail?: boolean
    fromName?: boolean
    content?: boolean
    contentType?: boolean
    importance?: boolean
    messageType?: boolean
    attachments?: boolean
    mentions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | TeamsMessage$dealArgs<ExtArgs>
    contact?: boolean | TeamsMessage$contactArgs<ExtArgs>
  }, ExtArgs["result"]["teamsMessage"]>

  export type TeamsMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    chatId?: boolean
    channelId?: boolean
    teamId?: boolean
    fromEmail?: boolean
    fromName?: boolean
    content?: boolean
    contentType?: boolean
    importance?: boolean
    messageType?: boolean
    attachments?: boolean
    mentions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | TeamsMessage$dealArgs<ExtArgs>
    contact?: boolean | TeamsMessage$contactArgs<ExtArgs>
  }, ExtArgs["result"]["teamsMessage"]>

  export type TeamsMessageSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    chatId?: boolean
    channelId?: boolean
    teamId?: boolean
    fromEmail?: boolean
    fromName?: boolean
    content?: boolean
    contentType?: boolean
    importance?: boolean
    messageType?: boolean
    attachments?: boolean
    mentions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sentAt?: boolean
  }

  export type TeamsMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "contactId" | "messageId" | "chatId" | "channelId" | "teamId" | "fromEmail" | "fromName" | "content" | "contentType" | "importance" | "messageType" | "attachments" | "mentions" | "createdAt" | "updatedAt" | "sentAt", ExtArgs["result"]["teamsMessage"]>
  export type TeamsMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | TeamsMessage$dealArgs<ExtArgs>
    contact?: boolean | TeamsMessage$contactArgs<ExtArgs>
  }
  export type TeamsMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | TeamsMessage$dealArgs<ExtArgs>
    contact?: boolean | TeamsMessage$contactArgs<ExtArgs>
  }
  export type TeamsMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | TeamsMessage$dealArgs<ExtArgs>
    contact?: boolean | TeamsMessage$contactArgs<ExtArgs>
  }

  export type $TeamsMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamsMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      contactId: string | null
      messageId: string
      chatId: string | null
      channelId: string | null
      teamId: string | null
      fromEmail: string
      fromName: string
      content: string
      contentType: string
      importance: string
      messageType: string
      attachments: Prisma.JsonValue | null
      mentions: string[]
      createdAt: Date
      updatedAt: Date
      sentAt: Date
    }, ExtArgs["result"]["teamsMessage"]>
    composites: {}
  }

  type TeamsMessageGetPayload<S extends boolean | null | undefined | TeamsMessageDefaultArgs> = $Result.GetResult<Prisma.$TeamsMessagePayload, S>

  type TeamsMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamsMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamsMessageCountAggregateInputType | true
    }

  export interface TeamsMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamsMessage'], meta: { name: 'TeamsMessage' } }
    /**
     * Find zero or one TeamsMessage that matches the filter.
     * @param {TeamsMessageFindUniqueArgs} args - Arguments to find a TeamsMessage
     * @example
     * // Get one TeamsMessage
     * const teamsMessage = await prisma.teamsMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamsMessageFindUniqueArgs>(args: SelectSubset<T, TeamsMessageFindUniqueArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamsMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamsMessageFindUniqueOrThrowArgs} args - Arguments to find a TeamsMessage
     * @example
     * // Get one TeamsMessage
     * const teamsMessage = await prisma.teamsMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamsMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamsMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamsMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageFindFirstArgs} args - Arguments to find a TeamsMessage
     * @example
     * // Get one TeamsMessage
     * const teamsMessage = await prisma.teamsMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamsMessageFindFirstArgs>(args?: SelectSubset<T, TeamsMessageFindFirstArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamsMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageFindFirstOrThrowArgs} args - Arguments to find a TeamsMessage
     * @example
     * // Get one TeamsMessage
     * const teamsMessage = await prisma.teamsMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamsMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamsMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamsMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamsMessages
     * const teamsMessages = await prisma.teamsMessage.findMany()
     * 
     * // Get first 10 TeamsMessages
     * const teamsMessages = await prisma.teamsMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamsMessageWithIdOnly = await prisma.teamsMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamsMessageFindManyArgs>(args?: SelectSubset<T, TeamsMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamsMessage.
     * @param {TeamsMessageCreateArgs} args - Arguments to create a TeamsMessage.
     * @example
     * // Create one TeamsMessage
     * const TeamsMessage = await prisma.teamsMessage.create({
     *   data: {
     *     // ... data to create a TeamsMessage
     *   }
     * })
     * 
     */
    create<T extends TeamsMessageCreateArgs>(args: SelectSubset<T, TeamsMessageCreateArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamsMessages.
     * @param {TeamsMessageCreateManyArgs} args - Arguments to create many TeamsMessages.
     * @example
     * // Create many TeamsMessages
     * const teamsMessage = await prisma.teamsMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamsMessageCreateManyArgs>(args?: SelectSubset<T, TeamsMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamsMessages and returns the data saved in the database.
     * @param {TeamsMessageCreateManyAndReturnArgs} args - Arguments to create many TeamsMessages.
     * @example
     * // Create many TeamsMessages
     * const teamsMessage = await prisma.teamsMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamsMessages and only return the `id`
     * const teamsMessageWithIdOnly = await prisma.teamsMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamsMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamsMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamsMessage.
     * @param {TeamsMessageDeleteArgs} args - Arguments to delete one TeamsMessage.
     * @example
     * // Delete one TeamsMessage
     * const TeamsMessage = await prisma.teamsMessage.delete({
     *   where: {
     *     // ... filter to delete one TeamsMessage
     *   }
     * })
     * 
     */
    delete<T extends TeamsMessageDeleteArgs>(args: SelectSubset<T, TeamsMessageDeleteArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamsMessage.
     * @param {TeamsMessageUpdateArgs} args - Arguments to update one TeamsMessage.
     * @example
     * // Update one TeamsMessage
     * const teamsMessage = await prisma.teamsMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamsMessageUpdateArgs>(args: SelectSubset<T, TeamsMessageUpdateArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamsMessages.
     * @param {TeamsMessageDeleteManyArgs} args - Arguments to filter TeamsMessages to delete.
     * @example
     * // Delete a few TeamsMessages
     * const { count } = await prisma.teamsMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamsMessageDeleteManyArgs>(args?: SelectSubset<T, TeamsMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamsMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamsMessages
     * const teamsMessage = await prisma.teamsMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamsMessageUpdateManyArgs>(args: SelectSubset<T, TeamsMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamsMessages and returns the data updated in the database.
     * @param {TeamsMessageUpdateManyAndReturnArgs} args - Arguments to update many TeamsMessages.
     * @example
     * // Update many TeamsMessages
     * const teamsMessage = await prisma.teamsMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamsMessages and only return the `id`
     * const teamsMessageWithIdOnly = await prisma.teamsMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamsMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamsMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamsMessage.
     * @param {TeamsMessageUpsertArgs} args - Arguments to update or create a TeamsMessage.
     * @example
     * // Update or create a TeamsMessage
     * const teamsMessage = await prisma.teamsMessage.upsert({
     *   create: {
     *     // ... data to create a TeamsMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamsMessage we want to update
     *   }
     * })
     */
    upsert<T extends TeamsMessageUpsertArgs>(args: SelectSubset<T, TeamsMessageUpsertArgs<ExtArgs>>): Prisma__TeamsMessageClient<$Result.GetResult<Prisma.$TeamsMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamsMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageCountArgs} args - Arguments to filter TeamsMessages to count.
     * @example
     * // Count the number of TeamsMessages
     * const count = await prisma.teamsMessage.count({
     *   where: {
     *     // ... the filter for the TeamsMessages we want to count
     *   }
     * })
    **/
    count<T extends TeamsMessageCountArgs>(
      args?: Subset<T, TeamsMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamsMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamsMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamsMessageAggregateArgs>(args: Subset<T, TeamsMessageAggregateArgs>): Prisma.PrismaPromise<GetTeamsMessageAggregateType<T>>

    /**
     * Group by TeamsMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamsMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamsMessageGroupByArgs['orderBy'] }
        : { orderBy?: TeamsMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamsMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamsMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamsMessage model
   */
  readonly fields: TeamsMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamsMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamsMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends TeamsMessage$dealArgs<ExtArgs> = {}>(args?: Subset<T, TeamsMessage$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends TeamsMessage$contactArgs<ExtArgs> = {}>(args?: Subset<T, TeamsMessage$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamsMessage model
   */
  interface TeamsMessageFieldRefs {
    readonly id: FieldRef<"TeamsMessage", 'String'>
    readonly userId: FieldRef<"TeamsMessage", 'String'>
    readonly dealId: FieldRef<"TeamsMessage", 'String'>
    readonly contactId: FieldRef<"TeamsMessage", 'String'>
    readonly messageId: FieldRef<"TeamsMessage", 'String'>
    readonly chatId: FieldRef<"TeamsMessage", 'String'>
    readonly channelId: FieldRef<"TeamsMessage", 'String'>
    readonly teamId: FieldRef<"TeamsMessage", 'String'>
    readonly fromEmail: FieldRef<"TeamsMessage", 'String'>
    readonly fromName: FieldRef<"TeamsMessage", 'String'>
    readonly content: FieldRef<"TeamsMessage", 'String'>
    readonly contentType: FieldRef<"TeamsMessage", 'String'>
    readonly importance: FieldRef<"TeamsMessage", 'String'>
    readonly messageType: FieldRef<"TeamsMessage", 'String'>
    readonly attachments: FieldRef<"TeamsMessage", 'Json'>
    readonly mentions: FieldRef<"TeamsMessage", 'String[]'>
    readonly createdAt: FieldRef<"TeamsMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamsMessage", 'DateTime'>
    readonly sentAt: FieldRef<"TeamsMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamsMessage findUnique
   */
  export type TeamsMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * Filter, which TeamsMessage to fetch.
     */
    where: TeamsMessageWhereUniqueInput
  }

  /**
   * TeamsMessage findUniqueOrThrow
   */
  export type TeamsMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * Filter, which TeamsMessage to fetch.
     */
    where: TeamsMessageWhereUniqueInput
  }

  /**
   * TeamsMessage findFirst
   */
  export type TeamsMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * Filter, which TeamsMessage to fetch.
     */
    where?: TeamsMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsMessages to fetch.
     */
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamsMessages.
     */
    cursor?: TeamsMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamsMessages.
     */
    distinct?: TeamsMessageScalarFieldEnum | TeamsMessageScalarFieldEnum[]
  }

  /**
   * TeamsMessage findFirstOrThrow
   */
  export type TeamsMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * Filter, which TeamsMessage to fetch.
     */
    where?: TeamsMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsMessages to fetch.
     */
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamsMessages.
     */
    cursor?: TeamsMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamsMessages.
     */
    distinct?: TeamsMessageScalarFieldEnum | TeamsMessageScalarFieldEnum[]
  }

  /**
   * TeamsMessage findMany
   */
  export type TeamsMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * Filter, which TeamsMessages to fetch.
     */
    where?: TeamsMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsMessages to fetch.
     */
    orderBy?: TeamsMessageOrderByWithRelationInput | TeamsMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamsMessages.
     */
    cursor?: TeamsMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsMessages.
     */
    skip?: number
    distinct?: TeamsMessageScalarFieldEnum | TeamsMessageScalarFieldEnum[]
  }

  /**
   * TeamsMessage create
   */
  export type TeamsMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamsMessage.
     */
    data: XOR<TeamsMessageCreateInput, TeamsMessageUncheckedCreateInput>
  }

  /**
   * TeamsMessage createMany
   */
  export type TeamsMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamsMessages.
     */
    data: TeamsMessageCreateManyInput | TeamsMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamsMessage createManyAndReturn
   */
  export type TeamsMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * The data used to create many TeamsMessages.
     */
    data: TeamsMessageCreateManyInput | TeamsMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamsMessage update
   */
  export type TeamsMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamsMessage.
     */
    data: XOR<TeamsMessageUpdateInput, TeamsMessageUncheckedUpdateInput>
    /**
     * Choose, which TeamsMessage to update.
     */
    where: TeamsMessageWhereUniqueInput
  }

  /**
   * TeamsMessage updateMany
   */
  export type TeamsMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamsMessages.
     */
    data: XOR<TeamsMessageUpdateManyMutationInput, TeamsMessageUncheckedUpdateManyInput>
    /**
     * Filter which TeamsMessages to update
     */
    where?: TeamsMessageWhereInput
    /**
     * Limit how many TeamsMessages to update.
     */
    limit?: number
  }

  /**
   * TeamsMessage updateManyAndReturn
   */
  export type TeamsMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * The data used to update TeamsMessages.
     */
    data: XOR<TeamsMessageUpdateManyMutationInput, TeamsMessageUncheckedUpdateManyInput>
    /**
     * Filter which TeamsMessages to update
     */
    where?: TeamsMessageWhereInput
    /**
     * Limit how many TeamsMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamsMessage upsert
   */
  export type TeamsMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamsMessage to update in case it exists.
     */
    where: TeamsMessageWhereUniqueInput
    /**
     * In case the TeamsMessage found by the `where` argument doesn't exist, create a new TeamsMessage with this data.
     */
    create: XOR<TeamsMessageCreateInput, TeamsMessageUncheckedCreateInput>
    /**
     * In case the TeamsMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamsMessageUpdateInput, TeamsMessageUncheckedUpdateInput>
  }

  /**
   * TeamsMessage delete
   */
  export type TeamsMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
    /**
     * Filter which TeamsMessage to delete.
     */
    where: TeamsMessageWhereUniqueInput
  }

  /**
   * TeamsMessage deleteMany
   */
  export type TeamsMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamsMessages to delete
     */
    where?: TeamsMessageWhereInput
    /**
     * Limit how many TeamsMessages to delete.
     */
    limit?: number
  }

  /**
   * TeamsMessage.deal
   */
  export type TeamsMessage$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * TeamsMessage.contact
   */
  export type TeamsMessage$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * TeamsMessage without action
   */
  export type TeamsMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsMessage
     */
    select?: TeamsMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsMessage
     */
    omit?: TeamsMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsMessageInclude<ExtArgs> | null
  }


  /**
   * Model TeamsChannel
   */

  export type AggregateTeamsChannel = {
    _count: TeamsChannelCountAggregateOutputType | null
    _avg: TeamsChannelAvgAggregateOutputType | null
    _sum: TeamsChannelSumAggregateOutputType | null
    _min: TeamsChannelMinAggregateOutputType | null
    _max: TeamsChannelMaxAggregateOutputType | null
  }

  export type TeamsChannelAvgAggregateOutputType = {
    memberCount: number | null
  }

  export type TeamsChannelSumAggregateOutputType = {
    memberCount: number | null
  }

  export type TeamsChannelMinAggregateOutputType = {
    id: string | null
    userId: string | null
    channelId: string | null
    teamId: string | null
    name: string | null
    description: string | null
    type: string | null
    webUrl: string | null
    memberCount: number | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamsChannelMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    channelId: string | null
    teamId: string | null
    name: string | null
    description: string | null
    type: string | null
    webUrl: string | null
    memberCount: number | null
    isArchived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamsChannelCountAggregateOutputType = {
    id: number
    userId: number
    channelId: number
    teamId: number
    name: number
    description: number
    type: number
    webUrl: number
    memberCount: number
    isArchived: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamsChannelAvgAggregateInputType = {
    memberCount?: true
  }

  export type TeamsChannelSumAggregateInputType = {
    memberCount?: true
  }

  export type TeamsChannelMinAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    teamId?: true
    name?: true
    description?: true
    type?: true
    webUrl?: true
    memberCount?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamsChannelMaxAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    teamId?: true
    name?: true
    description?: true
    type?: true
    webUrl?: true
    memberCount?: true
    isArchived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamsChannelCountAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    teamId?: true
    name?: true
    description?: true
    type?: true
    webUrl?: true
    memberCount?: true
    isArchived?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamsChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamsChannel to aggregate.
     */
    where?: TeamsChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsChannels to fetch.
     */
    orderBy?: TeamsChannelOrderByWithRelationInput | TeamsChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamsChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamsChannels
    **/
    _count?: true | TeamsChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamsChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamsChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamsChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamsChannelMaxAggregateInputType
  }

  export type GetTeamsChannelAggregateType<T extends TeamsChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamsChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamsChannel[P]>
      : GetScalarType<T[P], AggregateTeamsChannel[P]>
  }




  export type TeamsChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamsChannelWhereInput
    orderBy?: TeamsChannelOrderByWithAggregationInput | TeamsChannelOrderByWithAggregationInput[]
    by: TeamsChannelScalarFieldEnum[] | TeamsChannelScalarFieldEnum
    having?: TeamsChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamsChannelCountAggregateInputType | true
    _avg?: TeamsChannelAvgAggregateInputType
    _sum?: TeamsChannelSumAggregateInputType
    _min?: TeamsChannelMinAggregateInputType
    _max?: TeamsChannelMaxAggregateInputType
  }

  export type TeamsChannelGroupByOutputType = {
    id: string
    userId: string
    channelId: string
    teamId: string
    name: string
    description: string | null
    type: string
    webUrl: string | null
    memberCount: number | null
    isArchived: boolean
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TeamsChannelCountAggregateOutputType | null
    _avg: TeamsChannelAvgAggregateOutputType | null
    _sum: TeamsChannelSumAggregateOutputType | null
    _min: TeamsChannelMinAggregateOutputType | null
    _max: TeamsChannelMaxAggregateOutputType | null
  }

  type GetTeamsChannelGroupByPayload<T extends TeamsChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamsChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamsChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamsChannelGroupByOutputType[P]>
            : GetScalarType<T[P], TeamsChannelGroupByOutputType[P]>
        }
      >
    >


  export type TeamsChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    webUrl?: boolean
    memberCount?: boolean
    isArchived?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamsChannel"]>

  export type TeamsChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    webUrl?: boolean
    memberCount?: boolean
    isArchived?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamsChannel"]>

  export type TeamsChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    webUrl?: boolean
    memberCount?: boolean
    isArchived?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamsChannel"]>

  export type TeamsChannelSelectScalar = {
    id?: boolean
    userId?: boolean
    channelId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    webUrl?: boolean
    memberCount?: boolean
    isArchived?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamsChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "channelId" | "teamId" | "name" | "description" | "type" | "webUrl" | "memberCount" | "isArchived" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["teamsChannel"]>
  export type TeamsChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamsChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamsChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamsChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamsChannel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      channelId: string
      teamId: string
      name: string
      description: string | null
      type: string
      webUrl: string | null
      memberCount: number | null
      isArchived: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamsChannel"]>
    composites: {}
  }

  type TeamsChannelGetPayload<S extends boolean | null | undefined | TeamsChannelDefaultArgs> = $Result.GetResult<Prisma.$TeamsChannelPayload, S>

  type TeamsChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamsChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamsChannelCountAggregateInputType | true
    }

  export interface TeamsChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamsChannel'], meta: { name: 'TeamsChannel' } }
    /**
     * Find zero or one TeamsChannel that matches the filter.
     * @param {TeamsChannelFindUniqueArgs} args - Arguments to find a TeamsChannel
     * @example
     * // Get one TeamsChannel
     * const teamsChannel = await prisma.teamsChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamsChannelFindUniqueArgs>(args: SelectSubset<T, TeamsChannelFindUniqueArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamsChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamsChannelFindUniqueOrThrowArgs} args - Arguments to find a TeamsChannel
     * @example
     * // Get one TeamsChannel
     * const teamsChannel = await prisma.teamsChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamsChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamsChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamsChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelFindFirstArgs} args - Arguments to find a TeamsChannel
     * @example
     * // Get one TeamsChannel
     * const teamsChannel = await prisma.teamsChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamsChannelFindFirstArgs>(args?: SelectSubset<T, TeamsChannelFindFirstArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamsChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelFindFirstOrThrowArgs} args - Arguments to find a TeamsChannel
     * @example
     * // Get one TeamsChannel
     * const teamsChannel = await prisma.teamsChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamsChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamsChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamsChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamsChannels
     * const teamsChannels = await prisma.teamsChannel.findMany()
     * 
     * // Get first 10 TeamsChannels
     * const teamsChannels = await prisma.teamsChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamsChannelWithIdOnly = await prisma.teamsChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamsChannelFindManyArgs>(args?: SelectSubset<T, TeamsChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamsChannel.
     * @param {TeamsChannelCreateArgs} args - Arguments to create a TeamsChannel.
     * @example
     * // Create one TeamsChannel
     * const TeamsChannel = await prisma.teamsChannel.create({
     *   data: {
     *     // ... data to create a TeamsChannel
     *   }
     * })
     * 
     */
    create<T extends TeamsChannelCreateArgs>(args: SelectSubset<T, TeamsChannelCreateArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamsChannels.
     * @param {TeamsChannelCreateManyArgs} args - Arguments to create many TeamsChannels.
     * @example
     * // Create many TeamsChannels
     * const teamsChannel = await prisma.teamsChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamsChannelCreateManyArgs>(args?: SelectSubset<T, TeamsChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamsChannels and returns the data saved in the database.
     * @param {TeamsChannelCreateManyAndReturnArgs} args - Arguments to create many TeamsChannels.
     * @example
     * // Create many TeamsChannels
     * const teamsChannel = await prisma.teamsChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamsChannels and only return the `id`
     * const teamsChannelWithIdOnly = await prisma.teamsChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamsChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamsChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamsChannel.
     * @param {TeamsChannelDeleteArgs} args - Arguments to delete one TeamsChannel.
     * @example
     * // Delete one TeamsChannel
     * const TeamsChannel = await prisma.teamsChannel.delete({
     *   where: {
     *     // ... filter to delete one TeamsChannel
     *   }
     * })
     * 
     */
    delete<T extends TeamsChannelDeleteArgs>(args: SelectSubset<T, TeamsChannelDeleteArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamsChannel.
     * @param {TeamsChannelUpdateArgs} args - Arguments to update one TeamsChannel.
     * @example
     * // Update one TeamsChannel
     * const teamsChannel = await prisma.teamsChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamsChannelUpdateArgs>(args: SelectSubset<T, TeamsChannelUpdateArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamsChannels.
     * @param {TeamsChannelDeleteManyArgs} args - Arguments to filter TeamsChannels to delete.
     * @example
     * // Delete a few TeamsChannels
     * const { count } = await prisma.teamsChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamsChannelDeleteManyArgs>(args?: SelectSubset<T, TeamsChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamsChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamsChannels
     * const teamsChannel = await prisma.teamsChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamsChannelUpdateManyArgs>(args: SelectSubset<T, TeamsChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamsChannels and returns the data updated in the database.
     * @param {TeamsChannelUpdateManyAndReturnArgs} args - Arguments to update many TeamsChannels.
     * @example
     * // Update many TeamsChannels
     * const teamsChannel = await prisma.teamsChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamsChannels and only return the `id`
     * const teamsChannelWithIdOnly = await prisma.teamsChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamsChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamsChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamsChannel.
     * @param {TeamsChannelUpsertArgs} args - Arguments to update or create a TeamsChannel.
     * @example
     * // Update or create a TeamsChannel
     * const teamsChannel = await prisma.teamsChannel.upsert({
     *   create: {
     *     // ... data to create a TeamsChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamsChannel we want to update
     *   }
     * })
     */
    upsert<T extends TeamsChannelUpsertArgs>(args: SelectSubset<T, TeamsChannelUpsertArgs<ExtArgs>>): Prisma__TeamsChannelClient<$Result.GetResult<Prisma.$TeamsChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamsChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelCountArgs} args - Arguments to filter TeamsChannels to count.
     * @example
     * // Count the number of TeamsChannels
     * const count = await prisma.teamsChannel.count({
     *   where: {
     *     // ... the filter for the TeamsChannels we want to count
     *   }
     * })
    **/
    count<T extends TeamsChannelCountArgs>(
      args?: Subset<T, TeamsChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamsChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamsChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamsChannelAggregateArgs>(args: Subset<T, TeamsChannelAggregateArgs>): Prisma.PrismaPromise<GetTeamsChannelAggregateType<T>>

    /**
     * Group by TeamsChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamsChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamsChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamsChannelGroupByArgs['orderBy'] }
        : { orderBy?: TeamsChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamsChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamsChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamsChannel model
   */
  readonly fields: TeamsChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamsChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamsChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamsChannel model
   */
  interface TeamsChannelFieldRefs {
    readonly id: FieldRef<"TeamsChannel", 'String'>
    readonly userId: FieldRef<"TeamsChannel", 'String'>
    readonly channelId: FieldRef<"TeamsChannel", 'String'>
    readonly teamId: FieldRef<"TeamsChannel", 'String'>
    readonly name: FieldRef<"TeamsChannel", 'String'>
    readonly description: FieldRef<"TeamsChannel", 'String'>
    readonly type: FieldRef<"TeamsChannel", 'String'>
    readonly webUrl: FieldRef<"TeamsChannel", 'String'>
    readonly memberCount: FieldRef<"TeamsChannel", 'Int'>
    readonly isArchived: FieldRef<"TeamsChannel", 'Boolean'>
    readonly metadata: FieldRef<"TeamsChannel", 'Json'>
    readonly createdAt: FieldRef<"TeamsChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamsChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamsChannel findUnique
   */
  export type TeamsChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * Filter, which TeamsChannel to fetch.
     */
    where: TeamsChannelWhereUniqueInput
  }

  /**
   * TeamsChannel findUniqueOrThrow
   */
  export type TeamsChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * Filter, which TeamsChannel to fetch.
     */
    where: TeamsChannelWhereUniqueInput
  }

  /**
   * TeamsChannel findFirst
   */
  export type TeamsChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * Filter, which TeamsChannel to fetch.
     */
    where?: TeamsChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsChannels to fetch.
     */
    orderBy?: TeamsChannelOrderByWithRelationInput | TeamsChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamsChannels.
     */
    cursor?: TeamsChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamsChannels.
     */
    distinct?: TeamsChannelScalarFieldEnum | TeamsChannelScalarFieldEnum[]
  }

  /**
   * TeamsChannel findFirstOrThrow
   */
  export type TeamsChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * Filter, which TeamsChannel to fetch.
     */
    where?: TeamsChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsChannels to fetch.
     */
    orderBy?: TeamsChannelOrderByWithRelationInput | TeamsChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamsChannels.
     */
    cursor?: TeamsChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamsChannels.
     */
    distinct?: TeamsChannelScalarFieldEnum | TeamsChannelScalarFieldEnum[]
  }

  /**
   * TeamsChannel findMany
   */
  export type TeamsChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * Filter, which TeamsChannels to fetch.
     */
    where?: TeamsChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamsChannels to fetch.
     */
    orderBy?: TeamsChannelOrderByWithRelationInput | TeamsChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamsChannels.
     */
    cursor?: TeamsChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamsChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamsChannels.
     */
    skip?: number
    distinct?: TeamsChannelScalarFieldEnum | TeamsChannelScalarFieldEnum[]
  }

  /**
   * TeamsChannel create
   */
  export type TeamsChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamsChannel.
     */
    data: XOR<TeamsChannelCreateInput, TeamsChannelUncheckedCreateInput>
  }

  /**
   * TeamsChannel createMany
   */
  export type TeamsChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamsChannels.
     */
    data: TeamsChannelCreateManyInput | TeamsChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamsChannel createManyAndReturn
   */
  export type TeamsChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * The data used to create many TeamsChannels.
     */
    data: TeamsChannelCreateManyInput | TeamsChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamsChannel update
   */
  export type TeamsChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamsChannel.
     */
    data: XOR<TeamsChannelUpdateInput, TeamsChannelUncheckedUpdateInput>
    /**
     * Choose, which TeamsChannel to update.
     */
    where: TeamsChannelWhereUniqueInput
  }

  /**
   * TeamsChannel updateMany
   */
  export type TeamsChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamsChannels.
     */
    data: XOR<TeamsChannelUpdateManyMutationInput, TeamsChannelUncheckedUpdateManyInput>
    /**
     * Filter which TeamsChannels to update
     */
    where?: TeamsChannelWhereInput
    /**
     * Limit how many TeamsChannels to update.
     */
    limit?: number
  }

  /**
   * TeamsChannel updateManyAndReturn
   */
  export type TeamsChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * The data used to update TeamsChannels.
     */
    data: XOR<TeamsChannelUpdateManyMutationInput, TeamsChannelUncheckedUpdateManyInput>
    /**
     * Filter which TeamsChannels to update
     */
    where?: TeamsChannelWhereInput
    /**
     * Limit how many TeamsChannels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamsChannel upsert
   */
  export type TeamsChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamsChannel to update in case it exists.
     */
    where: TeamsChannelWhereUniqueInput
    /**
     * In case the TeamsChannel found by the `where` argument doesn't exist, create a new TeamsChannel with this data.
     */
    create: XOR<TeamsChannelCreateInput, TeamsChannelUncheckedCreateInput>
    /**
     * In case the TeamsChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamsChannelUpdateInput, TeamsChannelUncheckedUpdateInput>
  }

  /**
   * TeamsChannel delete
   */
  export type TeamsChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
    /**
     * Filter which TeamsChannel to delete.
     */
    where: TeamsChannelWhereUniqueInput
  }

  /**
   * TeamsChannel deleteMany
   */
  export type TeamsChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamsChannels to delete
     */
    where?: TeamsChannelWhereInput
    /**
     * Limit how many TeamsChannels to delete.
     */
    limit?: number
  }

  /**
   * TeamsChannel without action
   */
  export type TeamsChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamsChannel
     */
    select?: TeamsChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamsChannel
     */
    omit?: TeamsChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamsChannelInclude<ExtArgs> | null
  }


  /**
   * Model SlackMessage
   */

  export type AggregateSlackMessage = {
    _count: SlackMessageCountAggregateOutputType | null
    _min: SlackMessageMinAggregateOutputType | null
    _max: SlackMessageMaxAggregateOutputType | null
  }

  export type SlackMessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    messageId: string | null
    channelId: string | null
    channelName: string | null
    fromUserId: string | null
    fromName: string | null
    text: string | null
    messageType: string | null
    threadTs: string | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlackMessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    contactId: string | null
    messageId: string | null
    channelId: string | null
    channelName: string | null
    fromUserId: string | null
    fromName: string | null
    text: string | null
    messageType: string | null
    threadTs: string | null
    sentAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlackMessageCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    contactId: number
    messageId: number
    channelId: number
    channelName: number
    fromUserId: number
    fromName: number
    text: number
    messageType: number
    threadTs: number
    attachments: number
    reactions: number
    mentions: number
    sentAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlackMessageMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    messageId?: true
    channelId?: true
    channelName?: true
    fromUserId?: true
    fromName?: true
    text?: true
    messageType?: true
    threadTs?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlackMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    messageId?: true
    channelId?: true
    channelName?: true
    fromUserId?: true
    fromName?: true
    text?: true
    messageType?: true
    threadTs?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlackMessageCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    contactId?: true
    messageId?: true
    channelId?: true
    channelName?: true
    fromUserId?: true
    fromName?: true
    text?: true
    messageType?: true
    threadTs?: true
    attachments?: true
    reactions?: true
    mentions?: true
    sentAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlackMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlackMessage to aggregate.
     */
    where?: SlackMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackMessages to fetch.
     */
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlackMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SlackMessages
    **/
    _count?: true | SlackMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlackMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlackMessageMaxAggregateInputType
  }

  export type GetSlackMessageAggregateType<T extends SlackMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSlackMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlackMessage[P]>
      : GetScalarType<T[P], AggregateSlackMessage[P]>
  }




  export type SlackMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlackMessageWhereInput
    orderBy?: SlackMessageOrderByWithAggregationInput | SlackMessageOrderByWithAggregationInput[]
    by: SlackMessageScalarFieldEnum[] | SlackMessageScalarFieldEnum
    having?: SlackMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlackMessageCountAggregateInputType | true
    _min?: SlackMessageMinAggregateInputType
    _max?: SlackMessageMaxAggregateInputType
  }

  export type SlackMessageGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    contactId: string | null
    messageId: string
    channelId: string
    channelName: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType: string
    threadTs: string | null
    attachments: JsonValue | null
    reactions: JsonValue | null
    mentions: string[]
    sentAt: Date
    createdAt: Date
    updatedAt: Date
    _count: SlackMessageCountAggregateOutputType | null
    _min: SlackMessageMinAggregateOutputType | null
    _max: SlackMessageMaxAggregateOutputType | null
  }

  type GetSlackMessageGroupByPayload<T extends SlackMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlackMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlackMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlackMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SlackMessageGroupByOutputType[P]>
        }
      >
    >


  export type SlackMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    channelId?: boolean
    channelName?: boolean
    fromUserId?: boolean
    fromName?: boolean
    text?: boolean
    messageType?: boolean
    threadTs?: boolean
    attachments?: boolean
    reactions?: boolean
    mentions?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SlackMessage$dealArgs<ExtArgs>
    contact?: boolean | SlackMessage$contactArgs<ExtArgs>
  }, ExtArgs["result"]["slackMessage"]>

  export type SlackMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    channelId?: boolean
    channelName?: boolean
    fromUserId?: boolean
    fromName?: boolean
    text?: boolean
    messageType?: boolean
    threadTs?: boolean
    attachments?: boolean
    reactions?: boolean
    mentions?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SlackMessage$dealArgs<ExtArgs>
    contact?: boolean | SlackMessage$contactArgs<ExtArgs>
  }, ExtArgs["result"]["slackMessage"]>

  export type SlackMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    channelId?: boolean
    channelName?: boolean
    fromUserId?: boolean
    fromName?: boolean
    text?: boolean
    messageType?: boolean
    threadTs?: boolean
    attachments?: boolean
    reactions?: boolean
    mentions?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SlackMessage$dealArgs<ExtArgs>
    contact?: boolean | SlackMessage$contactArgs<ExtArgs>
  }, ExtArgs["result"]["slackMessage"]>

  export type SlackMessageSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    contactId?: boolean
    messageId?: boolean
    channelId?: boolean
    channelName?: boolean
    fromUserId?: boolean
    fromName?: boolean
    text?: boolean
    messageType?: boolean
    threadTs?: boolean
    attachments?: boolean
    reactions?: boolean
    mentions?: boolean
    sentAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SlackMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "contactId" | "messageId" | "channelId" | "channelName" | "fromUserId" | "fromName" | "text" | "messageType" | "threadTs" | "attachments" | "reactions" | "mentions" | "sentAt" | "createdAt" | "updatedAt", ExtArgs["result"]["slackMessage"]>
  export type SlackMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SlackMessage$dealArgs<ExtArgs>
    contact?: boolean | SlackMessage$contactArgs<ExtArgs>
  }
  export type SlackMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SlackMessage$dealArgs<ExtArgs>
    contact?: boolean | SlackMessage$contactArgs<ExtArgs>
  }
  export type SlackMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SlackMessage$dealArgs<ExtArgs>
    contact?: boolean | SlackMessage$contactArgs<ExtArgs>
  }

  export type $SlackMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SlackMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      contactId: string | null
      messageId: string
      channelId: string
      channelName: string | null
      fromUserId: string
      fromName: string
      text: string
      messageType: string
      threadTs: string | null
      attachments: Prisma.JsonValue | null
      reactions: Prisma.JsonValue | null
      mentions: string[]
      sentAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["slackMessage"]>
    composites: {}
  }

  type SlackMessageGetPayload<S extends boolean | null | undefined | SlackMessageDefaultArgs> = $Result.GetResult<Prisma.$SlackMessagePayload, S>

  type SlackMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlackMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlackMessageCountAggregateInputType | true
    }

  export interface SlackMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SlackMessage'], meta: { name: 'SlackMessage' } }
    /**
     * Find zero or one SlackMessage that matches the filter.
     * @param {SlackMessageFindUniqueArgs} args - Arguments to find a SlackMessage
     * @example
     * // Get one SlackMessage
     * const slackMessage = await prisma.slackMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlackMessageFindUniqueArgs>(args: SelectSubset<T, SlackMessageFindUniqueArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SlackMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlackMessageFindUniqueOrThrowArgs} args - Arguments to find a SlackMessage
     * @example
     * // Get one SlackMessage
     * const slackMessage = await prisma.slackMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlackMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SlackMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlackMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageFindFirstArgs} args - Arguments to find a SlackMessage
     * @example
     * // Get one SlackMessage
     * const slackMessage = await prisma.slackMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlackMessageFindFirstArgs>(args?: SelectSubset<T, SlackMessageFindFirstArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlackMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageFindFirstOrThrowArgs} args - Arguments to find a SlackMessage
     * @example
     * // Get one SlackMessage
     * const slackMessage = await prisma.slackMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlackMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SlackMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SlackMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SlackMessages
     * const slackMessages = await prisma.slackMessage.findMany()
     * 
     * // Get first 10 SlackMessages
     * const slackMessages = await prisma.slackMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slackMessageWithIdOnly = await prisma.slackMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlackMessageFindManyArgs>(args?: SelectSubset<T, SlackMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SlackMessage.
     * @param {SlackMessageCreateArgs} args - Arguments to create a SlackMessage.
     * @example
     * // Create one SlackMessage
     * const SlackMessage = await prisma.slackMessage.create({
     *   data: {
     *     // ... data to create a SlackMessage
     *   }
     * })
     * 
     */
    create<T extends SlackMessageCreateArgs>(args: SelectSubset<T, SlackMessageCreateArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SlackMessages.
     * @param {SlackMessageCreateManyArgs} args - Arguments to create many SlackMessages.
     * @example
     * // Create many SlackMessages
     * const slackMessage = await prisma.slackMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlackMessageCreateManyArgs>(args?: SelectSubset<T, SlackMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SlackMessages and returns the data saved in the database.
     * @param {SlackMessageCreateManyAndReturnArgs} args - Arguments to create many SlackMessages.
     * @example
     * // Create many SlackMessages
     * const slackMessage = await prisma.slackMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SlackMessages and only return the `id`
     * const slackMessageWithIdOnly = await prisma.slackMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlackMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, SlackMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SlackMessage.
     * @param {SlackMessageDeleteArgs} args - Arguments to delete one SlackMessage.
     * @example
     * // Delete one SlackMessage
     * const SlackMessage = await prisma.slackMessage.delete({
     *   where: {
     *     // ... filter to delete one SlackMessage
     *   }
     * })
     * 
     */
    delete<T extends SlackMessageDeleteArgs>(args: SelectSubset<T, SlackMessageDeleteArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SlackMessage.
     * @param {SlackMessageUpdateArgs} args - Arguments to update one SlackMessage.
     * @example
     * // Update one SlackMessage
     * const slackMessage = await prisma.slackMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlackMessageUpdateArgs>(args: SelectSubset<T, SlackMessageUpdateArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SlackMessages.
     * @param {SlackMessageDeleteManyArgs} args - Arguments to filter SlackMessages to delete.
     * @example
     * // Delete a few SlackMessages
     * const { count } = await prisma.slackMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlackMessageDeleteManyArgs>(args?: SelectSubset<T, SlackMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlackMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SlackMessages
     * const slackMessage = await prisma.slackMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlackMessageUpdateManyArgs>(args: SelectSubset<T, SlackMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlackMessages and returns the data updated in the database.
     * @param {SlackMessageUpdateManyAndReturnArgs} args - Arguments to update many SlackMessages.
     * @example
     * // Update many SlackMessages
     * const slackMessage = await prisma.slackMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SlackMessages and only return the `id`
     * const slackMessageWithIdOnly = await prisma.slackMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlackMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, SlackMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SlackMessage.
     * @param {SlackMessageUpsertArgs} args - Arguments to update or create a SlackMessage.
     * @example
     * // Update or create a SlackMessage
     * const slackMessage = await prisma.slackMessage.upsert({
     *   create: {
     *     // ... data to create a SlackMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SlackMessage we want to update
     *   }
     * })
     */
    upsert<T extends SlackMessageUpsertArgs>(args: SelectSubset<T, SlackMessageUpsertArgs<ExtArgs>>): Prisma__SlackMessageClient<$Result.GetResult<Prisma.$SlackMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SlackMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageCountArgs} args - Arguments to filter SlackMessages to count.
     * @example
     * // Count the number of SlackMessages
     * const count = await prisma.slackMessage.count({
     *   where: {
     *     // ... the filter for the SlackMessages we want to count
     *   }
     * })
    **/
    count<T extends SlackMessageCountArgs>(
      args?: Subset<T, SlackMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlackMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SlackMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlackMessageAggregateArgs>(args: Subset<T, SlackMessageAggregateArgs>): Prisma.PrismaPromise<GetSlackMessageAggregateType<T>>

    /**
     * Group by SlackMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlackMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlackMessageGroupByArgs['orderBy'] }
        : { orderBy?: SlackMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlackMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlackMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SlackMessage model
   */
  readonly fields: SlackMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SlackMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlackMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends SlackMessage$dealArgs<ExtArgs> = {}>(args?: Subset<T, SlackMessage$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends SlackMessage$contactArgs<ExtArgs> = {}>(args?: Subset<T, SlackMessage$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SlackMessage model
   */
  interface SlackMessageFieldRefs {
    readonly id: FieldRef<"SlackMessage", 'String'>
    readonly userId: FieldRef<"SlackMessage", 'String'>
    readonly dealId: FieldRef<"SlackMessage", 'String'>
    readonly contactId: FieldRef<"SlackMessage", 'String'>
    readonly messageId: FieldRef<"SlackMessage", 'String'>
    readonly channelId: FieldRef<"SlackMessage", 'String'>
    readonly channelName: FieldRef<"SlackMessage", 'String'>
    readonly fromUserId: FieldRef<"SlackMessage", 'String'>
    readonly fromName: FieldRef<"SlackMessage", 'String'>
    readonly text: FieldRef<"SlackMessage", 'String'>
    readonly messageType: FieldRef<"SlackMessage", 'String'>
    readonly threadTs: FieldRef<"SlackMessage", 'String'>
    readonly attachments: FieldRef<"SlackMessage", 'Json'>
    readonly reactions: FieldRef<"SlackMessage", 'Json'>
    readonly mentions: FieldRef<"SlackMessage", 'String[]'>
    readonly sentAt: FieldRef<"SlackMessage", 'DateTime'>
    readonly createdAt: FieldRef<"SlackMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"SlackMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SlackMessage findUnique
   */
  export type SlackMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * Filter, which SlackMessage to fetch.
     */
    where: SlackMessageWhereUniqueInput
  }

  /**
   * SlackMessage findUniqueOrThrow
   */
  export type SlackMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * Filter, which SlackMessage to fetch.
     */
    where: SlackMessageWhereUniqueInput
  }

  /**
   * SlackMessage findFirst
   */
  export type SlackMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * Filter, which SlackMessage to fetch.
     */
    where?: SlackMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackMessages to fetch.
     */
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlackMessages.
     */
    cursor?: SlackMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlackMessages.
     */
    distinct?: SlackMessageScalarFieldEnum | SlackMessageScalarFieldEnum[]
  }

  /**
   * SlackMessage findFirstOrThrow
   */
  export type SlackMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * Filter, which SlackMessage to fetch.
     */
    where?: SlackMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackMessages to fetch.
     */
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlackMessages.
     */
    cursor?: SlackMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlackMessages.
     */
    distinct?: SlackMessageScalarFieldEnum | SlackMessageScalarFieldEnum[]
  }

  /**
   * SlackMessage findMany
   */
  export type SlackMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * Filter, which SlackMessages to fetch.
     */
    where?: SlackMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackMessages to fetch.
     */
    orderBy?: SlackMessageOrderByWithRelationInput | SlackMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SlackMessages.
     */
    cursor?: SlackMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackMessages.
     */
    skip?: number
    distinct?: SlackMessageScalarFieldEnum | SlackMessageScalarFieldEnum[]
  }

  /**
   * SlackMessage create
   */
  export type SlackMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SlackMessage.
     */
    data: XOR<SlackMessageCreateInput, SlackMessageUncheckedCreateInput>
  }

  /**
   * SlackMessage createMany
   */
  export type SlackMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SlackMessages.
     */
    data: SlackMessageCreateManyInput | SlackMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SlackMessage createManyAndReturn
   */
  export type SlackMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * The data used to create many SlackMessages.
     */
    data: SlackMessageCreateManyInput | SlackMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SlackMessage update
   */
  export type SlackMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SlackMessage.
     */
    data: XOR<SlackMessageUpdateInput, SlackMessageUncheckedUpdateInput>
    /**
     * Choose, which SlackMessage to update.
     */
    where: SlackMessageWhereUniqueInput
  }

  /**
   * SlackMessage updateMany
   */
  export type SlackMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SlackMessages.
     */
    data: XOR<SlackMessageUpdateManyMutationInput, SlackMessageUncheckedUpdateManyInput>
    /**
     * Filter which SlackMessages to update
     */
    where?: SlackMessageWhereInput
    /**
     * Limit how many SlackMessages to update.
     */
    limit?: number
  }

  /**
   * SlackMessage updateManyAndReturn
   */
  export type SlackMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * The data used to update SlackMessages.
     */
    data: XOR<SlackMessageUpdateManyMutationInput, SlackMessageUncheckedUpdateManyInput>
    /**
     * Filter which SlackMessages to update
     */
    where?: SlackMessageWhereInput
    /**
     * Limit how many SlackMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SlackMessage upsert
   */
  export type SlackMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SlackMessage to update in case it exists.
     */
    where: SlackMessageWhereUniqueInput
    /**
     * In case the SlackMessage found by the `where` argument doesn't exist, create a new SlackMessage with this data.
     */
    create: XOR<SlackMessageCreateInput, SlackMessageUncheckedCreateInput>
    /**
     * In case the SlackMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlackMessageUpdateInput, SlackMessageUncheckedUpdateInput>
  }

  /**
   * SlackMessage delete
   */
  export type SlackMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
    /**
     * Filter which SlackMessage to delete.
     */
    where: SlackMessageWhereUniqueInput
  }

  /**
   * SlackMessage deleteMany
   */
  export type SlackMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlackMessages to delete
     */
    where?: SlackMessageWhereInput
    /**
     * Limit how many SlackMessages to delete.
     */
    limit?: number
  }

  /**
   * SlackMessage.deal
   */
  export type SlackMessage$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * SlackMessage.contact
   */
  export type SlackMessage$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * SlackMessage without action
   */
  export type SlackMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackMessage
     */
    select?: SlackMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackMessage
     */
    omit?: SlackMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackMessageInclude<ExtArgs> | null
  }


  /**
   * Model SlackChannel
   */

  export type AggregateSlackChannel = {
    _count: SlackChannelCountAggregateOutputType | null
    _avg: SlackChannelAvgAggregateOutputType | null
    _sum: SlackChannelSumAggregateOutputType | null
    _min: SlackChannelMinAggregateOutputType | null
    _max: SlackChannelMaxAggregateOutputType | null
  }

  export type SlackChannelAvgAggregateOutputType = {
    memberCount: number | null
  }

  export type SlackChannelSumAggregateOutputType = {
    memberCount: number | null
  }

  export type SlackChannelMinAggregateOutputType = {
    id: string | null
    userId: string | null
    channelId: string | null
    name: string | null
    purpose: string | null
    topic: string | null
    isPrivate: boolean | null
    isArchived: boolean | null
    memberCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlackChannelMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    channelId: string | null
    name: string | null
    purpose: string | null
    topic: string | null
    isPrivate: boolean | null
    isArchived: boolean | null
    memberCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlackChannelCountAggregateOutputType = {
    id: number
    userId: number
    channelId: number
    name: number
    purpose: number
    topic: number
    isPrivate: number
    isArchived: number
    memberCount: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlackChannelAvgAggregateInputType = {
    memberCount?: true
  }

  export type SlackChannelSumAggregateInputType = {
    memberCount?: true
  }

  export type SlackChannelMinAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    name?: true
    purpose?: true
    topic?: true
    isPrivate?: true
    isArchived?: true
    memberCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlackChannelMaxAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    name?: true
    purpose?: true
    topic?: true
    isPrivate?: true
    isArchived?: true
    memberCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlackChannelCountAggregateInputType = {
    id?: true
    userId?: true
    channelId?: true
    name?: true
    purpose?: true
    topic?: true
    isPrivate?: true
    isArchived?: true
    memberCount?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlackChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlackChannel to aggregate.
     */
    where?: SlackChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackChannels to fetch.
     */
    orderBy?: SlackChannelOrderByWithRelationInput | SlackChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlackChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SlackChannels
    **/
    _count?: true | SlackChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlackChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlackChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlackChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlackChannelMaxAggregateInputType
  }

  export type GetSlackChannelAggregateType<T extends SlackChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateSlackChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlackChannel[P]>
      : GetScalarType<T[P], AggregateSlackChannel[P]>
  }




  export type SlackChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlackChannelWhereInput
    orderBy?: SlackChannelOrderByWithAggregationInput | SlackChannelOrderByWithAggregationInput[]
    by: SlackChannelScalarFieldEnum[] | SlackChannelScalarFieldEnum
    having?: SlackChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlackChannelCountAggregateInputType | true
    _avg?: SlackChannelAvgAggregateInputType
    _sum?: SlackChannelSumAggregateInputType
    _min?: SlackChannelMinAggregateInputType
    _max?: SlackChannelMaxAggregateInputType
  }

  export type SlackChannelGroupByOutputType = {
    id: string
    userId: string
    channelId: string
    name: string
    purpose: string | null
    topic: string | null
    isPrivate: boolean
    isArchived: boolean
    memberCount: number | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SlackChannelCountAggregateOutputType | null
    _avg: SlackChannelAvgAggregateOutputType | null
    _sum: SlackChannelSumAggregateOutputType | null
    _min: SlackChannelMinAggregateOutputType | null
    _max: SlackChannelMaxAggregateOutputType | null
  }

  type GetSlackChannelGroupByPayload<T extends SlackChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlackChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlackChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlackChannelGroupByOutputType[P]>
            : GetScalarType<T[P], SlackChannelGroupByOutputType[P]>
        }
      >
    >


  export type SlackChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    name?: boolean
    purpose?: boolean
    topic?: boolean
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slackChannel"]>

  export type SlackChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    name?: boolean
    purpose?: boolean
    topic?: boolean
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slackChannel"]>

  export type SlackChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    channelId?: boolean
    name?: boolean
    purpose?: boolean
    topic?: boolean
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["slackChannel"]>

  export type SlackChannelSelectScalar = {
    id?: boolean
    userId?: boolean
    channelId?: boolean
    name?: boolean
    purpose?: boolean
    topic?: boolean
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SlackChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "channelId" | "name" | "purpose" | "topic" | "isPrivate" | "isArchived" | "memberCount" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["slackChannel"]>
  export type SlackChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SlackChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SlackChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SlackChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SlackChannel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      channelId: string
      name: string
      purpose: string | null
      topic: string | null
      isPrivate: boolean
      isArchived: boolean
      memberCount: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["slackChannel"]>
    composites: {}
  }

  type SlackChannelGetPayload<S extends boolean | null | undefined | SlackChannelDefaultArgs> = $Result.GetResult<Prisma.$SlackChannelPayload, S>

  type SlackChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SlackChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SlackChannelCountAggregateInputType | true
    }

  export interface SlackChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SlackChannel'], meta: { name: 'SlackChannel' } }
    /**
     * Find zero or one SlackChannel that matches the filter.
     * @param {SlackChannelFindUniqueArgs} args - Arguments to find a SlackChannel
     * @example
     * // Get one SlackChannel
     * const slackChannel = await prisma.slackChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlackChannelFindUniqueArgs>(args: SelectSubset<T, SlackChannelFindUniqueArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SlackChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SlackChannelFindUniqueOrThrowArgs} args - Arguments to find a SlackChannel
     * @example
     * // Get one SlackChannel
     * const slackChannel = await prisma.slackChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlackChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, SlackChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlackChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelFindFirstArgs} args - Arguments to find a SlackChannel
     * @example
     * // Get one SlackChannel
     * const slackChannel = await prisma.slackChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlackChannelFindFirstArgs>(args?: SelectSubset<T, SlackChannelFindFirstArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SlackChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelFindFirstOrThrowArgs} args - Arguments to find a SlackChannel
     * @example
     * // Get one SlackChannel
     * const slackChannel = await prisma.slackChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlackChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, SlackChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SlackChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SlackChannels
     * const slackChannels = await prisma.slackChannel.findMany()
     * 
     * // Get first 10 SlackChannels
     * const slackChannels = await prisma.slackChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slackChannelWithIdOnly = await prisma.slackChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlackChannelFindManyArgs>(args?: SelectSubset<T, SlackChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SlackChannel.
     * @param {SlackChannelCreateArgs} args - Arguments to create a SlackChannel.
     * @example
     * // Create one SlackChannel
     * const SlackChannel = await prisma.slackChannel.create({
     *   data: {
     *     // ... data to create a SlackChannel
     *   }
     * })
     * 
     */
    create<T extends SlackChannelCreateArgs>(args: SelectSubset<T, SlackChannelCreateArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SlackChannels.
     * @param {SlackChannelCreateManyArgs} args - Arguments to create many SlackChannels.
     * @example
     * // Create many SlackChannels
     * const slackChannel = await prisma.slackChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlackChannelCreateManyArgs>(args?: SelectSubset<T, SlackChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SlackChannels and returns the data saved in the database.
     * @param {SlackChannelCreateManyAndReturnArgs} args - Arguments to create many SlackChannels.
     * @example
     * // Create many SlackChannels
     * const slackChannel = await prisma.slackChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SlackChannels and only return the `id`
     * const slackChannelWithIdOnly = await prisma.slackChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SlackChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, SlackChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SlackChannel.
     * @param {SlackChannelDeleteArgs} args - Arguments to delete one SlackChannel.
     * @example
     * // Delete one SlackChannel
     * const SlackChannel = await prisma.slackChannel.delete({
     *   where: {
     *     // ... filter to delete one SlackChannel
     *   }
     * })
     * 
     */
    delete<T extends SlackChannelDeleteArgs>(args: SelectSubset<T, SlackChannelDeleteArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SlackChannel.
     * @param {SlackChannelUpdateArgs} args - Arguments to update one SlackChannel.
     * @example
     * // Update one SlackChannel
     * const slackChannel = await prisma.slackChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlackChannelUpdateArgs>(args: SelectSubset<T, SlackChannelUpdateArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SlackChannels.
     * @param {SlackChannelDeleteManyArgs} args - Arguments to filter SlackChannels to delete.
     * @example
     * // Delete a few SlackChannels
     * const { count } = await prisma.slackChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlackChannelDeleteManyArgs>(args?: SelectSubset<T, SlackChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlackChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SlackChannels
     * const slackChannel = await prisma.slackChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlackChannelUpdateManyArgs>(args: SelectSubset<T, SlackChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlackChannels and returns the data updated in the database.
     * @param {SlackChannelUpdateManyAndReturnArgs} args - Arguments to update many SlackChannels.
     * @example
     * // Update many SlackChannels
     * const slackChannel = await prisma.slackChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SlackChannels and only return the `id`
     * const slackChannelWithIdOnly = await prisma.slackChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SlackChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, SlackChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SlackChannel.
     * @param {SlackChannelUpsertArgs} args - Arguments to update or create a SlackChannel.
     * @example
     * // Update or create a SlackChannel
     * const slackChannel = await prisma.slackChannel.upsert({
     *   create: {
     *     // ... data to create a SlackChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SlackChannel we want to update
     *   }
     * })
     */
    upsert<T extends SlackChannelUpsertArgs>(args: SelectSubset<T, SlackChannelUpsertArgs<ExtArgs>>): Prisma__SlackChannelClient<$Result.GetResult<Prisma.$SlackChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SlackChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelCountArgs} args - Arguments to filter SlackChannels to count.
     * @example
     * // Count the number of SlackChannels
     * const count = await prisma.slackChannel.count({
     *   where: {
     *     // ... the filter for the SlackChannels we want to count
     *   }
     * })
    **/
    count<T extends SlackChannelCountArgs>(
      args?: Subset<T, SlackChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlackChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SlackChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlackChannelAggregateArgs>(args: Subset<T, SlackChannelAggregateArgs>): Prisma.PrismaPromise<GetSlackChannelAggregateType<T>>

    /**
     * Group by SlackChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlackChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlackChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlackChannelGroupByArgs['orderBy'] }
        : { orderBy?: SlackChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlackChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlackChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SlackChannel model
   */
  readonly fields: SlackChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SlackChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlackChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SlackChannel model
   */
  interface SlackChannelFieldRefs {
    readonly id: FieldRef<"SlackChannel", 'String'>
    readonly userId: FieldRef<"SlackChannel", 'String'>
    readonly channelId: FieldRef<"SlackChannel", 'String'>
    readonly name: FieldRef<"SlackChannel", 'String'>
    readonly purpose: FieldRef<"SlackChannel", 'String'>
    readonly topic: FieldRef<"SlackChannel", 'String'>
    readonly isPrivate: FieldRef<"SlackChannel", 'Boolean'>
    readonly isArchived: FieldRef<"SlackChannel", 'Boolean'>
    readonly memberCount: FieldRef<"SlackChannel", 'Int'>
    readonly metadata: FieldRef<"SlackChannel", 'Json'>
    readonly createdAt: FieldRef<"SlackChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"SlackChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SlackChannel findUnique
   */
  export type SlackChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * Filter, which SlackChannel to fetch.
     */
    where: SlackChannelWhereUniqueInput
  }

  /**
   * SlackChannel findUniqueOrThrow
   */
  export type SlackChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * Filter, which SlackChannel to fetch.
     */
    where: SlackChannelWhereUniqueInput
  }

  /**
   * SlackChannel findFirst
   */
  export type SlackChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * Filter, which SlackChannel to fetch.
     */
    where?: SlackChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackChannels to fetch.
     */
    orderBy?: SlackChannelOrderByWithRelationInput | SlackChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlackChannels.
     */
    cursor?: SlackChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlackChannels.
     */
    distinct?: SlackChannelScalarFieldEnum | SlackChannelScalarFieldEnum[]
  }

  /**
   * SlackChannel findFirstOrThrow
   */
  export type SlackChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * Filter, which SlackChannel to fetch.
     */
    where?: SlackChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackChannels to fetch.
     */
    orderBy?: SlackChannelOrderByWithRelationInput | SlackChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlackChannels.
     */
    cursor?: SlackChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlackChannels.
     */
    distinct?: SlackChannelScalarFieldEnum | SlackChannelScalarFieldEnum[]
  }

  /**
   * SlackChannel findMany
   */
  export type SlackChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * Filter, which SlackChannels to fetch.
     */
    where?: SlackChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlackChannels to fetch.
     */
    orderBy?: SlackChannelOrderByWithRelationInput | SlackChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SlackChannels.
     */
    cursor?: SlackChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlackChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlackChannels.
     */
    skip?: number
    distinct?: SlackChannelScalarFieldEnum | SlackChannelScalarFieldEnum[]
  }

  /**
   * SlackChannel create
   */
  export type SlackChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a SlackChannel.
     */
    data: XOR<SlackChannelCreateInput, SlackChannelUncheckedCreateInput>
  }

  /**
   * SlackChannel createMany
   */
  export type SlackChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SlackChannels.
     */
    data: SlackChannelCreateManyInput | SlackChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SlackChannel createManyAndReturn
   */
  export type SlackChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * The data used to create many SlackChannels.
     */
    data: SlackChannelCreateManyInput | SlackChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SlackChannel update
   */
  export type SlackChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a SlackChannel.
     */
    data: XOR<SlackChannelUpdateInput, SlackChannelUncheckedUpdateInput>
    /**
     * Choose, which SlackChannel to update.
     */
    where: SlackChannelWhereUniqueInput
  }

  /**
   * SlackChannel updateMany
   */
  export type SlackChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SlackChannels.
     */
    data: XOR<SlackChannelUpdateManyMutationInput, SlackChannelUncheckedUpdateManyInput>
    /**
     * Filter which SlackChannels to update
     */
    where?: SlackChannelWhereInput
    /**
     * Limit how many SlackChannels to update.
     */
    limit?: number
  }

  /**
   * SlackChannel updateManyAndReturn
   */
  export type SlackChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * The data used to update SlackChannels.
     */
    data: XOR<SlackChannelUpdateManyMutationInput, SlackChannelUncheckedUpdateManyInput>
    /**
     * Filter which SlackChannels to update
     */
    where?: SlackChannelWhereInput
    /**
     * Limit how many SlackChannels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SlackChannel upsert
   */
  export type SlackChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the SlackChannel to update in case it exists.
     */
    where: SlackChannelWhereUniqueInput
    /**
     * In case the SlackChannel found by the `where` argument doesn't exist, create a new SlackChannel with this data.
     */
    create: XOR<SlackChannelCreateInput, SlackChannelUncheckedCreateInput>
    /**
     * In case the SlackChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlackChannelUpdateInput, SlackChannelUncheckedUpdateInput>
  }

  /**
   * SlackChannel delete
   */
  export type SlackChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
    /**
     * Filter which SlackChannel to delete.
     */
    where: SlackChannelWhereUniqueInput
  }

  /**
   * SlackChannel deleteMany
   */
  export type SlackChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlackChannels to delete
     */
    where?: SlackChannelWhereInput
    /**
     * Limit how many SlackChannels to delete.
     */
    limit?: number
  }

  /**
   * SlackChannel without action
   */
  export type SlackChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlackChannel
     */
    select?: SlackChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SlackChannel
     */
    omit?: SlackChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SlackChannelInclude<ExtArgs> | null
  }


  /**
   * Model ZoomMeeting
   */

  export type AggregateZoomMeeting = {
    _count: ZoomMeetingCountAggregateOutputType | null
    _avg: ZoomMeetingAvgAggregateOutputType | null
    _sum: ZoomMeetingSumAggregateOutputType | null
    _min: ZoomMeetingMinAggregateOutputType | null
    _max: ZoomMeetingMaxAggregateOutputType | null
  }

  export type ZoomMeetingAvgAggregateOutputType = {
    duration: number | null
    participantCount: number | null
  }

  export type ZoomMeetingSumAggregateOutputType = {
    duration: number | null
    participantCount: number | null
  }

  export type ZoomMeetingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    meetingId: string | null
    uuid: string | null
    topic: string | null
    agenda: string | null
    startTime: Date | null
    duration: number | null
    timezone: string | null
    status: string | null
    meetingType: string | null
    joinUrl: string | null
    startUrl: string | null
    password: string | null
    hostEmail: string | null
    participantCount: number | null
    hasRecording: boolean | null
    recordingUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoomMeetingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    meetingId: string | null
    uuid: string | null
    topic: string | null
    agenda: string | null
    startTime: Date | null
    duration: number | null
    timezone: string | null
    status: string | null
    meetingType: string | null
    joinUrl: string | null
    startUrl: string | null
    password: string | null
    hostEmail: string | null
    participantCount: number | null
    hasRecording: boolean | null
    recordingUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoomMeetingCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    meetingId: number
    uuid: number
    topic: number
    agenda: number
    startTime: number
    duration: number
    timezone: number
    status: number
    meetingType: number
    joinUrl: number
    startUrl: number
    password: number
    hostEmail: number
    participantCount: number
    hasRecording: number
    recordingUrl: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoomMeetingAvgAggregateInputType = {
    duration?: true
    participantCount?: true
  }

  export type ZoomMeetingSumAggregateInputType = {
    duration?: true
    participantCount?: true
  }

  export type ZoomMeetingMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    meetingId?: true
    uuid?: true
    topic?: true
    agenda?: true
    startTime?: true
    duration?: true
    timezone?: true
    status?: true
    meetingType?: true
    joinUrl?: true
    startUrl?: true
    password?: true
    hostEmail?: true
    participantCount?: true
    hasRecording?: true
    recordingUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoomMeetingMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    meetingId?: true
    uuid?: true
    topic?: true
    agenda?: true
    startTime?: true
    duration?: true
    timezone?: true
    status?: true
    meetingType?: true
    joinUrl?: true
    startUrl?: true
    password?: true
    hostEmail?: true
    participantCount?: true
    hasRecording?: true
    recordingUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoomMeetingCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    meetingId?: true
    uuid?: true
    topic?: true
    agenda?: true
    startTime?: true
    duration?: true
    timezone?: true
    status?: true
    meetingType?: true
    joinUrl?: true
    startUrl?: true
    password?: true
    hostEmail?: true
    participantCount?: true
    hasRecording?: true
    recordingUrl?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoomMeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoomMeeting to aggregate.
     */
    where?: ZoomMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomMeetings to fetch.
     */
    orderBy?: ZoomMeetingOrderByWithRelationInput | ZoomMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoomMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZoomMeetings
    **/
    _count?: true | ZoomMeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoomMeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoomMeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoomMeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoomMeetingMaxAggregateInputType
  }

  export type GetZoomMeetingAggregateType<T extends ZoomMeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateZoomMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZoomMeeting[P]>
      : GetScalarType<T[P], AggregateZoomMeeting[P]>
  }




  export type ZoomMeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoomMeetingWhereInput
    orderBy?: ZoomMeetingOrderByWithAggregationInput | ZoomMeetingOrderByWithAggregationInput[]
    by: ZoomMeetingScalarFieldEnum[] | ZoomMeetingScalarFieldEnum
    having?: ZoomMeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoomMeetingCountAggregateInputType | true
    _avg?: ZoomMeetingAvgAggregateInputType
    _sum?: ZoomMeetingSumAggregateInputType
    _min?: ZoomMeetingMinAggregateInputType
    _max?: ZoomMeetingMaxAggregateInputType
  }

  export type ZoomMeetingGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    meetingId: string
    uuid: string | null
    topic: string
    agenda: string | null
    startTime: Date
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl: string | null
    startUrl: string | null
    password: string | null
    hostEmail: string | null
    participantCount: number | null
    hasRecording: boolean
    recordingUrl: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ZoomMeetingCountAggregateOutputType | null
    _avg: ZoomMeetingAvgAggregateOutputType | null
    _sum: ZoomMeetingSumAggregateOutputType | null
    _min: ZoomMeetingMinAggregateOutputType | null
    _max: ZoomMeetingMaxAggregateOutputType | null
  }

  type GetZoomMeetingGroupByPayload<T extends ZoomMeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoomMeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoomMeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoomMeetingGroupByOutputType[P]>
            : GetScalarType<T[P], ZoomMeetingGroupByOutputType[P]>
        }
      >
    >


  export type ZoomMeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    meetingId?: boolean
    uuid?: boolean
    topic?: boolean
    agenda?: boolean
    startTime?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    meetingType?: boolean
    joinUrl?: boolean
    startUrl?: boolean
    password?: boolean
    hostEmail?: boolean
    participantCount?: boolean
    hasRecording?: boolean
    recordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | ZoomMeeting$dealArgs<ExtArgs>
    participants?: boolean | ZoomMeeting$participantsArgs<ExtArgs>
    _count?: boolean | ZoomMeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zoomMeeting"]>

  export type ZoomMeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    meetingId?: boolean
    uuid?: boolean
    topic?: boolean
    agenda?: boolean
    startTime?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    meetingType?: boolean
    joinUrl?: boolean
    startUrl?: boolean
    password?: boolean
    hostEmail?: boolean
    participantCount?: boolean
    hasRecording?: boolean
    recordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | ZoomMeeting$dealArgs<ExtArgs>
  }, ExtArgs["result"]["zoomMeeting"]>

  export type ZoomMeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    meetingId?: boolean
    uuid?: boolean
    topic?: boolean
    agenda?: boolean
    startTime?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    meetingType?: boolean
    joinUrl?: boolean
    startUrl?: boolean
    password?: boolean
    hostEmail?: boolean
    participantCount?: boolean
    hasRecording?: boolean
    recordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | ZoomMeeting$dealArgs<ExtArgs>
  }, ExtArgs["result"]["zoomMeeting"]>

  export type ZoomMeetingSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    meetingId?: boolean
    uuid?: boolean
    topic?: boolean
    agenda?: boolean
    startTime?: boolean
    duration?: boolean
    timezone?: boolean
    status?: boolean
    meetingType?: boolean
    joinUrl?: boolean
    startUrl?: boolean
    password?: boolean
    hostEmail?: boolean
    participantCount?: boolean
    hasRecording?: boolean
    recordingUrl?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoomMeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "meetingId" | "uuid" | "topic" | "agenda" | "startTime" | "duration" | "timezone" | "status" | "meetingType" | "joinUrl" | "startUrl" | "password" | "hostEmail" | "participantCount" | "hasRecording" | "recordingUrl" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["zoomMeeting"]>
  export type ZoomMeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | ZoomMeeting$dealArgs<ExtArgs>
    participants?: boolean | ZoomMeeting$participantsArgs<ExtArgs>
    _count?: boolean | ZoomMeetingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoomMeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | ZoomMeeting$dealArgs<ExtArgs>
  }
  export type ZoomMeetingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | ZoomMeeting$dealArgs<ExtArgs>
  }

  export type $ZoomMeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZoomMeeting"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      participants: Prisma.$ZoomParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      meetingId: string
      uuid: string | null
      topic: string
      agenda: string | null
      startTime: Date
      duration: number
      timezone: string
      status: string
      meetingType: string
      joinUrl: string | null
      startUrl: string | null
      password: string | null
      hostEmail: string | null
      participantCount: number | null
      hasRecording: boolean
      recordingUrl: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zoomMeeting"]>
    composites: {}
  }

  type ZoomMeetingGetPayload<S extends boolean | null | undefined | ZoomMeetingDefaultArgs> = $Result.GetResult<Prisma.$ZoomMeetingPayload, S>

  type ZoomMeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoomMeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoomMeetingCountAggregateInputType | true
    }

  export interface ZoomMeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZoomMeeting'], meta: { name: 'ZoomMeeting' } }
    /**
     * Find zero or one ZoomMeeting that matches the filter.
     * @param {ZoomMeetingFindUniqueArgs} args - Arguments to find a ZoomMeeting
     * @example
     * // Get one ZoomMeeting
     * const zoomMeeting = await prisma.zoomMeeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoomMeetingFindUniqueArgs>(args: SelectSubset<T, ZoomMeetingFindUniqueArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZoomMeeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoomMeetingFindUniqueOrThrowArgs} args - Arguments to find a ZoomMeeting
     * @example
     * // Get one ZoomMeeting
     * const zoomMeeting = await prisma.zoomMeeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoomMeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoomMeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZoomMeeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingFindFirstArgs} args - Arguments to find a ZoomMeeting
     * @example
     * // Get one ZoomMeeting
     * const zoomMeeting = await prisma.zoomMeeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoomMeetingFindFirstArgs>(args?: SelectSubset<T, ZoomMeetingFindFirstArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZoomMeeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingFindFirstOrThrowArgs} args - Arguments to find a ZoomMeeting
     * @example
     * // Get one ZoomMeeting
     * const zoomMeeting = await prisma.zoomMeeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoomMeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoomMeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZoomMeetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZoomMeetings
     * const zoomMeetings = await prisma.zoomMeeting.findMany()
     * 
     * // Get first 10 ZoomMeetings
     * const zoomMeetings = await prisma.zoomMeeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoomMeetingWithIdOnly = await prisma.zoomMeeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoomMeetingFindManyArgs>(args?: SelectSubset<T, ZoomMeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZoomMeeting.
     * @param {ZoomMeetingCreateArgs} args - Arguments to create a ZoomMeeting.
     * @example
     * // Create one ZoomMeeting
     * const ZoomMeeting = await prisma.zoomMeeting.create({
     *   data: {
     *     // ... data to create a ZoomMeeting
     *   }
     * })
     * 
     */
    create<T extends ZoomMeetingCreateArgs>(args: SelectSubset<T, ZoomMeetingCreateArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZoomMeetings.
     * @param {ZoomMeetingCreateManyArgs} args - Arguments to create many ZoomMeetings.
     * @example
     * // Create many ZoomMeetings
     * const zoomMeeting = await prisma.zoomMeeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoomMeetingCreateManyArgs>(args?: SelectSubset<T, ZoomMeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZoomMeetings and returns the data saved in the database.
     * @param {ZoomMeetingCreateManyAndReturnArgs} args - Arguments to create many ZoomMeetings.
     * @example
     * // Create many ZoomMeetings
     * const zoomMeeting = await prisma.zoomMeeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZoomMeetings and only return the `id`
     * const zoomMeetingWithIdOnly = await prisma.zoomMeeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoomMeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoomMeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZoomMeeting.
     * @param {ZoomMeetingDeleteArgs} args - Arguments to delete one ZoomMeeting.
     * @example
     * // Delete one ZoomMeeting
     * const ZoomMeeting = await prisma.zoomMeeting.delete({
     *   where: {
     *     // ... filter to delete one ZoomMeeting
     *   }
     * })
     * 
     */
    delete<T extends ZoomMeetingDeleteArgs>(args: SelectSubset<T, ZoomMeetingDeleteArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZoomMeeting.
     * @param {ZoomMeetingUpdateArgs} args - Arguments to update one ZoomMeeting.
     * @example
     * // Update one ZoomMeeting
     * const zoomMeeting = await prisma.zoomMeeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoomMeetingUpdateArgs>(args: SelectSubset<T, ZoomMeetingUpdateArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZoomMeetings.
     * @param {ZoomMeetingDeleteManyArgs} args - Arguments to filter ZoomMeetings to delete.
     * @example
     * // Delete a few ZoomMeetings
     * const { count } = await prisma.zoomMeeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoomMeetingDeleteManyArgs>(args?: SelectSubset<T, ZoomMeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoomMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZoomMeetings
     * const zoomMeeting = await prisma.zoomMeeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoomMeetingUpdateManyArgs>(args: SelectSubset<T, ZoomMeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoomMeetings and returns the data updated in the database.
     * @param {ZoomMeetingUpdateManyAndReturnArgs} args - Arguments to update many ZoomMeetings.
     * @example
     * // Update many ZoomMeetings
     * const zoomMeeting = await prisma.zoomMeeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZoomMeetings and only return the `id`
     * const zoomMeetingWithIdOnly = await prisma.zoomMeeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoomMeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoomMeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZoomMeeting.
     * @param {ZoomMeetingUpsertArgs} args - Arguments to update or create a ZoomMeeting.
     * @example
     * // Update or create a ZoomMeeting
     * const zoomMeeting = await prisma.zoomMeeting.upsert({
     *   create: {
     *     // ... data to create a ZoomMeeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZoomMeeting we want to update
     *   }
     * })
     */
    upsert<T extends ZoomMeetingUpsertArgs>(args: SelectSubset<T, ZoomMeetingUpsertArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZoomMeetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingCountArgs} args - Arguments to filter ZoomMeetings to count.
     * @example
     * // Count the number of ZoomMeetings
     * const count = await prisma.zoomMeeting.count({
     *   where: {
     *     // ... the filter for the ZoomMeetings we want to count
     *   }
     * })
    **/
    count<T extends ZoomMeetingCountArgs>(
      args?: Subset<T, ZoomMeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoomMeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZoomMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoomMeetingAggregateArgs>(args: Subset<T, ZoomMeetingAggregateArgs>): Prisma.PrismaPromise<GetZoomMeetingAggregateType<T>>

    /**
     * Group by ZoomMeeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomMeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoomMeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoomMeetingGroupByArgs['orderBy'] }
        : { orderBy?: ZoomMeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoomMeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoomMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZoomMeeting model
   */
  readonly fields: ZoomMeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZoomMeeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoomMeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends ZoomMeeting$dealArgs<ExtArgs> = {}>(args?: Subset<T, ZoomMeeting$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends ZoomMeeting$participantsArgs<ExtArgs> = {}>(args?: Subset<T, ZoomMeeting$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZoomMeeting model
   */
  interface ZoomMeetingFieldRefs {
    readonly id: FieldRef<"ZoomMeeting", 'String'>
    readonly userId: FieldRef<"ZoomMeeting", 'String'>
    readonly dealId: FieldRef<"ZoomMeeting", 'String'>
    readonly meetingId: FieldRef<"ZoomMeeting", 'String'>
    readonly uuid: FieldRef<"ZoomMeeting", 'String'>
    readonly topic: FieldRef<"ZoomMeeting", 'String'>
    readonly agenda: FieldRef<"ZoomMeeting", 'String'>
    readonly startTime: FieldRef<"ZoomMeeting", 'DateTime'>
    readonly duration: FieldRef<"ZoomMeeting", 'Int'>
    readonly timezone: FieldRef<"ZoomMeeting", 'String'>
    readonly status: FieldRef<"ZoomMeeting", 'String'>
    readonly meetingType: FieldRef<"ZoomMeeting", 'String'>
    readonly joinUrl: FieldRef<"ZoomMeeting", 'String'>
    readonly startUrl: FieldRef<"ZoomMeeting", 'String'>
    readonly password: FieldRef<"ZoomMeeting", 'String'>
    readonly hostEmail: FieldRef<"ZoomMeeting", 'String'>
    readonly participantCount: FieldRef<"ZoomMeeting", 'Int'>
    readonly hasRecording: FieldRef<"ZoomMeeting", 'Boolean'>
    readonly recordingUrl: FieldRef<"ZoomMeeting", 'String'>
    readonly metadata: FieldRef<"ZoomMeeting", 'Json'>
    readonly createdAt: FieldRef<"ZoomMeeting", 'DateTime'>
    readonly updatedAt: FieldRef<"ZoomMeeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZoomMeeting findUnique
   */
  export type ZoomMeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * Filter, which ZoomMeeting to fetch.
     */
    where: ZoomMeetingWhereUniqueInput
  }

  /**
   * ZoomMeeting findUniqueOrThrow
   */
  export type ZoomMeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * Filter, which ZoomMeeting to fetch.
     */
    where: ZoomMeetingWhereUniqueInput
  }

  /**
   * ZoomMeeting findFirst
   */
  export type ZoomMeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * Filter, which ZoomMeeting to fetch.
     */
    where?: ZoomMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomMeetings to fetch.
     */
    orderBy?: ZoomMeetingOrderByWithRelationInput | ZoomMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoomMeetings.
     */
    cursor?: ZoomMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoomMeetings.
     */
    distinct?: ZoomMeetingScalarFieldEnum | ZoomMeetingScalarFieldEnum[]
  }

  /**
   * ZoomMeeting findFirstOrThrow
   */
  export type ZoomMeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * Filter, which ZoomMeeting to fetch.
     */
    where?: ZoomMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomMeetings to fetch.
     */
    orderBy?: ZoomMeetingOrderByWithRelationInput | ZoomMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoomMeetings.
     */
    cursor?: ZoomMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomMeetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoomMeetings.
     */
    distinct?: ZoomMeetingScalarFieldEnum | ZoomMeetingScalarFieldEnum[]
  }

  /**
   * ZoomMeeting findMany
   */
  export type ZoomMeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * Filter, which ZoomMeetings to fetch.
     */
    where?: ZoomMeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomMeetings to fetch.
     */
    orderBy?: ZoomMeetingOrderByWithRelationInput | ZoomMeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZoomMeetings.
     */
    cursor?: ZoomMeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomMeetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomMeetings.
     */
    skip?: number
    distinct?: ZoomMeetingScalarFieldEnum | ZoomMeetingScalarFieldEnum[]
  }

  /**
   * ZoomMeeting create
   */
  export type ZoomMeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a ZoomMeeting.
     */
    data: XOR<ZoomMeetingCreateInput, ZoomMeetingUncheckedCreateInput>
  }

  /**
   * ZoomMeeting createMany
   */
  export type ZoomMeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZoomMeetings.
     */
    data: ZoomMeetingCreateManyInput | ZoomMeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZoomMeeting createManyAndReturn
   */
  export type ZoomMeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * The data used to create many ZoomMeetings.
     */
    data: ZoomMeetingCreateManyInput | ZoomMeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZoomMeeting update
   */
  export type ZoomMeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a ZoomMeeting.
     */
    data: XOR<ZoomMeetingUpdateInput, ZoomMeetingUncheckedUpdateInput>
    /**
     * Choose, which ZoomMeeting to update.
     */
    where: ZoomMeetingWhereUniqueInput
  }

  /**
   * ZoomMeeting updateMany
   */
  export type ZoomMeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZoomMeetings.
     */
    data: XOR<ZoomMeetingUpdateManyMutationInput, ZoomMeetingUncheckedUpdateManyInput>
    /**
     * Filter which ZoomMeetings to update
     */
    where?: ZoomMeetingWhereInput
    /**
     * Limit how many ZoomMeetings to update.
     */
    limit?: number
  }

  /**
   * ZoomMeeting updateManyAndReturn
   */
  export type ZoomMeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * The data used to update ZoomMeetings.
     */
    data: XOR<ZoomMeetingUpdateManyMutationInput, ZoomMeetingUncheckedUpdateManyInput>
    /**
     * Filter which ZoomMeetings to update
     */
    where?: ZoomMeetingWhereInput
    /**
     * Limit how many ZoomMeetings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZoomMeeting upsert
   */
  export type ZoomMeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the ZoomMeeting to update in case it exists.
     */
    where: ZoomMeetingWhereUniqueInput
    /**
     * In case the ZoomMeeting found by the `where` argument doesn't exist, create a new ZoomMeeting with this data.
     */
    create: XOR<ZoomMeetingCreateInput, ZoomMeetingUncheckedCreateInput>
    /**
     * In case the ZoomMeeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoomMeetingUpdateInput, ZoomMeetingUncheckedUpdateInput>
  }

  /**
   * ZoomMeeting delete
   */
  export type ZoomMeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
    /**
     * Filter which ZoomMeeting to delete.
     */
    where: ZoomMeetingWhereUniqueInput
  }

  /**
   * ZoomMeeting deleteMany
   */
  export type ZoomMeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoomMeetings to delete
     */
    where?: ZoomMeetingWhereInput
    /**
     * Limit how many ZoomMeetings to delete.
     */
    limit?: number
  }

  /**
   * ZoomMeeting.deal
   */
  export type ZoomMeeting$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * ZoomMeeting.participants
   */
  export type ZoomMeeting$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    where?: ZoomParticipantWhereInput
    orderBy?: ZoomParticipantOrderByWithRelationInput | ZoomParticipantOrderByWithRelationInput[]
    cursor?: ZoomParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoomParticipantScalarFieldEnum | ZoomParticipantScalarFieldEnum[]
  }

  /**
   * ZoomMeeting without action
   */
  export type ZoomMeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomMeeting
     */
    select?: ZoomMeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomMeeting
     */
    omit?: ZoomMeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomMeetingInclude<ExtArgs> | null
  }


  /**
   * Model ZoomParticipant
   */

  export type AggregateZoomParticipant = {
    _count: ZoomParticipantCountAggregateOutputType | null
    _avg: ZoomParticipantAvgAggregateOutputType | null
    _sum: ZoomParticipantSumAggregateOutputType | null
    _min: ZoomParticipantMinAggregateOutputType | null
    _max: ZoomParticipantMaxAggregateOutputType | null
  }

  export type ZoomParticipantAvgAggregateOutputType = {
    duration: number | null
  }

  export type ZoomParticipantSumAggregateOutputType = {
    duration: number | null
  }

  export type ZoomParticipantMinAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    zoomUserId: string | null
    name: string | null
    email: string | null
    joinTime: Date | null
    leaveTime: Date | null
    duration: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoomParticipantMaxAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    zoomUserId: string | null
    name: string | null
    email: string | null
    joinTime: Date | null
    leaveTime: Date | null
    duration: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoomParticipantCountAggregateOutputType = {
    id: number
    meetingId: number
    userId: number
    zoomUserId: number
    name: number
    email: number
    joinTime: number
    leaveTime: number
    duration: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoomParticipantAvgAggregateInputType = {
    duration?: true
  }

  export type ZoomParticipantSumAggregateInputType = {
    duration?: true
  }

  export type ZoomParticipantMinAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    zoomUserId?: true
    name?: true
    email?: true
    joinTime?: true
    leaveTime?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoomParticipantMaxAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    zoomUserId?: true
    name?: true
    email?: true
    joinTime?: true
    leaveTime?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoomParticipantCountAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    zoomUserId?: true
    name?: true
    email?: true
    joinTime?: true
    leaveTime?: true
    duration?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoomParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoomParticipant to aggregate.
     */
    where?: ZoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomParticipants to fetch.
     */
    orderBy?: ZoomParticipantOrderByWithRelationInput | ZoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZoomParticipants
    **/
    _count?: true | ZoomParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoomParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoomParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoomParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoomParticipantMaxAggregateInputType
  }

  export type GetZoomParticipantAggregateType<T extends ZoomParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateZoomParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZoomParticipant[P]>
      : GetScalarType<T[P], AggregateZoomParticipant[P]>
  }




  export type ZoomParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoomParticipantWhereInput
    orderBy?: ZoomParticipantOrderByWithAggregationInput | ZoomParticipantOrderByWithAggregationInput[]
    by: ZoomParticipantScalarFieldEnum[] | ZoomParticipantScalarFieldEnum
    having?: ZoomParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoomParticipantCountAggregateInputType | true
    _avg?: ZoomParticipantAvgAggregateInputType
    _sum?: ZoomParticipantSumAggregateInputType
    _min?: ZoomParticipantMinAggregateInputType
    _max?: ZoomParticipantMaxAggregateInputType
  }

  export type ZoomParticipantGroupByOutputType = {
    id: string
    meetingId: string
    userId: string | null
    zoomUserId: string | null
    name: string
    email: string | null
    joinTime: Date
    leaveTime: Date | null
    duration: number | null
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ZoomParticipantCountAggregateOutputType | null
    _avg: ZoomParticipantAvgAggregateOutputType | null
    _sum: ZoomParticipantSumAggregateOutputType | null
    _min: ZoomParticipantMinAggregateOutputType | null
    _max: ZoomParticipantMaxAggregateOutputType | null
  }

  type GetZoomParticipantGroupByPayload<T extends ZoomParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoomParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoomParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoomParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ZoomParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ZoomParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    zoomUserId?: boolean
    name?: boolean
    email?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    duration?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | ZoomMeetingDefaultArgs<ExtArgs>
    user?: boolean | ZoomParticipant$userArgs<ExtArgs>
  }, ExtArgs["result"]["zoomParticipant"]>

  export type ZoomParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    zoomUserId?: boolean
    name?: boolean
    email?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    duration?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | ZoomMeetingDefaultArgs<ExtArgs>
    user?: boolean | ZoomParticipant$userArgs<ExtArgs>
  }, ExtArgs["result"]["zoomParticipant"]>

  export type ZoomParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    zoomUserId?: boolean
    name?: boolean
    email?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    duration?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | ZoomMeetingDefaultArgs<ExtArgs>
    user?: boolean | ZoomParticipant$userArgs<ExtArgs>
  }, ExtArgs["result"]["zoomParticipant"]>

  export type ZoomParticipantSelectScalar = {
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    zoomUserId?: boolean
    name?: boolean
    email?: boolean
    joinTime?: boolean
    leaveTime?: boolean
    duration?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoomParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "meetingId" | "userId" | "zoomUserId" | "name" | "email" | "joinTime" | "leaveTime" | "duration" | "status" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["zoomParticipant"]>
  export type ZoomParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | ZoomMeetingDefaultArgs<ExtArgs>
    user?: boolean | ZoomParticipant$userArgs<ExtArgs>
  }
  export type ZoomParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | ZoomMeetingDefaultArgs<ExtArgs>
    user?: boolean | ZoomParticipant$userArgs<ExtArgs>
  }
  export type ZoomParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | ZoomMeetingDefaultArgs<ExtArgs>
    user?: boolean | ZoomParticipant$userArgs<ExtArgs>
  }

  export type $ZoomParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZoomParticipant"
    objects: {
      meeting: Prisma.$ZoomMeetingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingId: string
      userId: string | null
      zoomUserId: string | null
      name: string
      email: string | null
      joinTime: Date
      leaveTime: Date | null
      duration: number | null
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zoomParticipant"]>
    composites: {}
  }

  type ZoomParticipantGetPayload<S extends boolean | null | undefined | ZoomParticipantDefaultArgs> = $Result.GetResult<Prisma.$ZoomParticipantPayload, S>

  type ZoomParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZoomParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoomParticipantCountAggregateInputType | true
    }

  export interface ZoomParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZoomParticipant'], meta: { name: 'ZoomParticipant' } }
    /**
     * Find zero or one ZoomParticipant that matches the filter.
     * @param {ZoomParticipantFindUniqueArgs} args - Arguments to find a ZoomParticipant
     * @example
     * // Get one ZoomParticipant
     * const zoomParticipant = await prisma.zoomParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoomParticipantFindUniqueArgs>(args: SelectSubset<T, ZoomParticipantFindUniqueArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZoomParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZoomParticipantFindUniqueOrThrowArgs} args - Arguments to find a ZoomParticipant
     * @example
     * // Get one ZoomParticipant
     * const zoomParticipant = await prisma.zoomParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoomParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoomParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZoomParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantFindFirstArgs} args - Arguments to find a ZoomParticipant
     * @example
     * // Get one ZoomParticipant
     * const zoomParticipant = await prisma.zoomParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoomParticipantFindFirstArgs>(args?: SelectSubset<T, ZoomParticipantFindFirstArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZoomParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantFindFirstOrThrowArgs} args - Arguments to find a ZoomParticipant
     * @example
     * // Get one ZoomParticipant
     * const zoomParticipant = await prisma.zoomParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoomParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoomParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZoomParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZoomParticipants
     * const zoomParticipants = await prisma.zoomParticipant.findMany()
     * 
     * // Get first 10 ZoomParticipants
     * const zoomParticipants = await prisma.zoomParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoomParticipantWithIdOnly = await prisma.zoomParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoomParticipantFindManyArgs>(args?: SelectSubset<T, ZoomParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZoomParticipant.
     * @param {ZoomParticipantCreateArgs} args - Arguments to create a ZoomParticipant.
     * @example
     * // Create one ZoomParticipant
     * const ZoomParticipant = await prisma.zoomParticipant.create({
     *   data: {
     *     // ... data to create a ZoomParticipant
     *   }
     * })
     * 
     */
    create<T extends ZoomParticipantCreateArgs>(args: SelectSubset<T, ZoomParticipantCreateArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZoomParticipants.
     * @param {ZoomParticipantCreateManyArgs} args - Arguments to create many ZoomParticipants.
     * @example
     * // Create many ZoomParticipants
     * const zoomParticipant = await prisma.zoomParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoomParticipantCreateManyArgs>(args?: SelectSubset<T, ZoomParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZoomParticipants and returns the data saved in the database.
     * @param {ZoomParticipantCreateManyAndReturnArgs} args - Arguments to create many ZoomParticipants.
     * @example
     * // Create many ZoomParticipants
     * const zoomParticipant = await prisma.zoomParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZoomParticipants and only return the `id`
     * const zoomParticipantWithIdOnly = await prisma.zoomParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoomParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoomParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZoomParticipant.
     * @param {ZoomParticipantDeleteArgs} args - Arguments to delete one ZoomParticipant.
     * @example
     * // Delete one ZoomParticipant
     * const ZoomParticipant = await prisma.zoomParticipant.delete({
     *   where: {
     *     // ... filter to delete one ZoomParticipant
     *   }
     * })
     * 
     */
    delete<T extends ZoomParticipantDeleteArgs>(args: SelectSubset<T, ZoomParticipantDeleteArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZoomParticipant.
     * @param {ZoomParticipantUpdateArgs} args - Arguments to update one ZoomParticipant.
     * @example
     * // Update one ZoomParticipant
     * const zoomParticipant = await prisma.zoomParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoomParticipantUpdateArgs>(args: SelectSubset<T, ZoomParticipantUpdateArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZoomParticipants.
     * @param {ZoomParticipantDeleteManyArgs} args - Arguments to filter ZoomParticipants to delete.
     * @example
     * // Delete a few ZoomParticipants
     * const { count } = await prisma.zoomParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoomParticipantDeleteManyArgs>(args?: SelectSubset<T, ZoomParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoomParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZoomParticipants
     * const zoomParticipant = await prisma.zoomParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoomParticipantUpdateManyArgs>(args: SelectSubset<T, ZoomParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZoomParticipants and returns the data updated in the database.
     * @param {ZoomParticipantUpdateManyAndReturnArgs} args - Arguments to update many ZoomParticipants.
     * @example
     * // Update many ZoomParticipants
     * const zoomParticipant = await prisma.zoomParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZoomParticipants and only return the `id`
     * const zoomParticipantWithIdOnly = await prisma.zoomParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZoomParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ZoomParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZoomParticipant.
     * @param {ZoomParticipantUpsertArgs} args - Arguments to update or create a ZoomParticipant.
     * @example
     * // Update or create a ZoomParticipant
     * const zoomParticipant = await prisma.zoomParticipant.upsert({
     *   create: {
     *     // ... data to create a ZoomParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZoomParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ZoomParticipantUpsertArgs>(args: SelectSubset<T, ZoomParticipantUpsertArgs<ExtArgs>>): Prisma__ZoomParticipantClient<$Result.GetResult<Prisma.$ZoomParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZoomParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantCountArgs} args - Arguments to filter ZoomParticipants to count.
     * @example
     * // Count the number of ZoomParticipants
     * const count = await prisma.zoomParticipant.count({
     *   where: {
     *     // ... the filter for the ZoomParticipants we want to count
     *   }
     * })
    **/
    count<T extends ZoomParticipantCountArgs>(
      args?: Subset<T, ZoomParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoomParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZoomParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoomParticipantAggregateArgs>(args: Subset<T, ZoomParticipantAggregateArgs>): Prisma.PrismaPromise<GetZoomParticipantAggregateType<T>>

    /**
     * Group by ZoomParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoomParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoomParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoomParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ZoomParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoomParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoomParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZoomParticipant model
   */
  readonly fields: ZoomParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZoomParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoomParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends ZoomMeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoomMeetingDefaultArgs<ExtArgs>>): Prisma__ZoomMeetingClient<$Result.GetResult<Prisma.$ZoomMeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ZoomParticipant$userArgs<ExtArgs> = {}>(args?: Subset<T, ZoomParticipant$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZoomParticipant model
   */
  interface ZoomParticipantFieldRefs {
    readonly id: FieldRef<"ZoomParticipant", 'String'>
    readonly meetingId: FieldRef<"ZoomParticipant", 'String'>
    readonly userId: FieldRef<"ZoomParticipant", 'String'>
    readonly zoomUserId: FieldRef<"ZoomParticipant", 'String'>
    readonly name: FieldRef<"ZoomParticipant", 'String'>
    readonly email: FieldRef<"ZoomParticipant", 'String'>
    readonly joinTime: FieldRef<"ZoomParticipant", 'DateTime'>
    readonly leaveTime: FieldRef<"ZoomParticipant", 'DateTime'>
    readonly duration: FieldRef<"ZoomParticipant", 'Int'>
    readonly status: FieldRef<"ZoomParticipant", 'String'>
    readonly metadata: FieldRef<"ZoomParticipant", 'Json'>
    readonly createdAt: FieldRef<"ZoomParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"ZoomParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZoomParticipant findUnique
   */
  export type ZoomParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ZoomParticipant to fetch.
     */
    where: ZoomParticipantWhereUniqueInput
  }

  /**
   * ZoomParticipant findUniqueOrThrow
   */
  export type ZoomParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ZoomParticipant to fetch.
     */
    where: ZoomParticipantWhereUniqueInput
  }

  /**
   * ZoomParticipant findFirst
   */
  export type ZoomParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ZoomParticipant to fetch.
     */
    where?: ZoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomParticipants to fetch.
     */
    orderBy?: ZoomParticipantOrderByWithRelationInput | ZoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoomParticipants.
     */
    cursor?: ZoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoomParticipants.
     */
    distinct?: ZoomParticipantScalarFieldEnum | ZoomParticipantScalarFieldEnum[]
  }

  /**
   * ZoomParticipant findFirstOrThrow
   */
  export type ZoomParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ZoomParticipant to fetch.
     */
    where?: ZoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomParticipants to fetch.
     */
    orderBy?: ZoomParticipantOrderByWithRelationInput | ZoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZoomParticipants.
     */
    cursor?: ZoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZoomParticipants.
     */
    distinct?: ZoomParticipantScalarFieldEnum | ZoomParticipantScalarFieldEnum[]
  }

  /**
   * ZoomParticipant findMany
   */
  export type ZoomParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ZoomParticipants to fetch.
     */
    where?: ZoomParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZoomParticipants to fetch.
     */
    orderBy?: ZoomParticipantOrderByWithRelationInput | ZoomParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZoomParticipants.
     */
    cursor?: ZoomParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZoomParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZoomParticipants.
     */
    skip?: number
    distinct?: ZoomParticipantScalarFieldEnum | ZoomParticipantScalarFieldEnum[]
  }

  /**
   * ZoomParticipant create
   */
  export type ZoomParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ZoomParticipant.
     */
    data: XOR<ZoomParticipantCreateInput, ZoomParticipantUncheckedCreateInput>
  }

  /**
   * ZoomParticipant createMany
   */
  export type ZoomParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZoomParticipants.
     */
    data: ZoomParticipantCreateManyInput | ZoomParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZoomParticipant createManyAndReturn
   */
  export type ZoomParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ZoomParticipants.
     */
    data: ZoomParticipantCreateManyInput | ZoomParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZoomParticipant update
   */
  export type ZoomParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ZoomParticipant.
     */
    data: XOR<ZoomParticipantUpdateInput, ZoomParticipantUncheckedUpdateInput>
    /**
     * Choose, which ZoomParticipant to update.
     */
    where: ZoomParticipantWhereUniqueInput
  }

  /**
   * ZoomParticipant updateMany
   */
  export type ZoomParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZoomParticipants.
     */
    data: XOR<ZoomParticipantUpdateManyMutationInput, ZoomParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ZoomParticipants to update
     */
    where?: ZoomParticipantWhereInput
    /**
     * Limit how many ZoomParticipants to update.
     */
    limit?: number
  }

  /**
   * ZoomParticipant updateManyAndReturn
   */
  export type ZoomParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ZoomParticipants.
     */
    data: XOR<ZoomParticipantUpdateManyMutationInput, ZoomParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ZoomParticipants to update
     */
    where?: ZoomParticipantWhereInput
    /**
     * Limit how many ZoomParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZoomParticipant upsert
   */
  export type ZoomParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ZoomParticipant to update in case it exists.
     */
    where: ZoomParticipantWhereUniqueInput
    /**
     * In case the ZoomParticipant found by the `where` argument doesn't exist, create a new ZoomParticipant with this data.
     */
    create: XOR<ZoomParticipantCreateInput, ZoomParticipantUncheckedCreateInput>
    /**
     * In case the ZoomParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoomParticipantUpdateInput, ZoomParticipantUncheckedUpdateInput>
  }

  /**
   * ZoomParticipant delete
   */
  export type ZoomParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
    /**
     * Filter which ZoomParticipant to delete.
     */
    where: ZoomParticipantWhereUniqueInput
  }

  /**
   * ZoomParticipant deleteMany
   */
  export type ZoomParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZoomParticipants to delete
     */
    where?: ZoomParticipantWhereInput
    /**
     * Limit how many ZoomParticipants to delete.
     */
    limit?: number
  }

  /**
   * ZoomParticipant.user
   */
  export type ZoomParticipant$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ZoomParticipant without action
   */
  export type ZoomParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoomParticipant
     */
    select?: ZoomParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZoomParticipant
     */
    omit?: ZoomParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoomParticipantInclude<ExtArgs> | null
  }


  /**
   * Model SalesforceAccount
   */

  export type AggregateSalesforceAccount = {
    _count: SalesforceAccountCountAggregateOutputType | null
    _avg: SalesforceAccountAvgAggregateOutputType | null
    _sum: SalesforceAccountSumAggregateOutputType | null
    _min: SalesforceAccountMinAggregateOutputType | null
    _max: SalesforceAccountMaxAggregateOutputType | null
  }

  export type SalesforceAccountAvgAggregateOutputType = {
    revenue: number | null
    employees: number | null
  }

  export type SalesforceAccountSumAggregateOutputType = {
    revenue: number | null
    employees: number | null
  }

  export type SalesforceAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    accountId: string | null
    name: string | null
    type: string | null
    industry: string | null
    website: string | null
    phone: string | null
    billingCity: string | null
    billingState: string | null
    billingCountry: string | null
    description: string | null
    revenue: number | null
    employees: number | null
    ownerId: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesforceAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    accountId: string | null
    name: string | null
    type: string | null
    industry: string | null
    website: string | null
    phone: string | null
    billingCity: string | null
    billingState: string | null
    billingCountry: string | null
    description: string | null
    revenue: number | null
    employees: number | null
    ownerId: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesforceAccountCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    accountId: number
    name: number
    type: number
    industry: number
    website: number
    phone: number
    billingCity: number
    billingState: number
    billingCountry: number
    description: number
    revenue: number
    employees: number
    ownerId: number
    metadata: number
    lastSync: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesforceAccountAvgAggregateInputType = {
    revenue?: true
    employees?: true
  }

  export type SalesforceAccountSumAggregateInputType = {
    revenue?: true
    employees?: true
  }

  export type SalesforceAccountMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    accountId?: true
    name?: true
    type?: true
    industry?: true
    website?: true
    phone?: true
    billingCity?: true
    billingState?: true
    billingCountry?: true
    description?: true
    revenue?: true
    employees?: true
    ownerId?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesforceAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    accountId?: true
    name?: true
    type?: true
    industry?: true
    website?: true
    phone?: true
    billingCity?: true
    billingState?: true
    billingCountry?: true
    description?: true
    revenue?: true
    employees?: true
    ownerId?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesforceAccountCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    accountId?: true
    name?: true
    type?: true
    industry?: true
    website?: true
    phone?: true
    billingCity?: true
    billingState?: true
    billingCountry?: true
    description?: true
    revenue?: true
    employees?: true
    ownerId?: true
    metadata?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesforceAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesforceAccount to aggregate.
     */
    where?: SalesforceAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceAccounts to fetch.
     */
    orderBy?: SalesforceAccountOrderByWithRelationInput | SalesforceAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesforceAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesforceAccounts
    **/
    _count?: true | SalesforceAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesforceAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesforceAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesforceAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesforceAccountMaxAggregateInputType
  }

  export type GetSalesforceAccountAggregateType<T extends SalesforceAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesforceAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesforceAccount[P]>
      : GetScalarType<T[P], AggregateSalesforceAccount[P]>
  }




  export type SalesforceAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceAccountWhereInput
    orderBy?: SalesforceAccountOrderByWithAggregationInput | SalesforceAccountOrderByWithAggregationInput[]
    by: SalesforceAccountScalarFieldEnum[] | SalesforceAccountScalarFieldEnum
    having?: SalesforceAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesforceAccountCountAggregateInputType | true
    _avg?: SalesforceAccountAvgAggregateInputType
    _sum?: SalesforceAccountSumAggregateInputType
    _min?: SalesforceAccountMinAggregateInputType
    _max?: SalesforceAccountMaxAggregateInputType
  }

  export type SalesforceAccountGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    accountId: string
    name: string
    type: string | null
    industry: string | null
    website: string | null
    phone: string | null
    billingCity: string | null
    billingState: string | null
    billingCountry: string | null
    description: string | null
    revenue: number | null
    employees: number | null
    ownerId: string | null
    metadata: JsonValue | null
    lastSync: Date
    createdAt: Date
    updatedAt: Date
    _count: SalesforceAccountCountAggregateOutputType | null
    _avg: SalesforceAccountAvgAggregateOutputType | null
    _sum: SalesforceAccountSumAggregateOutputType | null
    _min: SalesforceAccountMinAggregateOutputType | null
    _max: SalesforceAccountMaxAggregateOutputType | null
  }

  type GetSalesforceAccountGroupByPayload<T extends SalesforceAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesforceAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesforceAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesforceAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SalesforceAccountGroupByOutputType[P]>
        }
      >
    >


  export type SalesforceAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    accountId?: boolean
    name?: boolean
    type?: boolean
    industry?: boolean
    website?: boolean
    phone?: boolean
    billingCity?: boolean
    billingState?: boolean
    billingCountry?: boolean
    description?: boolean
    revenue?: boolean
    employees?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceAccount$dealArgs<ExtArgs>
    contacts?: boolean | SalesforceAccount$contactsArgs<ExtArgs>
    opportunities?: boolean | SalesforceAccount$opportunitiesArgs<ExtArgs>
    _count?: boolean | SalesforceAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceAccount"]>

  export type SalesforceAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    accountId?: boolean
    name?: boolean
    type?: boolean
    industry?: boolean
    website?: boolean
    phone?: boolean
    billingCity?: boolean
    billingState?: boolean
    billingCountry?: boolean
    description?: boolean
    revenue?: boolean
    employees?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceAccount$dealArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceAccount"]>

  export type SalesforceAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    accountId?: boolean
    name?: boolean
    type?: boolean
    industry?: boolean
    website?: boolean
    phone?: boolean
    billingCity?: boolean
    billingState?: boolean
    billingCountry?: boolean
    description?: boolean
    revenue?: boolean
    employees?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceAccount$dealArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceAccount"]>

  export type SalesforceAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    accountId?: boolean
    name?: boolean
    type?: boolean
    industry?: boolean
    website?: boolean
    phone?: boolean
    billingCity?: boolean
    billingState?: boolean
    billingCountry?: boolean
    description?: boolean
    revenue?: boolean
    employees?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesforceAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "accountId" | "name" | "type" | "industry" | "website" | "phone" | "billingCity" | "billingState" | "billingCountry" | "description" | "revenue" | "employees" | "ownerId" | "metadata" | "lastSync" | "createdAt" | "updatedAt", ExtArgs["result"]["salesforceAccount"]>
  export type SalesforceAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceAccount$dealArgs<ExtArgs>
    contacts?: boolean | SalesforceAccount$contactsArgs<ExtArgs>
    opportunities?: boolean | SalesforceAccount$opportunitiesArgs<ExtArgs>
    _count?: boolean | SalesforceAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesforceAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceAccount$dealArgs<ExtArgs>
  }
  export type SalesforceAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceAccount$dealArgs<ExtArgs>
  }

  export type $SalesforceAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesforceAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      contacts: Prisma.$SalesforceContactPayload<ExtArgs>[]
      opportunities: Prisma.$SalesforceOpportunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      accountId: string
      name: string
      type: string | null
      industry: string | null
      website: string | null
      phone: string | null
      billingCity: string | null
      billingState: string | null
      billingCountry: string | null
      description: string | null
      revenue: number | null
      employees: number | null
      ownerId: string | null
      metadata: Prisma.JsonValue | null
      lastSync: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesforceAccount"]>
    composites: {}
  }

  type SalesforceAccountGetPayload<S extends boolean | null | undefined | SalesforceAccountDefaultArgs> = $Result.GetResult<Prisma.$SalesforceAccountPayload, S>

  type SalesforceAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesforceAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesforceAccountCountAggregateInputType | true
    }

  export interface SalesforceAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesforceAccount'], meta: { name: 'SalesforceAccount' } }
    /**
     * Find zero or one SalesforceAccount that matches the filter.
     * @param {SalesforceAccountFindUniqueArgs} args - Arguments to find a SalesforceAccount
     * @example
     * // Get one SalesforceAccount
     * const salesforceAccount = await prisma.salesforceAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesforceAccountFindUniqueArgs>(args: SelectSubset<T, SalesforceAccountFindUniqueArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesforceAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesforceAccountFindUniqueOrThrowArgs} args - Arguments to find a SalesforceAccount
     * @example
     * // Get one SalesforceAccount
     * const salesforceAccount = await prisma.salesforceAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesforceAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesforceAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesforceAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountFindFirstArgs} args - Arguments to find a SalesforceAccount
     * @example
     * // Get one SalesforceAccount
     * const salesforceAccount = await prisma.salesforceAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesforceAccountFindFirstArgs>(args?: SelectSubset<T, SalesforceAccountFindFirstArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesforceAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountFindFirstOrThrowArgs} args - Arguments to find a SalesforceAccount
     * @example
     * // Get one SalesforceAccount
     * const salesforceAccount = await prisma.salesforceAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesforceAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesforceAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesforceAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesforceAccounts
     * const salesforceAccounts = await prisma.salesforceAccount.findMany()
     * 
     * // Get first 10 SalesforceAccounts
     * const salesforceAccounts = await prisma.salesforceAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesforceAccountWithIdOnly = await prisma.salesforceAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesforceAccountFindManyArgs>(args?: SelectSubset<T, SalesforceAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesforceAccount.
     * @param {SalesforceAccountCreateArgs} args - Arguments to create a SalesforceAccount.
     * @example
     * // Create one SalesforceAccount
     * const SalesforceAccount = await prisma.salesforceAccount.create({
     *   data: {
     *     // ... data to create a SalesforceAccount
     *   }
     * })
     * 
     */
    create<T extends SalesforceAccountCreateArgs>(args: SelectSubset<T, SalesforceAccountCreateArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesforceAccounts.
     * @param {SalesforceAccountCreateManyArgs} args - Arguments to create many SalesforceAccounts.
     * @example
     * // Create many SalesforceAccounts
     * const salesforceAccount = await prisma.salesforceAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesforceAccountCreateManyArgs>(args?: SelectSubset<T, SalesforceAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesforceAccounts and returns the data saved in the database.
     * @param {SalesforceAccountCreateManyAndReturnArgs} args - Arguments to create many SalesforceAccounts.
     * @example
     * // Create many SalesforceAccounts
     * const salesforceAccount = await prisma.salesforceAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesforceAccounts and only return the `id`
     * const salesforceAccountWithIdOnly = await prisma.salesforceAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesforceAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesforceAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesforceAccount.
     * @param {SalesforceAccountDeleteArgs} args - Arguments to delete one SalesforceAccount.
     * @example
     * // Delete one SalesforceAccount
     * const SalesforceAccount = await prisma.salesforceAccount.delete({
     *   where: {
     *     // ... filter to delete one SalesforceAccount
     *   }
     * })
     * 
     */
    delete<T extends SalesforceAccountDeleteArgs>(args: SelectSubset<T, SalesforceAccountDeleteArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesforceAccount.
     * @param {SalesforceAccountUpdateArgs} args - Arguments to update one SalesforceAccount.
     * @example
     * // Update one SalesforceAccount
     * const salesforceAccount = await prisma.salesforceAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesforceAccountUpdateArgs>(args: SelectSubset<T, SalesforceAccountUpdateArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesforceAccounts.
     * @param {SalesforceAccountDeleteManyArgs} args - Arguments to filter SalesforceAccounts to delete.
     * @example
     * // Delete a few SalesforceAccounts
     * const { count } = await prisma.salesforceAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesforceAccountDeleteManyArgs>(args?: SelectSubset<T, SalesforceAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesforceAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesforceAccounts
     * const salesforceAccount = await prisma.salesforceAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesforceAccountUpdateManyArgs>(args: SelectSubset<T, SalesforceAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesforceAccounts and returns the data updated in the database.
     * @param {SalesforceAccountUpdateManyAndReturnArgs} args - Arguments to update many SalesforceAccounts.
     * @example
     * // Update many SalesforceAccounts
     * const salesforceAccount = await prisma.salesforceAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesforceAccounts and only return the `id`
     * const salesforceAccountWithIdOnly = await prisma.salesforceAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesforceAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesforceAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesforceAccount.
     * @param {SalesforceAccountUpsertArgs} args - Arguments to update or create a SalesforceAccount.
     * @example
     * // Update or create a SalesforceAccount
     * const salesforceAccount = await prisma.salesforceAccount.upsert({
     *   create: {
     *     // ... data to create a SalesforceAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesforceAccount we want to update
     *   }
     * })
     */
    upsert<T extends SalesforceAccountUpsertArgs>(args: SelectSubset<T, SalesforceAccountUpsertArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesforceAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountCountArgs} args - Arguments to filter SalesforceAccounts to count.
     * @example
     * // Count the number of SalesforceAccounts
     * const count = await prisma.salesforceAccount.count({
     *   where: {
     *     // ... the filter for the SalesforceAccounts we want to count
     *   }
     * })
    **/
    count<T extends SalesforceAccountCountArgs>(
      args?: Subset<T, SalesforceAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesforceAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesforceAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesforceAccountAggregateArgs>(args: Subset<T, SalesforceAccountAggregateArgs>): Prisma.PrismaPromise<GetSalesforceAccountAggregateType<T>>

    /**
     * Group by SalesforceAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesforceAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesforceAccountGroupByArgs['orderBy'] }
        : { orderBy?: SalesforceAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesforceAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesforceAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesforceAccount model
   */
  readonly fields: SalesforceAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesforceAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesforceAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends SalesforceAccount$dealArgs<ExtArgs> = {}>(args?: Subset<T, SalesforceAccount$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contacts<T extends SalesforceAccount$contactsArgs<ExtArgs> = {}>(args?: Subset<T, SalesforceAccount$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    opportunities<T extends SalesforceAccount$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, SalesforceAccount$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesforceAccount model
   */
  interface SalesforceAccountFieldRefs {
    readonly id: FieldRef<"SalesforceAccount", 'String'>
    readonly userId: FieldRef<"SalesforceAccount", 'String'>
    readonly dealId: FieldRef<"SalesforceAccount", 'String'>
    readonly accountId: FieldRef<"SalesforceAccount", 'String'>
    readonly name: FieldRef<"SalesforceAccount", 'String'>
    readonly type: FieldRef<"SalesforceAccount", 'String'>
    readonly industry: FieldRef<"SalesforceAccount", 'String'>
    readonly website: FieldRef<"SalesforceAccount", 'String'>
    readonly phone: FieldRef<"SalesforceAccount", 'String'>
    readonly billingCity: FieldRef<"SalesforceAccount", 'String'>
    readonly billingState: FieldRef<"SalesforceAccount", 'String'>
    readonly billingCountry: FieldRef<"SalesforceAccount", 'String'>
    readonly description: FieldRef<"SalesforceAccount", 'String'>
    readonly revenue: FieldRef<"SalesforceAccount", 'Float'>
    readonly employees: FieldRef<"SalesforceAccount", 'Int'>
    readonly ownerId: FieldRef<"SalesforceAccount", 'String'>
    readonly metadata: FieldRef<"SalesforceAccount", 'Json'>
    readonly lastSync: FieldRef<"SalesforceAccount", 'DateTime'>
    readonly createdAt: FieldRef<"SalesforceAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesforceAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesforceAccount findUnique
   */
  export type SalesforceAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceAccount to fetch.
     */
    where: SalesforceAccountWhereUniqueInput
  }

  /**
   * SalesforceAccount findUniqueOrThrow
   */
  export type SalesforceAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceAccount to fetch.
     */
    where: SalesforceAccountWhereUniqueInput
  }

  /**
   * SalesforceAccount findFirst
   */
  export type SalesforceAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceAccount to fetch.
     */
    where?: SalesforceAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceAccounts to fetch.
     */
    orderBy?: SalesforceAccountOrderByWithRelationInput | SalesforceAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesforceAccounts.
     */
    cursor?: SalesforceAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesforceAccounts.
     */
    distinct?: SalesforceAccountScalarFieldEnum | SalesforceAccountScalarFieldEnum[]
  }

  /**
   * SalesforceAccount findFirstOrThrow
   */
  export type SalesforceAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceAccount to fetch.
     */
    where?: SalesforceAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceAccounts to fetch.
     */
    orderBy?: SalesforceAccountOrderByWithRelationInput | SalesforceAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesforceAccounts.
     */
    cursor?: SalesforceAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesforceAccounts.
     */
    distinct?: SalesforceAccountScalarFieldEnum | SalesforceAccountScalarFieldEnum[]
  }

  /**
   * SalesforceAccount findMany
   */
  export type SalesforceAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceAccounts to fetch.
     */
    where?: SalesforceAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceAccounts to fetch.
     */
    orderBy?: SalesforceAccountOrderByWithRelationInput | SalesforceAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesforceAccounts.
     */
    cursor?: SalesforceAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceAccounts.
     */
    skip?: number
    distinct?: SalesforceAccountScalarFieldEnum | SalesforceAccountScalarFieldEnum[]
  }

  /**
   * SalesforceAccount create
   */
  export type SalesforceAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesforceAccount.
     */
    data: XOR<SalesforceAccountCreateInput, SalesforceAccountUncheckedCreateInput>
  }

  /**
   * SalesforceAccount createMany
   */
  export type SalesforceAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesforceAccounts.
     */
    data: SalesforceAccountCreateManyInput | SalesforceAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesforceAccount createManyAndReturn
   */
  export type SalesforceAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SalesforceAccounts.
     */
    data: SalesforceAccountCreateManyInput | SalesforceAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesforceAccount update
   */
  export type SalesforceAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesforceAccount.
     */
    data: XOR<SalesforceAccountUpdateInput, SalesforceAccountUncheckedUpdateInput>
    /**
     * Choose, which SalesforceAccount to update.
     */
    where: SalesforceAccountWhereUniqueInput
  }

  /**
   * SalesforceAccount updateMany
   */
  export type SalesforceAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesforceAccounts.
     */
    data: XOR<SalesforceAccountUpdateManyMutationInput, SalesforceAccountUncheckedUpdateManyInput>
    /**
     * Filter which SalesforceAccounts to update
     */
    where?: SalesforceAccountWhereInput
    /**
     * Limit how many SalesforceAccounts to update.
     */
    limit?: number
  }

  /**
   * SalesforceAccount updateManyAndReturn
   */
  export type SalesforceAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * The data used to update SalesforceAccounts.
     */
    data: XOR<SalesforceAccountUpdateManyMutationInput, SalesforceAccountUncheckedUpdateManyInput>
    /**
     * Filter which SalesforceAccounts to update
     */
    where?: SalesforceAccountWhereInput
    /**
     * Limit how many SalesforceAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesforceAccount upsert
   */
  export type SalesforceAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesforceAccount to update in case it exists.
     */
    where: SalesforceAccountWhereUniqueInput
    /**
     * In case the SalesforceAccount found by the `where` argument doesn't exist, create a new SalesforceAccount with this data.
     */
    create: XOR<SalesforceAccountCreateInput, SalesforceAccountUncheckedCreateInput>
    /**
     * In case the SalesforceAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesforceAccountUpdateInput, SalesforceAccountUncheckedUpdateInput>
  }

  /**
   * SalesforceAccount delete
   */
  export type SalesforceAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    /**
     * Filter which SalesforceAccount to delete.
     */
    where: SalesforceAccountWhereUniqueInput
  }

  /**
   * SalesforceAccount deleteMany
   */
  export type SalesforceAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesforceAccounts to delete
     */
    where?: SalesforceAccountWhereInput
    /**
     * Limit how many SalesforceAccounts to delete.
     */
    limit?: number
  }

  /**
   * SalesforceAccount.deal
   */
  export type SalesforceAccount$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * SalesforceAccount.contacts
   */
  export type SalesforceAccount$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    where?: SalesforceContactWhereInput
    orderBy?: SalesforceContactOrderByWithRelationInput | SalesforceContactOrderByWithRelationInput[]
    cursor?: SalesforceContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceContactScalarFieldEnum | SalesforceContactScalarFieldEnum[]
  }

  /**
   * SalesforceAccount.opportunities
   */
  export type SalesforceAccount$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    where?: SalesforceOpportunityWhereInput
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    cursor?: SalesforceOpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesforceOpportunityScalarFieldEnum | SalesforceOpportunityScalarFieldEnum[]
  }

  /**
   * SalesforceAccount without action
   */
  export type SalesforceAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
  }


  /**
   * Model SalesforceContact
   */

  export type AggregateSalesforceContact = {
    _count: SalesforceContactCountAggregateOutputType | null
    _min: SalesforceContactMinAggregateOutputType | null
    _max: SalesforceContactMaxAggregateOutputType | null
  }

  export type SalesforceContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    accountId: string | null
    name: string | null
    email: string | null
    phone: string | null
    title: string | null
    department: string | null
    leadSource: string | null
    description: string | null
    ownerId: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesforceContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contactId: string | null
    accountId: string | null
    name: string | null
    email: string | null
    phone: string | null
    title: string | null
    department: string | null
    leadSource: string | null
    description: string | null
    ownerId: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesforceContactCountAggregateOutputType = {
    id: number
    userId: number
    contactId: number
    accountId: number
    name: number
    email: number
    phone: number
    title: number
    department: number
    leadSource: number
    description: number
    ownerId: number
    metadata: number
    lastSync: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesforceContactMinAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    accountId?: true
    name?: true
    email?: true
    phone?: true
    title?: true
    department?: true
    leadSource?: true
    description?: true
    ownerId?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesforceContactMaxAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    accountId?: true
    name?: true
    email?: true
    phone?: true
    title?: true
    department?: true
    leadSource?: true
    description?: true
    ownerId?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesforceContactCountAggregateInputType = {
    id?: true
    userId?: true
    contactId?: true
    accountId?: true
    name?: true
    email?: true
    phone?: true
    title?: true
    department?: true
    leadSource?: true
    description?: true
    ownerId?: true
    metadata?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesforceContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesforceContact to aggregate.
     */
    where?: SalesforceContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceContacts to fetch.
     */
    orderBy?: SalesforceContactOrderByWithRelationInput | SalesforceContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesforceContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesforceContacts
    **/
    _count?: true | SalesforceContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesforceContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesforceContactMaxAggregateInputType
  }

  export type GetSalesforceContactAggregateType<T extends SalesforceContactAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesforceContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesforceContact[P]>
      : GetScalarType<T[P], AggregateSalesforceContact[P]>
  }




  export type SalesforceContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceContactWhereInput
    orderBy?: SalesforceContactOrderByWithAggregationInput | SalesforceContactOrderByWithAggregationInput[]
    by: SalesforceContactScalarFieldEnum[] | SalesforceContactScalarFieldEnum
    having?: SalesforceContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesforceContactCountAggregateInputType | true
    _min?: SalesforceContactMinAggregateInputType
    _max?: SalesforceContactMaxAggregateInputType
  }

  export type SalesforceContactGroupByOutputType = {
    id: string
    userId: string
    contactId: string
    accountId: string | null
    name: string
    email: string | null
    phone: string | null
    title: string | null
    department: string | null
    leadSource: string | null
    description: string | null
    ownerId: string | null
    metadata: JsonValue | null
    lastSync: Date
    createdAt: Date
    updatedAt: Date
    _count: SalesforceContactCountAggregateOutputType | null
    _min: SalesforceContactMinAggregateOutputType | null
    _max: SalesforceContactMaxAggregateOutputType | null
  }

  type GetSalesforceContactGroupByPayload<T extends SalesforceContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesforceContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesforceContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesforceContactGroupByOutputType[P]>
            : GetScalarType<T[P], SalesforceContactGroupByOutputType[P]>
        }
      >
    >


  export type SalesforceContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactId?: boolean
    accountId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    department?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SalesforceContact$accountArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceContact"]>

  export type SalesforceContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactId?: boolean
    accountId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    department?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SalesforceContact$accountArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceContact"]>

  export type SalesforceContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contactId?: boolean
    accountId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    department?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SalesforceContact$accountArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceContact"]>

  export type SalesforceContactSelectScalar = {
    id?: boolean
    userId?: boolean
    contactId?: boolean
    accountId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    title?: boolean
    department?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesforceContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "contactId" | "accountId" | "name" | "email" | "phone" | "title" | "department" | "leadSource" | "description" | "ownerId" | "metadata" | "lastSync" | "createdAt" | "updatedAt", ExtArgs["result"]["salesforceContact"]>
  export type SalesforceContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SalesforceContact$accountArgs<ExtArgs>
  }
  export type SalesforceContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SalesforceContact$accountArgs<ExtArgs>
  }
  export type SalesforceContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SalesforceContact$accountArgs<ExtArgs>
  }

  export type $SalesforceContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesforceContact"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$SalesforceAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contactId: string
      accountId: string | null
      name: string
      email: string | null
      phone: string | null
      title: string | null
      department: string | null
      leadSource: string | null
      description: string | null
      ownerId: string | null
      metadata: Prisma.JsonValue | null
      lastSync: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesforceContact"]>
    composites: {}
  }

  type SalesforceContactGetPayload<S extends boolean | null | undefined | SalesforceContactDefaultArgs> = $Result.GetResult<Prisma.$SalesforceContactPayload, S>

  type SalesforceContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesforceContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesforceContactCountAggregateInputType | true
    }

  export interface SalesforceContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesforceContact'], meta: { name: 'SalesforceContact' } }
    /**
     * Find zero or one SalesforceContact that matches the filter.
     * @param {SalesforceContactFindUniqueArgs} args - Arguments to find a SalesforceContact
     * @example
     * // Get one SalesforceContact
     * const salesforceContact = await prisma.salesforceContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesforceContactFindUniqueArgs>(args: SelectSubset<T, SalesforceContactFindUniqueArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesforceContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesforceContactFindUniqueOrThrowArgs} args - Arguments to find a SalesforceContact
     * @example
     * // Get one SalesforceContact
     * const salesforceContact = await prisma.salesforceContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesforceContactFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesforceContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesforceContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactFindFirstArgs} args - Arguments to find a SalesforceContact
     * @example
     * // Get one SalesforceContact
     * const salesforceContact = await prisma.salesforceContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesforceContactFindFirstArgs>(args?: SelectSubset<T, SalesforceContactFindFirstArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesforceContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactFindFirstOrThrowArgs} args - Arguments to find a SalesforceContact
     * @example
     * // Get one SalesforceContact
     * const salesforceContact = await prisma.salesforceContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesforceContactFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesforceContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesforceContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesforceContacts
     * const salesforceContacts = await prisma.salesforceContact.findMany()
     * 
     * // Get first 10 SalesforceContacts
     * const salesforceContacts = await prisma.salesforceContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesforceContactWithIdOnly = await prisma.salesforceContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesforceContactFindManyArgs>(args?: SelectSubset<T, SalesforceContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesforceContact.
     * @param {SalesforceContactCreateArgs} args - Arguments to create a SalesforceContact.
     * @example
     * // Create one SalesforceContact
     * const SalesforceContact = await prisma.salesforceContact.create({
     *   data: {
     *     // ... data to create a SalesforceContact
     *   }
     * })
     * 
     */
    create<T extends SalesforceContactCreateArgs>(args: SelectSubset<T, SalesforceContactCreateArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesforceContacts.
     * @param {SalesforceContactCreateManyArgs} args - Arguments to create many SalesforceContacts.
     * @example
     * // Create many SalesforceContacts
     * const salesforceContact = await prisma.salesforceContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesforceContactCreateManyArgs>(args?: SelectSubset<T, SalesforceContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesforceContacts and returns the data saved in the database.
     * @param {SalesforceContactCreateManyAndReturnArgs} args - Arguments to create many SalesforceContacts.
     * @example
     * // Create many SalesforceContacts
     * const salesforceContact = await prisma.salesforceContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesforceContacts and only return the `id`
     * const salesforceContactWithIdOnly = await prisma.salesforceContact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesforceContactCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesforceContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesforceContact.
     * @param {SalesforceContactDeleteArgs} args - Arguments to delete one SalesforceContact.
     * @example
     * // Delete one SalesforceContact
     * const SalesforceContact = await prisma.salesforceContact.delete({
     *   where: {
     *     // ... filter to delete one SalesforceContact
     *   }
     * })
     * 
     */
    delete<T extends SalesforceContactDeleteArgs>(args: SelectSubset<T, SalesforceContactDeleteArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesforceContact.
     * @param {SalesforceContactUpdateArgs} args - Arguments to update one SalesforceContact.
     * @example
     * // Update one SalesforceContact
     * const salesforceContact = await prisma.salesforceContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesforceContactUpdateArgs>(args: SelectSubset<T, SalesforceContactUpdateArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesforceContacts.
     * @param {SalesforceContactDeleteManyArgs} args - Arguments to filter SalesforceContacts to delete.
     * @example
     * // Delete a few SalesforceContacts
     * const { count } = await prisma.salesforceContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesforceContactDeleteManyArgs>(args?: SelectSubset<T, SalesforceContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesforceContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesforceContacts
     * const salesforceContact = await prisma.salesforceContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesforceContactUpdateManyArgs>(args: SelectSubset<T, SalesforceContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesforceContacts and returns the data updated in the database.
     * @param {SalesforceContactUpdateManyAndReturnArgs} args - Arguments to update many SalesforceContacts.
     * @example
     * // Update many SalesforceContacts
     * const salesforceContact = await prisma.salesforceContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesforceContacts and only return the `id`
     * const salesforceContactWithIdOnly = await prisma.salesforceContact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesforceContactUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesforceContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesforceContact.
     * @param {SalesforceContactUpsertArgs} args - Arguments to update or create a SalesforceContact.
     * @example
     * // Update or create a SalesforceContact
     * const salesforceContact = await prisma.salesforceContact.upsert({
     *   create: {
     *     // ... data to create a SalesforceContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesforceContact we want to update
     *   }
     * })
     */
    upsert<T extends SalesforceContactUpsertArgs>(args: SelectSubset<T, SalesforceContactUpsertArgs<ExtArgs>>): Prisma__SalesforceContactClient<$Result.GetResult<Prisma.$SalesforceContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesforceContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactCountArgs} args - Arguments to filter SalesforceContacts to count.
     * @example
     * // Count the number of SalesforceContacts
     * const count = await prisma.salesforceContact.count({
     *   where: {
     *     // ... the filter for the SalesforceContacts we want to count
     *   }
     * })
    **/
    count<T extends SalesforceContactCountArgs>(
      args?: Subset<T, SalesforceContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesforceContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesforceContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesforceContactAggregateArgs>(args: Subset<T, SalesforceContactAggregateArgs>): Prisma.PrismaPromise<GetSalesforceContactAggregateType<T>>

    /**
     * Group by SalesforceContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesforceContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesforceContactGroupByArgs['orderBy'] }
        : { orderBy?: SalesforceContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesforceContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesforceContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesforceContact model
   */
  readonly fields: SalesforceContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesforceContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesforceContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends SalesforceContact$accountArgs<ExtArgs> = {}>(args?: Subset<T, SalesforceContact$accountArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesforceContact model
   */
  interface SalesforceContactFieldRefs {
    readonly id: FieldRef<"SalesforceContact", 'String'>
    readonly userId: FieldRef<"SalesforceContact", 'String'>
    readonly contactId: FieldRef<"SalesforceContact", 'String'>
    readonly accountId: FieldRef<"SalesforceContact", 'String'>
    readonly name: FieldRef<"SalesforceContact", 'String'>
    readonly email: FieldRef<"SalesforceContact", 'String'>
    readonly phone: FieldRef<"SalesforceContact", 'String'>
    readonly title: FieldRef<"SalesforceContact", 'String'>
    readonly department: FieldRef<"SalesforceContact", 'String'>
    readonly leadSource: FieldRef<"SalesforceContact", 'String'>
    readonly description: FieldRef<"SalesforceContact", 'String'>
    readonly ownerId: FieldRef<"SalesforceContact", 'String'>
    readonly metadata: FieldRef<"SalesforceContact", 'Json'>
    readonly lastSync: FieldRef<"SalesforceContact", 'DateTime'>
    readonly createdAt: FieldRef<"SalesforceContact", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesforceContact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesforceContact findUnique
   */
  export type SalesforceContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceContact to fetch.
     */
    where: SalesforceContactWhereUniqueInput
  }

  /**
   * SalesforceContact findUniqueOrThrow
   */
  export type SalesforceContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceContact to fetch.
     */
    where: SalesforceContactWhereUniqueInput
  }

  /**
   * SalesforceContact findFirst
   */
  export type SalesforceContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceContact to fetch.
     */
    where?: SalesforceContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceContacts to fetch.
     */
    orderBy?: SalesforceContactOrderByWithRelationInput | SalesforceContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesforceContacts.
     */
    cursor?: SalesforceContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesforceContacts.
     */
    distinct?: SalesforceContactScalarFieldEnum | SalesforceContactScalarFieldEnum[]
  }

  /**
   * SalesforceContact findFirstOrThrow
   */
  export type SalesforceContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceContact to fetch.
     */
    where?: SalesforceContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceContacts to fetch.
     */
    orderBy?: SalesforceContactOrderByWithRelationInput | SalesforceContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesforceContacts.
     */
    cursor?: SalesforceContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesforceContacts.
     */
    distinct?: SalesforceContactScalarFieldEnum | SalesforceContactScalarFieldEnum[]
  }

  /**
   * SalesforceContact findMany
   */
  export type SalesforceContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceContacts to fetch.
     */
    where?: SalesforceContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceContacts to fetch.
     */
    orderBy?: SalesforceContactOrderByWithRelationInput | SalesforceContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesforceContacts.
     */
    cursor?: SalesforceContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceContacts.
     */
    skip?: number
    distinct?: SalesforceContactScalarFieldEnum | SalesforceContactScalarFieldEnum[]
  }

  /**
   * SalesforceContact create
   */
  export type SalesforceContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesforceContact.
     */
    data: XOR<SalesforceContactCreateInput, SalesforceContactUncheckedCreateInput>
  }

  /**
   * SalesforceContact createMany
   */
  export type SalesforceContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesforceContacts.
     */
    data: SalesforceContactCreateManyInput | SalesforceContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesforceContact createManyAndReturn
   */
  export type SalesforceContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * The data used to create many SalesforceContacts.
     */
    data: SalesforceContactCreateManyInput | SalesforceContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesforceContact update
   */
  export type SalesforceContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesforceContact.
     */
    data: XOR<SalesforceContactUpdateInput, SalesforceContactUncheckedUpdateInput>
    /**
     * Choose, which SalesforceContact to update.
     */
    where: SalesforceContactWhereUniqueInput
  }

  /**
   * SalesforceContact updateMany
   */
  export type SalesforceContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesforceContacts.
     */
    data: XOR<SalesforceContactUpdateManyMutationInput, SalesforceContactUncheckedUpdateManyInput>
    /**
     * Filter which SalesforceContacts to update
     */
    where?: SalesforceContactWhereInput
    /**
     * Limit how many SalesforceContacts to update.
     */
    limit?: number
  }

  /**
   * SalesforceContact updateManyAndReturn
   */
  export type SalesforceContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * The data used to update SalesforceContacts.
     */
    data: XOR<SalesforceContactUpdateManyMutationInput, SalesforceContactUncheckedUpdateManyInput>
    /**
     * Filter which SalesforceContacts to update
     */
    where?: SalesforceContactWhereInput
    /**
     * Limit how many SalesforceContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesforceContact upsert
   */
  export type SalesforceContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesforceContact to update in case it exists.
     */
    where: SalesforceContactWhereUniqueInput
    /**
     * In case the SalesforceContact found by the `where` argument doesn't exist, create a new SalesforceContact with this data.
     */
    create: XOR<SalesforceContactCreateInput, SalesforceContactUncheckedCreateInput>
    /**
     * In case the SalesforceContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesforceContactUpdateInput, SalesforceContactUncheckedUpdateInput>
  }

  /**
   * SalesforceContact delete
   */
  export type SalesforceContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
    /**
     * Filter which SalesforceContact to delete.
     */
    where: SalesforceContactWhereUniqueInput
  }

  /**
   * SalesforceContact deleteMany
   */
  export type SalesforceContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesforceContacts to delete
     */
    where?: SalesforceContactWhereInput
    /**
     * Limit how many SalesforceContacts to delete.
     */
    limit?: number
  }

  /**
   * SalesforceContact.account
   */
  export type SalesforceContact$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    where?: SalesforceAccountWhereInput
  }

  /**
   * SalesforceContact without action
   */
  export type SalesforceContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceContact
     */
    select?: SalesforceContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceContact
     */
    omit?: SalesforceContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceContactInclude<ExtArgs> | null
  }


  /**
   * Model SalesforceOpportunity
   */

  export type AggregateSalesforceOpportunity = {
    _count: SalesforceOpportunityCountAggregateOutputType | null
    _avg: SalesforceOpportunityAvgAggregateOutputType | null
    _sum: SalesforceOpportunitySumAggregateOutputType | null
    _min: SalesforceOpportunityMinAggregateOutputType | null
    _max: SalesforceOpportunityMaxAggregateOutputType | null
  }

  export type SalesforceOpportunityAvgAggregateOutputType = {
    amount: number | null
    probability: number | null
  }

  export type SalesforceOpportunitySumAggregateOutputType = {
    amount: number | null
    probability: number | null
  }

  export type SalesforceOpportunityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    opportunityId: string | null
    accountId: string | null
    name: string | null
    amount: number | null
    stage: string | null
    probability: number | null
    closeDate: Date | null
    type: string | null
    leadSource: string | null
    description: string | null
    ownerId: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesforceOpportunityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    dealId: string | null
    opportunityId: string | null
    accountId: string | null
    name: string | null
    amount: number | null
    stage: string | null
    probability: number | null
    closeDate: Date | null
    type: string | null
    leadSource: string | null
    description: string | null
    ownerId: string | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesforceOpportunityCountAggregateOutputType = {
    id: number
    userId: number
    dealId: number
    opportunityId: number
    accountId: number
    name: number
    amount: number
    stage: number
    probability: number
    closeDate: number
    type: number
    leadSource: number
    description: number
    ownerId: number
    metadata: number
    lastSync: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesforceOpportunityAvgAggregateInputType = {
    amount?: true
    probability?: true
  }

  export type SalesforceOpportunitySumAggregateInputType = {
    amount?: true
    probability?: true
  }

  export type SalesforceOpportunityMinAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    opportunityId?: true
    accountId?: true
    name?: true
    amount?: true
    stage?: true
    probability?: true
    closeDate?: true
    type?: true
    leadSource?: true
    description?: true
    ownerId?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesforceOpportunityMaxAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    opportunityId?: true
    accountId?: true
    name?: true
    amount?: true
    stage?: true
    probability?: true
    closeDate?: true
    type?: true
    leadSource?: true
    description?: true
    ownerId?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesforceOpportunityCountAggregateInputType = {
    id?: true
    userId?: true
    dealId?: true
    opportunityId?: true
    accountId?: true
    name?: true
    amount?: true
    stage?: true
    probability?: true
    closeDate?: true
    type?: true
    leadSource?: true
    description?: true
    ownerId?: true
    metadata?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesforceOpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesforceOpportunity to aggregate.
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceOpportunities to fetch.
     */
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesforceOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesforceOpportunities
    **/
    _count?: true | SalesforceOpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesforceOpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesforceOpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesforceOpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesforceOpportunityMaxAggregateInputType
  }

  export type GetSalesforceOpportunityAggregateType<T extends SalesforceOpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesforceOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesforceOpportunity[P]>
      : GetScalarType<T[P], AggregateSalesforceOpportunity[P]>
  }




  export type SalesforceOpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesforceOpportunityWhereInput
    orderBy?: SalesforceOpportunityOrderByWithAggregationInput | SalesforceOpportunityOrderByWithAggregationInput[]
    by: SalesforceOpportunityScalarFieldEnum[] | SalesforceOpportunityScalarFieldEnum
    having?: SalesforceOpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesforceOpportunityCountAggregateInputType | true
    _avg?: SalesforceOpportunityAvgAggregateInputType
    _sum?: SalesforceOpportunitySumAggregateInputType
    _min?: SalesforceOpportunityMinAggregateInputType
    _max?: SalesforceOpportunityMaxAggregateInputType
  }

  export type SalesforceOpportunityGroupByOutputType = {
    id: string
    userId: string
    dealId: string | null
    opportunityId: string
    accountId: string | null
    name: string
    amount: number | null
    stage: string
    probability: number | null
    closeDate: Date | null
    type: string | null
    leadSource: string | null
    description: string | null
    ownerId: string | null
    metadata: JsonValue | null
    lastSync: Date
    createdAt: Date
    updatedAt: Date
    _count: SalesforceOpportunityCountAggregateOutputType | null
    _avg: SalesforceOpportunityAvgAggregateOutputType | null
    _sum: SalesforceOpportunitySumAggregateOutputType | null
    _min: SalesforceOpportunityMinAggregateOutputType | null
    _max: SalesforceOpportunityMaxAggregateOutputType | null
  }

  type GetSalesforceOpportunityGroupByPayload<T extends SalesforceOpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesforceOpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesforceOpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesforceOpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], SalesforceOpportunityGroupByOutputType[P]>
        }
      >
    >


  export type SalesforceOpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    opportunityId?: boolean
    accountId?: boolean
    name?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    type?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceOpportunity$dealArgs<ExtArgs>
    account?: boolean | SalesforceOpportunity$accountArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceOpportunity"]>

  export type SalesforceOpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    opportunityId?: boolean
    accountId?: boolean
    name?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    type?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceOpportunity$dealArgs<ExtArgs>
    account?: boolean | SalesforceOpportunity$accountArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceOpportunity"]>

  export type SalesforceOpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dealId?: boolean
    opportunityId?: boolean
    accountId?: boolean
    name?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    type?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceOpportunity$dealArgs<ExtArgs>
    account?: boolean | SalesforceOpportunity$accountArgs<ExtArgs>
  }, ExtArgs["result"]["salesforceOpportunity"]>

  export type SalesforceOpportunitySelectScalar = {
    id?: boolean
    userId?: boolean
    dealId?: boolean
    opportunityId?: boolean
    accountId?: boolean
    name?: boolean
    amount?: boolean
    stage?: boolean
    probability?: boolean
    closeDate?: boolean
    type?: boolean
    leadSource?: boolean
    description?: boolean
    ownerId?: boolean
    metadata?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesforceOpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dealId" | "opportunityId" | "accountId" | "name" | "amount" | "stage" | "probability" | "closeDate" | "type" | "leadSource" | "description" | "ownerId" | "metadata" | "lastSync" | "createdAt" | "updatedAt", ExtArgs["result"]["salesforceOpportunity"]>
  export type SalesforceOpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceOpportunity$dealArgs<ExtArgs>
    account?: boolean | SalesforceOpportunity$accountArgs<ExtArgs>
  }
  export type SalesforceOpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceOpportunity$dealArgs<ExtArgs>
    account?: boolean | SalesforceOpportunity$accountArgs<ExtArgs>
  }
  export type SalesforceOpportunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    deal?: boolean | SalesforceOpportunity$dealArgs<ExtArgs>
    account?: boolean | SalesforceOpportunity$accountArgs<ExtArgs>
  }

  export type $SalesforceOpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesforceOpportunity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      account: Prisma.$SalesforceAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      dealId: string | null
      opportunityId: string
      accountId: string | null
      name: string
      amount: number | null
      stage: string
      probability: number | null
      closeDate: Date | null
      type: string | null
      leadSource: string | null
      description: string | null
      ownerId: string | null
      metadata: Prisma.JsonValue | null
      lastSync: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesforceOpportunity"]>
    composites: {}
  }

  type SalesforceOpportunityGetPayload<S extends boolean | null | undefined | SalesforceOpportunityDefaultArgs> = $Result.GetResult<Prisma.$SalesforceOpportunityPayload, S>

  type SalesforceOpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesforceOpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesforceOpportunityCountAggregateInputType | true
    }

  export interface SalesforceOpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesforceOpportunity'], meta: { name: 'SalesforceOpportunity' } }
    /**
     * Find zero or one SalesforceOpportunity that matches the filter.
     * @param {SalesforceOpportunityFindUniqueArgs} args - Arguments to find a SalesforceOpportunity
     * @example
     * // Get one SalesforceOpportunity
     * const salesforceOpportunity = await prisma.salesforceOpportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesforceOpportunityFindUniqueArgs>(args: SelectSubset<T, SalesforceOpportunityFindUniqueArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesforceOpportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesforceOpportunityFindUniqueOrThrowArgs} args - Arguments to find a SalesforceOpportunity
     * @example
     * // Get one SalesforceOpportunity
     * const salesforceOpportunity = await prisma.salesforceOpportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesforceOpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesforceOpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesforceOpportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityFindFirstArgs} args - Arguments to find a SalesforceOpportunity
     * @example
     * // Get one SalesforceOpportunity
     * const salesforceOpportunity = await prisma.salesforceOpportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesforceOpportunityFindFirstArgs>(args?: SelectSubset<T, SalesforceOpportunityFindFirstArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesforceOpportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityFindFirstOrThrowArgs} args - Arguments to find a SalesforceOpportunity
     * @example
     * // Get one SalesforceOpportunity
     * const salesforceOpportunity = await prisma.salesforceOpportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesforceOpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesforceOpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesforceOpportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesforceOpportunities
     * const salesforceOpportunities = await prisma.salesforceOpportunity.findMany()
     * 
     * // Get first 10 SalesforceOpportunities
     * const salesforceOpportunities = await prisma.salesforceOpportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesforceOpportunityWithIdOnly = await prisma.salesforceOpportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesforceOpportunityFindManyArgs>(args?: SelectSubset<T, SalesforceOpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesforceOpportunity.
     * @param {SalesforceOpportunityCreateArgs} args - Arguments to create a SalesforceOpportunity.
     * @example
     * // Create one SalesforceOpportunity
     * const SalesforceOpportunity = await prisma.salesforceOpportunity.create({
     *   data: {
     *     // ... data to create a SalesforceOpportunity
     *   }
     * })
     * 
     */
    create<T extends SalesforceOpportunityCreateArgs>(args: SelectSubset<T, SalesforceOpportunityCreateArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesforceOpportunities.
     * @param {SalesforceOpportunityCreateManyArgs} args - Arguments to create many SalesforceOpportunities.
     * @example
     * // Create many SalesforceOpportunities
     * const salesforceOpportunity = await prisma.salesforceOpportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesforceOpportunityCreateManyArgs>(args?: SelectSubset<T, SalesforceOpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesforceOpportunities and returns the data saved in the database.
     * @param {SalesforceOpportunityCreateManyAndReturnArgs} args - Arguments to create many SalesforceOpportunities.
     * @example
     * // Create many SalesforceOpportunities
     * const salesforceOpportunity = await prisma.salesforceOpportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesforceOpportunities and only return the `id`
     * const salesforceOpportunityWithIdOnly = await prisma.salesforceOpportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesforceOpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesforceOpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesforceOpportunity.
     * @param {SalesforceOpportunityDeleteArgs} args - Arguments to delete one SalesforceOpportunity.
     * @example
     * // Delete one SalesforceOpportunity
     * const SalesforceOpportunity = await prisma.salesforceOpportunity.delete({
     *   where: {
     *     // ... filter to delete one SalesforceOpportunity
     *   }
     * })
     * 
     */
    delete<T extends SalesforceOpportunityDeleteArgs>(args: SelectSubset<T, SalesforceOpportunityDeleteArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesforceOpportunity.
     * @param {SalesforceOpportunityUpdateArgs} args - Arguments to update one SalesforceOpportunity.
     * @example
     * // Update one SalesforceOpportunity
     * const salesforceOpportunity = await prisma.salesforceOpportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesforceOpportunityUpdateArgs>(args: SelectSubset<T, SalesforceOpportunityUpdateArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesforceOpportunities.
     * @param {SalesforceOpportunityDeleteManyArgs} args - Arguments to filter SalesforceOpportunities to delete.
     * @example
     * // Delete a few SalesforceOpportunities
     * const { count } = await prisma.salesforceOpportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesforceOpportunityDeleteManyArgs>(args?: SelectSubset<T, SalesforceOpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesforceOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesforceOpportunities
     * const salesforceOpportunity = await prisma.salesforceOpportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesforceOpportunityUpdateManyArgs>(args: SelectSubset<T, SalesforceOpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesforceOpportunities and returns the data updated in the database.
     * @param {SalesforceOpportunityUpdateManyAndReturnArgs} args - Arguments to update many SalesforceOpportunities.
     * @example
     * // Update many SalesforceOpportunities
     * const salesforceOpportunity = await prisma.salesforceOpportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesforceOpportunities and only return the `id`
     * const salesforceOpportunityWithIdOnly = await prisma.salesforceOpportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesforceOpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesforceOpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesforceOpportunity.
     * @param {SalesforceOpportunityUpsertArgs} args - Arguments to update or create a SalesforceOpportunity.
     * @example
     * // Update or create a SalesforceOpportunity
     * const salesforceOpportunity = await prisma.salesforceOpportunity.upsert({
     *   create: {
     *     // ... data to create a SalesforceOpportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesforceOpportunity we want to update
     *   }
     * })
     */
    upsert<T extends SalesforceOpportunityUpsertArgs>(args: SelectSubset<T, SalesforceOpportunityUpsertArgs<ExtArgs>>): Prisma__SalesforceOpportunityClient<$Result.GetResult<Prisma.$SalesforceOpportunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesforceOpportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityCountArgs} args - Arguments to filter SalesforceOpportunities to count.
     * @example
     * // Count the number of SalesforceOpportunities
     * const count = await prisma.salesforceOpportunity.count({
     *   where: {
     *     // ... the filter for the SalesforceOpportunities we want to count
     *   }
     * })
    **/
    count<T extends SalesforceOpportunityCountArgs>(
      args?: Subset<T, SalesforceOpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesforceOpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesforceOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesforceOpportunityAggregateArgs>(args: Subset<T, SalesforceOpportunityAggregateArgs>): Prisma.PrismaPromise<GetSalesforceOpportunityAggregateType<T>>

    /**
     * Group by SalesforceOpportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesforceOpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesforceOpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesforceOpportunityGroupByArgs['orderBy'] }
        : { orderBy?: SalesforceOpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesforceOpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesforceOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesforceOpportunity model
   */
  readonly fields: SalesforceOpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesforceOpportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesforceOpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends SalesforceOpportunity$dealArgs<ExtArgs> = {}>(args?: Subset<T, SalesforceOpportunity$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    account<T extends SalesforceOpportunity$accountArgs<ExtArgs> = {}>(args?: Subset<T, SalesforceOpportunity$accountArgs<ExtArgs>>): Prisma__SalesforceAccountClient<$Result.GetResult<Prisma.$SalesforceAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesforceOpportunity model
   */
  interface SalesforceOpportunityFieldRefs {
    readonly id: FieldRef<"SalesforceOpportunity", 'String'>
    readonly userId: FieldRef<"SalesforceOpportunity", 'String'>
    readonly dealId: FieldRef<"SalesforceOpportunity", 'String'>
    readonly opportunityId: FieldRef<"SalesforceOpportunity", 'String'>
    readonly accountId: FieldRef<"SalesforceOpportunity", 'String'>
    readonly name: FieldRef<"SalesforceOpportunity", 'String'>
    readonly amount: FieldRef<"SalesforceOpportunity", 'Float'>
    readonly stage: FieldRef<"SalesforceOpportunity", 'String'>
    readonly probability: FieldRef<"SalesforceOpportunity", 'Float'>
    readonly closeDate: FieldRef<"SalesforceOpportunity", 'DateTime'>
    readonly type: FieldRef<"SalesforceOpportunity", 'String'>
    readonly leadSource: FieldRef<"SalesforceOpportunity", 'String'>
    readonly description: FieldRef<"SalesforceOpportunity", 'String'>
    readonly ownerId: FieldRef<"SalesforceOpportunity", 'String'>
    readonly metadata: FieldRef<"SalesforceOpportunity", 'Json'>
    readonly lastSync: FieldRef<"SalesforceOpportunity", 'DateTime'>
    readonly createdAt: FieldRef<"SalesforceOpportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesforceOpportunity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesforceOpportunity findUnique
   */
  export type SalesforceOpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceOpportunity to fetch.
     */
    where: SalesforceOpportunityWhereUniqueInput
  }

  /**
   * SalesforceOpportunity findUniqueOrThrow
   */
  export type SalesforceOpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceOpportunity to fetch.
     */
    where: SalesforceOpportunityWhereUniqueInput
  }

  /**
   * SalesforceOpportunity findFirst
   */
  export type SalesforceOpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceOpportunity to fetch.
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceOpportunities to fetch.
     */
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesforceOpportunities.
     */
    cursor?: SalesforceOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesforceOpportunities.
     */
    distinct?: SalesforceOpportunityScalarFieldEnum | SalesforceOpportunityScalarFieldEnum[]
  }

  /**
   * SalesforceOpportunity findFirstOrThrow
   */
  export type SalesforceOpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceOpportunity to fetch.
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceOpportunities to fetch.
     */
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesforceOpportunities.
     */
    cursor?: SalesforceOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceOpportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesforceOpportunities.
     */
    distinct?: SalesforceOpportunityScalarFieldEnum | SalesforceOpportunityScalarFieldEnum[]
  }

  /**
   * SalesforceOpportunity findMany
   */
  export type SalesforceOpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * Filter, which SalesforceOpportunities to fetch.
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesforceOpportunities to fetch.
     */
    orderBy?: SalesforceOpportunityOrderByWithRelationInput | SalesforceOpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesforceOpportunities.
     */
    cursor?: SalesforceOpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesforceOpportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesforceOpportunities.
     */
    skip?: number
    distinct?: SalesforceOpportunityScalarFieldEnum | SalesforceOpportunityScalarFieldEnum[]
  }

  /**
   * SalesforceOpportunity create
   */
  export type SalesforceOpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesforceOpportunity.
     */
    data: XOR<SalesforceOpportunityCreateInput, SalesforceOpportunityUncheckedCreateInput>
  }

  /**
   * SalesforceOpportunity createMany
   */
  export type SalesforceOpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesforceOpportunities.
     */
    data: SalesforceOpportunityCreateManyInput | SalesforceOpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesforceOpportunity createManyAndReturn
   */
  export type SalesforceOpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many SalesforceOpportunities.
     */
    data: SalesforceOpportunityCreateManyInput | SalesforceOpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesforceOpportunity update
   */
  export type SalesforceOpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesforceOpportunity.
     */
    data: XOR<SalesforceOpportunityUpdateInput, SalesforceOpportunityUncheckedUpdateInput>
    /**
     * Choose, which SalesforceOpportunity to update.
     */
    where: SalesforceOpportunityWhereUniqueInput
  }

  /**
   * SalesforceOpportunity updateMany
   */
  export type SalesforceOpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesforceOpportunities.
     */
    data: XOR<SalesforceOpportunityUpdateManyMutationInput, SalesforceOpportunityUncheckedUpdateManyInput>
    /**
     * Filter which SalesforceOpportunities to update
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * Limit how many SalesforceOpportunities to update.
     */
    limit?: number
  }

  /**
   * SalesforceOpportunity updateManyAndReturn
   */
  export type SalesforceOpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * The data used to update SalesforceOpportunities.
     */
    data: XOR<SalesforceOpportunityUpdateManyMutationInput, SalesforceOpportunityUncheckedUpdateManyInput>
    /**
     * Filter which SalesforceOpportunities to update
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * Limit how many SalesforceOpportunities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesforceOpportunity upsert
   */
  export type SalesforceOpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesforceOpportunity to update in case it exists.
     */
    where: SalesforceOpportunityWhereUniqueInput
    /**
     * In case the SalesforceOpportunity found by the `where` argument doesn't exist, create a new SalesforceOpportunity with this data.
     */
    create: XOR<SalesforceOpportunityCreateInput, SalesforceOpportunityUncheckedCreateInput>
    /**
     * In case the SalesforceOpportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesforceOpportunityUpdateInput, SalesforceOpportunityUncheckedUpdateInput>
  }

  /**
   * SalesforceOpportunity delete
   */
  export type SalesforceOpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
    /**
     * Filter which SalesforceOpportunity to delete.
     */
    where: SalesforceOpportunityWhereUniqueInput
  }

  /**
   * SalesforceOpportunity deleteMany
   */
  export type SalesforceOpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesforceOpportunities to delete
     */
    where?: SalesforceOpportunityWhereInput
    /**
     * Limit how many SalesforceOpportunities to delete.
     */
    limit?: number
  }

  /**
   * SalesforceOpportunity.deal
   */
  export type SalesforceOpportunity$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * SalesforceOpportunity.account
   */
  export type SalesforceOpportunity$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceAccount
     */
    select?: SalesforceAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceAccount
     */
    omit?: SalesforceAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceAccountInclude<ExtArgs> | null
    where?: SalesforceAccountWhereInput
  }

  /**
   * SalesforceOpportunity without action
   */
  export type SalesforceOpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesforceOpportunity
     */
    select?: SalesforceOpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesforceOpportunity
     */
    omit?: SalesforceOpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesforceOpportunityInclude<ExtArgs> | null
  }


  /**
   * Model LPGroup
   */

  export type AggregateLPGroup = {
    _count: LPGroupCountAggregateOutputType | null
    _min: LPGroupMinAggregateOutputType | null
    _max: LPGroupMaxAggregateOutputType | null
  }

  export type LPGroupMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    autoAssign: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LPGroupMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    type: string | null
    autoAssign: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LPGroupCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    type: number
    criteria: number
    autoAssign: number
    emailPreferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LPGroupMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    autoAssign?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LPGroupMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    autoAssign?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LPGroupCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    type?: true
    criteria?: true
    autoAssign?: true
    emailPreferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LPGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LPGroup to aggregate.
     */
    where?: LPGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LPGroups to fetch.
     */
    orderBy?: LPGroupOrderByWithRelationInput | LPGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LPGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LPGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LPGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LPGroups
    **/
    _count?: true | LPGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LPGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LPGroupMaxAggregateInputType
  }

  export type GetLPGroupAggregateType<T extends LPGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateLPGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLPGroup[P]>
      : GetScalarType<T[P], AggregateLPGroup[P]>
  }




  export type LPGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LPGroupWhereInput
    orderBy?: LPGroupOrderByWithAggregationInput | LPGroupOrderByWithAggregationInput[]
    by: LPGroupScalarFieldEnum[] | LPGroupScalarFieldEnum
    having?: LPGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LPGroupCountAggregateInputType | true
    _min?: LPGroupMinAggregateInputType
    _max?: LPGroupMaxAggregateInputType
  }

  export type LPGroupGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    type: string
    criteria: JsonValue | null
    autoAssign: boolean
    emailPreferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LPGroupCountAggregateOutputType | null
    _min: LPGroupMinAggregateOutputType | null
    _max: LPGroupMaxAggregateOutputType | null
  }

  type GetLPGroupGroupByPayload<T extends LPGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LPGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LPGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LPGroupGroupByOutputType[P]>
            : GetScalarType<T[P], LPGroupGroupByOutputType[P]>
        }
      >
    >


  export type LPGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    criteria?: boolean
    autoAssign?: boolean
    emailPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | LPGroup$membersArgs<ExtArgs>
    _count?: boolean | LPGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lPGroup"]>

  export type LPGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    criteria?: boolean
    autoAssign?: boolean
    emailPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lPGroup"]>

  export type LPGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    criteria?: boolean
    autoAssign?: boolean
    emailPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lPGroup"]>

  export type LPGroupSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    criteria?: boolean
    autoAssign?: boolean
    emailPreferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LPGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "type" | "criteria" | "autoAssign" | "emailPreferences" | "createdAt" | "updatedAt", ExtArgs["result"]["lPGroup"]>
  export type LPGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | LPGroup$membersArgs<ExtArgs>
    _count?: boolean | LPGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LPGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LPGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LPGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LPGroup"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$InvestorGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      type: string
      criteria: Prisma.JsonValue | null
      autoAssign: boolean
      emailPreferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lPGroup"]>
    composites: {}
  }

  type LPGroupGetPayload<S extends boolean | null | undefined | LPGroupDefaultArgs> = $Result.GetResult<Prisma.$LPGroupPayload, S>

  type LPGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LPGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LPGroupCountAggregateInputType | true
    }

  export interface LPGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LPGroup'], meta: { name: 'LPGroup' } }
    /**
     * Find zero or one LPGroup that matches the filter.
     * @param {LPGroupFindUniqueArgs} args - Arguments to find a LPGroup
     * @example
     * // Get one LPGroup
     * const lPGroup = await prisma.lPGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LPGroupFindUniqueArgs>(args: SelectSubset<T, LPGroupFindUniqueArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LPGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LPGroupFindUniqueOrThrowArgs} args - Arguments to find a LPGroup
     * @example
     * // Get one LPGroup
     * const lPGroup = await prisma.lPGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LPGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, LPGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LPGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupFindFirstArgs} args - Arguments to find a LPGroup
     * @example
     * // Get one LPGroup
     * const lPGroup = await prisma.lPGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LPGroupFindFirstArgs>(args?: SelectSubset<T, LPGroupFindFirstArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LPGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupFindFirstOrThrowArgs} args - Arguments to find a LPGroup
     * @example
     * // Get one LPGroup
     * const lPGroup = await prisma.lPGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LPGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, LPGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LPGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LPGroups
     * const lPGroups = await prisma.lPGroup.findMany()
     * 
     * // Get first 10 LPGroups
     * const lPGroups = await prisma.lPGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lPGroupWithIdOnly = await prisma.lPGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LPGroupFindManyArgs>(args?: SelectSubset<T, LPGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LPGroup.
     * @param {LPGroupCreateArgs} args - Arguments to create a LPGroup.
     * @example
     * // Create one LPGroup
     * const LPGroup = await prisma.lPGroup.create({
     *   data: {
     *     // ... data to create a LPGroup
     *   }
     * })
     * 
     */
    create<T extends LPGroupCreateArgs>(args: SelectSubset<T, LPGroupCreateArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LPGroups.
     * @param {LPGroupCreateManyArgs} args - Arguments to create many LPGroups.
     * @example
     * // Create many LPGroups
     * const lPGroup = await prisma.lPGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LPGroupCreateManyArgs>(args?: SelectSubset<T, LPGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LPGroups and returns the data saved in the database.
     * @param {LPGroupCreateManyAndReturnArgs} args - Arguments to create many LPGroups.
     * @example
     * // Create many LPGroups
     * const lPGroup = await prisma.lPGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LPGroups and only return the `id`
     * const lPGroupWithIdOnly = await prisma.lPGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LPGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, LPGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LPGroup.
     * @param {LPGroupDeleteArgs} args - Arguments to delete one LPGroup.
     * @example
     * // Delete one LPGroup
     * const LPGroup = await prisma.lPGroup.delete({
     *   where: {
     *     // ... filter to delete one LPGroup
     *   }
     * })
     * 
     */
    delete<T extends LPGroupDeleteArgs>(args: SelectSubset<T, LPGroupDeleteArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LPGroup.
     * @param {LPGroupUpdateArgs} args - Arguments to update one LPGroup.
     * @example
     * // Update one LPGroup
     * const lPGroup = await prisma.lPGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LPGroupUpdateArgs>(args: SelectSubset<T, LPGroupUpdateArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LPGroups.
     * @param {LPGroupDeleteManyArgs} args - Arguments to filter LPGroups to delete.
     * @example
     * // Delete a few LPGroups
     * const { count } = await prisma.lPGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LPGroupDeleteManyArgs>(args?: SelectSubset<T, LPGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LPGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LPGroups
     * const lPGroup = await prisma.lPGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LPGroupUpdateManyArgs>(args: SelectSubset<T, LPGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LPGroups and returns the data updated in the database.
     * @param {LPGroupUpdateManyAndReturnArgs} args - Arguments to update many LPGroups.
     * @example
     * // Update many LPGroups
     * const lPGroup = await prisma.lPGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LPGroups and only return the `id`
     * const lPGroupWithIdOnly = await prisma.lPGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LPGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, LPGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LPGroup.
     * @param {LPGroupUpsertArgs} args - Arguments to update or create a LPGroup.
     * @example
     * // Update or create a LPGroup
     * const lPGroup = await prisma.lPGroup.upsert({
     *   create: {
     *     // ... data to create a LPGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LPGroup we want to update
     *   }
     * })
     */
    upsert<T extends LPGroupUpsertArgs>(args: SelectSubset<T, LPGroupUpsertArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LPGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupCountArgs} args - Arguments to filter LPGroups to count.
     * @example
     * // Count the number of LPGroups
     * const count = await prisma.lPGroup.count({
     *   where: {
     *     // ... the filter for the LPGroups we want to count
     *   }
     * })
    **/
    count<T extends LPGroupCountArgs>(
      args?: Subset<T, LPGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LPGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LPGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LPGroupAggregateArgs>(args: Subset<T, LPGroupAggregateArgs>): Prisma.PrismaPromise<GetLPGroupAggregateType<T>>

    /**
     * Group by LPGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LPGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LPGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LPGroupGroupByArgs['orderBy'] }
        : { orderBy?: LPGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LPGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLPGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LPGroup model
   */
  readonly fields: LPGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LPGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LPGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends LPGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, LPGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LPGroup model
   */
  interface LPGroupFieldRefs {
    readonly id: FieldRef<"LPGroup", 'String'>
    readonly userId: FieldRef<"LPGroup", 'String'>
    readonly name: FieldRef<"LPGroup", 'String'>
    readonly description: FieldRef<"LPGroup", 'String'>
    readonly type: FieldRef<"LPGroup", 'String'>
    readonly criteria: FieldRef<"LPGroup", 'Json'>
    readonly autoAssign: FieldRef<"LPGroup", 'Boolean'>
    readonly emailPreferences: FieldRef<"LPGroup", 'Json'>
    readonly createdAt: FieldRef<"LPGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"LPGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LPGroup findUnique
   */
  export type LPGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * Filter, which LPGroup to fetch.
     */
    where: LPGroupWhereUniqueInput
  }

  /**
   * LPGroup findUniqueOrThrow
   */
  export type LPGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * Filter, which LPGroup to fetch.
     */
    where: LPGroupWhereUniqueInput
  }

  /**
   * LPGroup findFirst
   */
  export type LPGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * Filter, which LPGroup to fetch.
     */
    where?: LPGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LPGroups to fetch.
     */
    orderBy?: LPGroupOrderByWithRelationInput | LPGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LPGroups.
     */
    cursor?: LPGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LPGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LPGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LPGroups.
     */
    distinct?: LPGroupScalarFieldEnum | LPGroupScalarFieldEnum[]
  }

  /**
   * LPGroup findFirstOrThrow
   */
  export type LPGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * Filter, which LPGroup to fetch.
     */
    where?: LPGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LPGroups to fetch.
     */
    orderBy?: LPGroupOrderByWithRelationInput | LPGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LPGroups.
     */
    cursor?: LPGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LPGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LPGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LPGroups.
     */
    distinct?: LPGroupScalarFieldEnum | LPGroupScalarFieldEnum[]
  }

  /**
   * LPGroup findMany
   */
  export type LPGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * Filter, which LPGroups to fetch.
     */
    where?: LPGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LPGroups to fetch.
     */
    orderBy?: LPGroupOrderByWithRelationInput | LPGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LPGroups.
     */
    cursor?: LPGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LPGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LPGroups.
     */
    skip?: number
    distinct?: LPGroupScalarFieldEnum | LPGroupScalarFieldEnum[]
  }

  /**
   * LPGroup create
   */
  export type LPGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a LPGroup.
     */
    data: XOR<LPGroupCreateInput, LPGroupUncheckedCreateInput>
  }

  /**
   * LPGroup createMany
   */
  export type LPGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LPGroups.
     */
    data: LPGroupCreateManyInput | LPGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LPGroup createManyAndReturn
   */
  export type LPGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * The data used to create many LPGroups.
     */
    data: LPGroupCreateManyInput | LPGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LPGroup update
   */
  export type LPGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a LPGroup.
     */
    data: XOR<LPGroupUpdateInput, LPGroupUncheckedUpdateInput>
    /**
     * Choose, which LPGroup to update.
     */
    where: LPGroupWhereUniqueInput
  }

  /**
   * LPGroup updateMany
   */
  export type LPGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LPGroups.
     */
    data: XOR<LPGroupUpdateManyMutationInput, LPGroupUncheckedUpdateManyInput>
    /**
     * Filter which LPGroups to update
     */
    where?: LPGroupWhereInput
    /**
     * Limit how many LPGroups to update.
     */
    limit?: number
  }

  /**
   * LPGroup updateManyAndReturn
   */
  export type LPGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * The data used to update LPGroups.
     */
    data: XOR<LPGroupUpdateManyMutationInput, LPGroupUncheckedUpdateManyInput>
    /**
     * Filter which LPGroups to update
     */
    where?: LPGroupWhereInput
    /**
     * Limit how many LPGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LPGroup upsert
   */
  export type LPGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the LPGroup to update in case it exists.
     */
    where: LPGroupWhereUniqueInput
    /**
     * In case the LPGroup found by the `where` argument doesn't exist, create a new LPGroup with this data.
     */
    create: XOR<LPGroupCreateInput, LPGroupUncheckedCreateInput>
    /**
     * In case the LPGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LPGroupUpdateInput, LPGroupUncheckedUpdateInput>
  }

  /**
   * LPGroup delete
   */
  export type LPGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
    /**
     * Filter which LPGroup to delete.
     */
    where: LPGroupWhereUniqueInput
  }

  /**
   * LPGroup deleteMany
   */
  export type LPGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LPGroups to delete
     */
    where?: LPGroupWhereInput
    /**
     * Limit how many LPGroups to delete.
     */
    limit?: number
  }

  /**
   * LPGroup.members
   */
  export type LPGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    where?: InvestorGroupMemberWhereInput
    orderBy?: InvestorGroupMemberOrderByWithRelationInput | InvestorGroupMemberOrderByWithRelationInput[]
    cursor?: InvestorGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvestorGroupMemberScalarFieldEnum | InvestorGroupMemberScalarFieldEnum[]
  }

  /**
   * LPGroup without action
   */
  export type LPGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LPGroup
     */
    select?: LPGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LPGroup
     */
    omit?: LPGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LPGroupInclude<ExtArgs> | null
  }


  /**
   * Model InvestorGroupMember
   */

  export type AggregateInvestorGroupMember = {
    _count: InvestorGroupMemberCountAggregateOutputType | null
    _min: InvestorGroupMemberMinAggregateOutputType | null
    _max: InvestorGroupMemberMaxAggregateOutputType | null
  }

  export type InvestorGroupMemberMinAggregateOutputType = {
    id: string | null
    investorId: string | null
    groupId: string | null
    assignedAt: Date | null
    autoAssigned: boolean | null
  }

  export type InvestorGroupMemberMaxAggregateOutputType = {
    id: string | null
    investorId: string | null
    groupId: string | null
    assignedAt: Date | null
    autoAssigned: boolean | null
  }

  export type InvestorGroupMemberCountAggregateOutputType = {
    id: number
    investorId: number
    groupId: number
    assignedAt: number
    autoAssigned: number
    _all: number
  }


  export type InvestorGroupMemberMinAggregateInputType = {
    id?: true
    investorId?: true
    groupId?: true
    assignedAt?: true
    autoAssigned?: true
  }

  export type InvestorGroupMemberMaxAggregateInputType = {
    id?: true
    investorId?: true
    groupId?: true
    assignedAt?: true
    autoAssigned?: true
  }

  export type InvestorGroupMemberCountAggregateInputType = {
    id?: true
    investorId?: true
    groupId?: true
    assignedAt?: true
    autoAssigned?: true
    _all?: true
  }

  export type InvestorGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorGroupMember to aggregate.
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorGroupMembers to fetch.
     */
    orderBy?: InvestorGroupMemberOrderByWithRelationInput | InvestorGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestorGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestorGroupMembers
    **/
    _count?: true | InvestorGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorGroupMemberMaxAggregateInputType
  }

  export type GetInvestorGroupMemberAggregateType<T extends InvestorGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestorGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestorGroupMember[P]>
      : GetScalarType<T[P], AggregateInvestorGroupMember[P]>
  }




  export type InvestorGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestorGroupMemberWhereInput
    orderBy?: InvestorGroupMemberOrderByWithAggregationInput | InvestorGroupMemberOrderByWithAggregationInput[]
    by: InvestorGroupMemberScalarFieldEnum[] | InvestorGroupMemberScalarFieldEnum
    having?: InvestorGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorGroupMemberCountAggregateInputType | true
    _min?: InvestorGroupMemberMinAggregateInputType
    _max?: InvestorGroupMemberMaxAggregateInputType
  }

  export type InvestorGroupMemberGroupByOutputType = {
    id: string
    investorId: string
    groupId: string
    assignedAt: Date
    autoAssigned: boolean
    _count: InvestorGroupMemberCountAggregateOutputType | null
    _min: InvestorGroupMemberMinAggregateOutputType | null
    _max: InvestorGroupMemberMaxAggregateOutputType | null
  }

  type GetInvestorGroupMemberGroupByPayload<T extends InvestorGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type InvestorGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    autoAssigned?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    group?: boolean | LPGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorGroupMember"]>

  export type InvestorGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    autoAssigned?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    group?: boolean | LPGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorGroupMember"]>

  export type InvestorGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    investorId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    autoAssigned?: boolean
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    group?: boolean | LPGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investorGroupMember"]>

  export type InvestorGroupMemberSelectScalar = {
    id?: boolean
    investorId?: boolean
    groupId?: boolean
    assignedAt?: boolean
    autoAssigned?: boolean
  }

  export type InvestorGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "investorId" | "groupId" | "assignedAt" | "autoAssigned", ExtArgs["result"]["investorGroupMember"]>
  export type InvestorGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    group?: boolean | LPGroupDefaultArgs<ExtArgs>
  }
  export type InvestorGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    group?: boolean | LPGroupDefaultArgs<ExtArgs>
  }
  export type InvestorGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    investor?: boolean | InvestorDefaultArgs<ExtArgs>
    group?: boolean | LPGroupDefaultArgs<ExtArgs>
  }

  export type $InvestorGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestorGroupMember"
    objects: {
      investor: Prisma.$InvestorPayload<ExtArgs>
      group: Prisma.$LPGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      investorId: string
      groupId: string
      assignedAt: Date
      autoAssigned: boolean
    }, ExtArgs["result"]["investorGroupMember"]>
    composites: {}
  }

  type InvestorGroupMemberGetPayload<S extends boolean | null | undefined | InvestorGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$InvestorGroupMemberPayload, S>

  type InvestorGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestorGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestorGroupMemberCountAggregateInputType | true
    }

  export interface InvestorGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestorGroupMember'], meta: { name: 'InvestorGroupMember' } }
    /**
     * Find zero or one InvestorGroupMember that matches the filter.
     * @param {InvestorGroupMemberFindUniqueArgs} args - Arguments to find a InvestorGroupMember
     * @example
     * // Get one InvestorGroupMember
     * const investorGroupMember = await prisma.investorGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestorGroupMemberFindUniqueArgs>(args: SelectSubset<T, InvestorGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvestorGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestorGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a InvestorGroupMember
     * @example
     * // Get one InvestorGroupMember
     * const investorGroupMember = await prisma.investorGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestorGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestorGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberFindFirstArgs} args - Arguments to find a InvestorGroupMember
     * @example
     * // Get one InvestorGroupMember
     * const investorGroupMember = await prisma.investorGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestorGroupMemberFindFirstArgs>(args?: SelectSubset<T, InvestorGroupMemberFindFirstArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvestorGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberFindFirstOrThrowArgs} args - Arguments to find a InvestorGroupMember
     * @example
     * // Get one InvestorGroupMember
     * const investorGroupMember = await prisma.investorGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestorGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestorGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvestorGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestorGroupMembers
     * const investorGroupMembers = await prisma.investorGroupMember.findMany()
     * 
     * // Get first 10 InvestorGroupMembers
     * const investorGroupMembers = await prisma.investorGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorGroupMemberWithIdOnly = await prisma.investorGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestorGroupMemberFindManyArgs>(args?: SelectSubset<T, InvestorGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvestorGroupMember.
     * @param {InvestorGroupMemberCreateArgs} args - Arguments to create a InvestorGroupMember.
     * @example
     * // Create one InvestorGroupMember
     * const InvestorGroupMember = await prisma.investorGroupMember.create({
     *   data: {
     *     // ... data to create a InvestorGroupMember
     *   }
     * })
     * 
     */
    create<T extends InvestorGroupMemberCreateArgs>(args: SelectSubset<T, InvestorGroupMemberCreateArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvestorGroupMembers.
     * @param {InvestorGroupMemberCreateManyArgs} args - Arguments to create many InvestorGroupMembers.
     * @example
     * // Create many InvestorGroupMembers
     * const investorGroupMember = await prisma.investorGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestorGroupMemberCreateManyArgs>(args?: SelectSubset<T, InvestorGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestorGroupMembers and returns the data saved in the database.
     * @param {InvestorGroupMemberCreateManyAndReturnArgs} args - Arguments to create many InvestorGroupMembers.
     * @example
     * // Create many InvestorGroupMembers
     * const investorGroupMember = await prisma.investorGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestorGroupMembers and only return the `id`
     * const investorGroupMemberWithIdOnly = await prisma.investorGroupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestorGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestorGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvestorGroupMember.
     * @param {InvestorGroupMemberDeleteArgs} args - Arguments to delete one InvestorGroupMember.
     * @example
     * // Delete one InvestorGroupMember
     * const InvestorGroupMember = await prisma.investorGroupMember.delete({
     *   where: {
     *     // ... filter to delete one InvestorGroupMember
     *   }
     * })
     * 
     */
    delete<T extends InvestorGroupMemberDeleteArgs>(args: SelectSubset<T, InvestorGroupMemberDeleteArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvestorGroupMember.
     * @param {InvestorGroupMemberUpdateArgs} args - Arguments to update one InvestorGroupMember.
     * @example
     * // Update one InvestorGroupMember
     * const investorGroupMember = await prisma.investorGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestorGroupMemberUpdateArgs>(args: SelectSubset<T, InvestorGroupMemberUpdateArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvestorGroupMembers.
     * @param {InvestorGroupMemberDeleteManyArgs} args - Arguments to filter InvestorGroupMembers to delete.
     * @example
     * // Delete a few InvestorGroupMembers
     * const { count } = await prisma.investorGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestorGroupMemberDeleteManyArgs>(args?: SelectSubset<T, InvestorGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestorGroupMembers
     * const investorGroupMember = await prisma.investorGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestorGroupMemberUpdateManyArgs>(args: SelectSubset<T, InvestorGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestorGroupMembers and returns the data updated in the database.
     * @param {InvestorGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many InvestorGroupMembers.
     * @example
     * // Update many InvestorGroupMembers
     * const investorGroupMember = await prisma.investorGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvestorGroupMembers and only return the `id`
     * const investorGroupMemberWithIdOnly = await prisma.investorGroupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestorGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestorGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvestorGroupMember.
     * @param {InvestorGroupMemberUpsertArgs} args - Arguments to update or create a InvestorGroupMember.
     * @example
     * // Update or create a InvestorGroupMember
     * const investorGroupMember = await prisma.investorGroupMember.upsert({
     *   create: {
     *     // ... data to create a InvestorGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestorGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends InvestorGroupMemberUpsertArgs>(args: SelectSubset<T, InvestorGroupMemberUpsertArgs<ExtArgs>>): Prisma__InvestorGroupMemberClient<$Result.GetResult<Prisma.$InvestorGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvestorGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberCountArgs} args - Arguments to filter InvestorGroupMembers to count.
     * @example
     * // Count the number of InvestorGroupMembers
     * const count = await prisma.investorGroupMember.count({
     *   where: {
     *     // ... the filter for the InvestorGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends InvestorGroupMemberCountArgs>(
      args?: Subset<T, InvestorGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestorGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorGroupMemberAggregateArgs>(args: Subset<T, InvestorGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetInvestorGroupMemberAggregateType<T>>

    /**
     * Group by InvestorGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestorGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestorGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: InvestorGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestorGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestorGroupMember model
   */
  readonly fields: InvestorGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestorGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestorGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    investor<T extends InvestorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvestorDefaultArgs<ExtArgs>>): Prisma__InvestorClient<$Result.GetResult<Prisma.$InvestorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    group<T extends LPGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LPGroupDefaultArgs<ExtArgs>>): Prisma__LPGroupClient<$Result.GetResult<Prisma.$LPGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestorGroupMember model
   */
  interface InvestorGroupMemberFieldRefs {
    readonly id: FieldRef<"InvestorGroupMember", 'String'>
    readonly investorId: FieldRef<"InvestorGroupMember", 'String'>
    readonly groupId: FieldRef<"InvestorGroupMember", 'String'>
    readonly assignedAt: FieldRef<"InvestorGroupMember", 'DateTime'>
    readonly autoAssigned: FieldRef<"InvestorGroupMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InvestorGroupMember findUnique
   */
  export type InvestorGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which InvestorGroupMember to fetch.
     */
    where: InvestorGroupMemberWhereUniqueInput
  }

  /**
   * InvestorGroupMember findUniqueOrThrow
   */
  export type InvestorGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which InvestorGroupMember to fetch.
     */
    where: InvestorGroupMemberWhereUniqueInput
  }

  /**
   * InvestorGroupMember findFirst
   */
  export type InvestorGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which InvestorGroupMember to fetch.
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorGroupMembers to fetch.
     */
    orderBy?: InvestorGroupMemberOrderByWithRelationInput | InvestorGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorGroupMembers.
     */
    cursor?: InvestorGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorGroupMembers.
     */
    distinct?: InvestorGroupMemberScalarFieldEnum | InvestorGroupMemberScalarFieldEnum[]
  }

  /**
   * InvestorGroupMember findFirstOrThrow
   */
  export type InvestorGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which InvestorGroupMember to fetch.
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorGroupMembers to fetch.
     */
    orderBy?: InvestorGroupMemberOrderByWithRelationInput | InvestorGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestorGroupMembers.
     */
    cursor?: InvestorGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestorGroupMembers.
     */
    distinct?: InvestorGroupMemberScalarFieldEnum | InvestorGroupMemberScalarFieldEnum[]
  }

  /**
   * InvestorGroupMember findMany
   */
  export type InvestorGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which InvestorGroupMembers to fetch.
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestorGroupMembers to fetch.
     */
    orderBy?: InvestorGroupMemberOrderByWithRelationInput | InvestorGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestorGroupMembers.
     */
    cursor?: InvestorGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestorGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestorGroupMembers.
     */
    skip?: number
    distinct?: InvestorGroupMemberScalarFieldEnum | InvestorGroupMemberScalarFieldEnum[]
  }

  /**
   * InvestorGroupMember create
   */
  export type InvestorGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestorGroupMember.
     */
    data: XOR<InvestorGroupMemberCreateInput, InvestorGroupMemberUncheckedCreateInput>
  }

  /**
   * InvestorGroupMember createMany
   */
  export type InvestorGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestorGroupMembers.
     */
    data: InvestorGroupMemberCreateManyInput | InvestorGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestorGroupMember createManyAndReturn
   */
  export type InvestorGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many InvestorGroupMembers.
     */
    data: InvestorGroupMemberCreateManyInput | InvestorGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorGroupMember update
   */
  export type InvestorGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestorGroupMember.
     */
    data: XOR<InvestorGroupMemberUpdateInput, InvestorGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which InvestorGroupMember to update.
     */
    where: InvestorGroupMemberWhereUniqueInput
  }

  /**
   * InvestorGroupMember updateMany
   */
  export type InvestorGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestorGroupMembers.
     */
    data: XOR<InvestorGroupMemberUpdateManyMutationInput, InvestorGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which InvestorGroupMembers to update
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * Limit how many InvestorGroupMembers to update.
     */
    limit?: number
  }

  /**
   * InvestorGroupMember updateManyAndReturn
   */
  export type InvestorGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update InvestorGroupMembers.
     */
    data: XOR<InvestorGroupMemberUpdateManyMutationInput, InvestorGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which InvestorGroupMembers to update
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * Limit how many InvestorGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestorGroupMember upsert
   */
  export type InvestorGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestorGroupMember to update in case it exists.
     */
    where: InvestorGroupMemberWhereUniqueInput
    /**
     * In case the InvestorGroupMember found by the `where` argument doesn't exist, create a new InvestorGroupMember with this data.
     */
    create: XOR<InvestorGroupMemberCreateInput, InvestorGroupMemberUncheckedCreateInput>
    /**
     * In case the InvestorGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestorGroupMemberUpdateInput, InvestorGroupMemberUncheckedUpdateInput>
  }

  /**
   * InvestorGroupMember delete
   */
  export type InvestorGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which InvestorGroupMember to delete.
     */
    where: InvestorGroupMemberWhereUniqueInput
  }

  /**
   * InvestorGroupMember deleteMany
   */
  export type InvestorGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestorGroupMembers to delete
     */
    where?: InvestorGroupMemberWhereInput
    /**
     * Limit how many InvestorGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * InvestorGroupMember without action
   */
  export type InvestorGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestorGroupMember
     */
    select?: InvestorGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestorGroupMember
     */
    omit?: InvestorGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestorGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    firm: 'firm',
    role: 'role',
    phone: 'phone',
    location: 'location',
    avatar: 'avatar',
    emailVerified: 'emailVerified',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    bio: 'bio',
    joinDate: 'joinDate',
    timezone: 'timezone',
    language: 'language',
    theme: 'theme',
    notifications: 'notifications',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const UserPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    emailNotify: 'emailNotify',
    pushNotify: 'pushNotify',
    smsNotify: 'smsNotify',
    calendarNotify: 'calendarNotify',
    dealNotify: 'dealNotify',
    autoSave: 'autoSave',
    darkMode: 'darkMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferenceScalarFieldEnum = (typeof UserPreferenceScalarFieldEnum)[keyof typeof UserPreferenceScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    type: 'type',
    isActive: 'isActive',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    scope: 'scope',
    profile: 'profile',
    settings: 'settings',
    lastSync: 'lastSync',
    syncStatus: 'syncStatus',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    company: 'company',
    description: 'description',
    sector: 'sector',
    stage: 'stage',
    status: 'status',
    value: 'value',
    probability: 'probability',
    leadPartner: 'leadPartner',
    team: 'team',
    tags: 'tags',
    priority: 'priority',
    targetClose: 'targetClose',
    actualClose: 'actualClose',
    nextStep: 'nextStep',
    lastActivity: 'lastActivity',
    source: 'source',
    geography: 'geography',
    dealSize: 'dealSize',
    metrics: 'metrics',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    googleContactId: 'googleContactId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    title: 'title',
    role: 'role',
    linkedinUrl: 'linkedinUrl',
    avatar: 'avatar',
    notes: 'notes',
    tags: 'tags',
    relationshipScore: 'relationshipScore',
    lastContact: 'lastContact',
    status: 'status',
    isKeyContact: 'isKeyContact',
    source: 'source',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    contactId: 'contactId',
    type: 'type',
    title: 'title',
    description: 'description',
    content: 'content',
    date: 'date',
    duration: 'duration',
    location: 'location',
    attendees: 'attendees',
    status: 'status',
    priority: 'priority',
    outcome: 'outcome',
    nextSteps: 'nextSteps',
    metadata: 'metadata',
    externalId: 'externalId',
    syncedFrom: 'syncedFrom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    name: 'name',
    description: 'description',
    type: 'type',
    category: 'category',
    size: 'size',
    url: 'url',
    googleDriveId: 'googleDriveId',
    path: 'path',
    version: 'version',
    isConfidential: 'isConfidential',
    uploadedBy: 'uploadedBy',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const CommunicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    contactId: 'contactId',
    type: 'type',
    subject: 'subject',
    content: 'content',
    htmlContent: 'htmlContent',
    fromEmail: 'fromEmail',
    toEmails: 'toEmails',
    ccEmails: 'ccEmails',
    bccEmails: 'bccEmails',
    threadId: 'threadId',
    messageId: 'messageId',
    status: 'status',
    direction: 'direction',
    isRead: 'isRead',
    isImportant: 'isImportant',
    labels: 'labels',
    attachments: 'attachments',
    metadata: 'metadata',
    sentAt: 'sentAt',
    receivedAt: 'receivedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunicationScalarFieldEnum = (typeof CommunicationScalarFieldEnum)[keyof typeof CommunicationScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    type: 'type',
    status: 'status',
    totalCommitment: 'totalCommitment',
    totalCalled: 'totalCalled',
    description: 'description',
    website: 'website',
    location: 'location',
    founded: 'founded',
    aum: 'aum',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const FundScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    type: 'type',
    strategy: 'strategy',
    targetSize: 'targetSize',
    minimumCommitment: 'minimumCommitment',
    managementFee: 'managementFee',
    carriedInterest: 'carriedInterest',
    currency: 'currency',
    vintage: 'vintage',
    investmentPeriod: 'investmentPeriod',
    fundTerm: 'fundTerm',
    geoFocus: 'geoFocus',
    sectorFocus: 'sectorFocus',
    description: 'description',
    status: 'status',
    raisedAmount: 'raisedAmount',
    investorCount: 'investorCount',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FundScalarFieldEnum = (typeof FundScalarFieldEnum)[keyof typeof FundScalarFieldEnum]


  export const InvestorEntityScalarFieldEnum: {
    id: 'id',
    investorId: 'investorId',
    name: 'name',
    type: 'type',
    investmentType: 'investmentType',
    commitment: 'commitment',
    called: 'called',
    status: 'status',
    documents: 'documents',
    fundInvestments: 'fundInvestments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvestorEntityScalarFieldEnum = (typeof InvestorEntityScalarFieldEnum)[keyof typeof InvestorEntityScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    type: 'type',
    format: 'format',
    content: 'content',
    data: 'data',
    url: 'url',
    status: 'status',
    recipients: 'recipients',
    sentAt: 'sentAt',
    generatedAt: 'generatedAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SyncJobScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    itemsProcessed: 'itemsProcessed',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SyncJobScalarFieldEnum = (typeof SyncJobScalarFieldEnum)[keyof typeof SyncJobScalarFieldEnum]


  export const TeamsMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    contactId: 'contactId',
    messageId: 'messageId',
    chatId: 'chatId',
    channelId: 'channelId',
    teamId: 'teamId',
    fromEmail: 'fromEmail',
    fromName: 'fromName',
    content: 'content',
    contentType: 'contentType',
    importance: 'importance',
    messageType: 'messageType',
    attachments: 'attachments',
    mentions: 'mentions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    sentAt: 'sentAt'
  };

  export type TeamsMessageScalarFieldEnum = (typeof TeamsMessageScalarFieldEnum)[keyof typeof TeamsMessageScalarFieldEnum]


  export const TeamsChannelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channelId: 'channelId',
    teamId: 'teamId',
    name: 'name',
    description: 'description',
    type: 'type',
    webUrl: 'webUrl',
    memberCount: 'memberCount',
    isArchived: 'isArchived',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamsChannelScalarFieldEnum = (typeof TeamsChannelScalarFieldEnum)[keyof typeof TeamsChannelScalarFieldEnum]


  export const SlackMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    contactId: 'contactId',
    messageId: 'messageId',
    channelId: 'channelId',
    channelName: 'channelName',
    fromUserId: 'fromUserId',
    fromName: 'fromName',
    text: 'text',
    messageType: 'messageType',
    threadTs: 'threadTs',
    attachments: 'attachments',
    reactions: 'reactions',
    mentions: 'mentions',
    sentAt: 'sentAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlackMessageScalarFieldEnum = (typeof SlackMessageScalarFieldEnum)[keyof typeof SlackMessageScalarFieldEnum]


  export const SlackChannelScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    channelId: 'channelId',
    name: 'name',
    purpose: 'purpose',
    topic: 'topic',
    isPrivate: 'isPrivate',
    isArchived: 'isArchived',
    memberCount: 'memberCount',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlackChannelScalarFieldEnum = (typeof SlackChannelScalarFieldEnum)[keyof typeof SlackChannelScalarFieldEnum]


  export const ZoomMeetingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    meetingId: 'meetingId',
    uuid: 'uuid',
    topic: 'topic',
    agenda: 'agenda',
    startTime: 'startTime',
    duration: 'duration',
    timezone: 'timezone',
    status: 'status',
    meetingType: 'meetingType',
    joinUrl: 'joinUrl',
    startUrl: 'startUrl',
    password: 'password',
    hostEmail: 'hostEmail',
    participantCount: 'participantCount',
    hasRecording: 'hasRecording',
    recordingUrl: 'recordingUrl',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoomMeetingScalarFieldEnum = (typeof ZoomMeetingScalarFieldEnum)[keyof typeof ZoomMeetingScalarFieldEnum]


  export const ZoomParticipantScalarFieldEnum: {
    id: 'id',
    meetingId: 'meetingId',
    userId: 'userId',
    zoomUserId: 'zoomUserId',
    name: 'name',
    email: 'email',
    joinTime: 'joinTime',
    leaveTime: 'leaveTime',
    duration: 'duration',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoomParticipantScalarFieldEnum = (typeof ZoomParticipantScalarFieldEnum)[keyof typeof ZoomParticipantScalarFieldEnum]


  export const SalesforceAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    accountId: 'accountId',
    name: 'name',
    type: 'type',
    industry: 'industry',
    website: 'website',
    phone: 'phone',
    billingCity: 'billingCity',
    billingState: 'billingState',
    billingCountry: 'billingCountry',
    description: 'description',
    revenue: 'revenue',
    employees: 'employees',
    ownerId: 'ownerId',
    metadata: 'metadata',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesforceAccountScalarFieldEnum = (typeof SalesforceAccountScalarFieldEnum)[keyof typeof SalesforceAccountScalarFieldEnum]


  export const SalesforceContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contactId: 'contactId',
    accountId: 'accountId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    title: 'title',
    department: 'department',
    leadSource: 'leadSource',
    description: 'description',
    ownerId: 'ownerId',
    metadata: 'metadata',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesforceContactScalarFieldEnum = (typeof SalesforceContactScalarFieldEnum)[keyof typeof SalesforceContactScalarFieldEnum]


  export const SalesforceOpportunityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dealId: 'dealId',
    opportunityId: 'opportunityId',
    accountId: 'accountId',
    name: 'name',
    amount: 'amount',
    stage: 'stage',
    probability: 'probability',
    closeDate: 'closeDate',
    type: 'type',
    leadSource: 'leadSource',
    description: 'description',
    ownerId: 'ownerId',
    metadata: 'metadata',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesforceOpportunityScalarFieldEnum = (typeof SalesforceOpportunityScalarFieldEnum)[keyof typeof SalesforceOpportunityScalarFieldEnum]


  export const LPGroupScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    type: 'type',
    criteria: 'criteria',
    autoAssign: 'autoAssign',
    emailPreferences: 'emailPreferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LPGroupScalarFieldEnum = (typeof LPGroupScalarFieldEnum)[keyof typeof LPGroupScalarFieldEnum]


  export const InvestorGroupMemberScalarFieldEnum: {
    id: 'id',
    investorId: 'investorId',
    groupId: 'groupId',
    assignedAt: 'assignedAt',
    autoAssigned: 'autoAssigned'
  };

  export type InvestorGroupMemberScalarFieldEnum = (typeof InvestorGroupMemberScalarFieldEnum)[keyof typeof InvestorGroupMemberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    firm?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    integrations?: IntegrationListRelationFilter
    deals?: DealListRelationFilter
    activities?: ActivityListRelationFilter
    ownedContacts?: ContactListRelationFilter
    communications?: CommunicationListRelationFilter
    documents?: DocumentListRelationFilter
    preferences?: XOR<UserPreferenceNullableScalarRelationFilter, UserPreferenceWhereInput> | null
    teamsMessages?: TeamsMessageListRelationFilter
    teamsChannels?: TeamsChannelListRelationFilter
    slackMessages?: SlackMessageListRelationFilter
    slackChannels?: SlackChannelListRelationFilter
    zoomMeetings?: ZoomMeetingListRelationFilter
    zoomParticipants?: ZoomParticipantListRelationFilter
    salesforceAccounts?: SalesforceAccountListRelationFilter
    salesforceContacts?: SalesforceContactListRelationFilter
    salesforceOpportunities?: SalesforceOpportunityListRelationFilter
    funds?: FundListRelationFilter
    investors?: InvestorListRelationFilter
    lpGroups?: LPGroupListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firm?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    integrations?: IntegrationOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    ownedContacts?: ContactOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    preferences?: UserPreferenceOrderByWithRelationInput
    teamsMessages?: TeamsMessageOrderByRelationAggregateInput
    teamsChannels?: TeamsChannelOrderByRelationAggregateInput
    slackMessages?: SlackMessageOrderByRelationAggregateInput
    slackChannels?: SlackChannelOrderByRelationAggregateInput
    zoomMeetings?: ZoomMeetingOrderByRelationAggregateInput
    zoomParticipants?: ZoomParticipantOrderByRelationAggregateInput
    salesforceAccounts?: SalesforceAccountOrderByRelationAggregateInput
    salesforceContacts?: SalesforceContactOrderByRelationAggregateInput
    salesforceOpportunities?: SalesforceOpportunityOrderByRelationAggregateInput
    funds?: FundOrderByRelationAggregateInput
    investors?: InvestorOrderByRelationAggregateInput
    lpGroups?: LPGroupOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    firm?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    integrations?: IntegrationListRelationFilter
    deals?: DealListRelationFilter
    activities?: ActivityListRelationFilter
    ownedContacts?: ContactListRelationFilter
    communications?: CommunicationListRelationFilter
    documents?: DocumentListRelationFilter
    preferences?: XOR<UserPreferenceNullableScalarRelationFilter, UserPreferenceWhereInput> | null
    teamsMessages?: TeamsMessageListRelationFilter
    teamsChannels?: TeamsChannelListRelationFilter
    slackMessages?: SlackMessageListRelationFilter
    slackChannels?: SlackChannelListRelationFilter
    zoomMeetings?: ZoomMeetingListRelationFilter
    zoomParticipants?: ZoomParticipantListRelationFilter
    salesforceAccounts?: SalesforceAccountListRelationFilter
    salesforceContacts?: SalesforceContactListRelationFilter
    salesforceOpportunities?: SalesforceOpportunityListRelationFilter
    funds?: FundListRelationFilter
    investors?: InvestorListRelationFilter
    lpGroups?: LPGroupListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firm?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    firm?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    title?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    joinDate?: DateTimeFilter<"Profile"> | Date | string
    timezone?: StringFilter<"Profile"> | string
    language?: StringFilter<"Profile"> | string
    theme?: StringFilter<"Profile"> | string
    notifications?: JsonNullableFilter<"Profile">
    settings?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    joinDate?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    title?: StringNullableFilter<"Profile"> | string | null
    bio?: StringNullableFilter<"Profile"> | string | null
    joinDate?: DateTimeFilter<"Profile"> | Date | string
    timezone?: StringFilter<"Profile"> | string
    language?: StringFilter<"Profile"> | string
    theme?: StringFilter<"Profile"> | string
    notifications?: JsonNullableFilter<"Profile">
    settings?: JsonNullableFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    joinDate?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    title?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    joinDate?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    timezone?: StringWithAggregatesFilter<"Profile"> | string
    language?: StringWithAggregatesFilter<"Profile"> | string
    theme?: StringWithAggregatesFilter<"Profile"> | string
    notifications?: JsonNullableWithAggregatesFilter<"Profile">
    settings?: JsonNullableWithAggregatesFilter<"Profile">
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type UserPreferenceWhereInput = {
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    id?: StringFilter<"UserPreference"> | string
    userId?: StringFilter<"UserPreference"> | string
    emailNotify?: BoolFilter<"UserPreference"> | boolean
    pushNotify?: BoolFilter<"UserPreference"> | boolean
    smsNotify?: BoolFilter<"UserPreference"> | boolean
    calendarNotify?: BoolFilter<"UserPreference"> | boolean
    dealNotify?: BoolFilter<"UserPreference"> | boolean
    autoSave?: BoolFilter<"UserPreference"> | boolean
    darkMode?: BoolFilter<"UserPreference"> | boolean
    createdAt?: DateTimeFilter<"UserPreference"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    smsNotify?: SortOrder
    calendarNotify?: SortOrder
    dealNotify?: SortOrder
    autoSave?: SortOrder
    darkMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    emailNotify?: BoolFilter<"UserPreference"> | boolean
    pushNotify?: BoolFilter<"UserPreference"> | boolean
    smsNotify?: BoolFilter<"UserPreference"> | boolean
    calendarNotify?: BoolFilter<"UserPreference"> | boolean
    dealNotify?: BoolFilter<"UserPreference"> | boolean
    autoSave?: BoolFilter<"UserPreference"> | boolean
    darkMode?: BoolFilter<"UserPreference"> | boolean
    createdAt?: DateTimeFilter<"UserPreference"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    smsNotify?: SortOrder
    calendarNotify?: SortOrder
    dealNotify?: SortOrder
    autoSave?: SortOrder
    darkMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferenceCountOrderByAggregateInput
    _max?: UserPreferenceMaxOrderByAggregateInput
    _min?: UserPreferenceMinOrderByAggregateInput
  }

  export type UserPreferenceScalarWhereWithAggregatesInput = {
    AND?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    OR?: UserPreferenceScalarWhereWithAggregatesInput[]
    NOT?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreference"> | string
    userId?: StringWithAggregatesFilter<"UserPreference"> | string
    emailNotify?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    pushNotify?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    smsNotify?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    calendarNotify?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    dealNotify?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    autoSave?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    darkMode?: BoolWithAggregatesFilter<"UserPreference"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreference"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    userId?: StringFilter<"Integration"> | string
    provider?: StringFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    isActive?: BoolFilter<"Integration"> | boolean
    accessToken?: StringNullableFilter<"Integration"> | string | null
    refreshToken?: StringNullableFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    scope?: StringNullableListFilter<"Integration">
    profile?: JsonNullableFilter<"Integration">
    settings?: JsonNullableFilter<"Integration">
    lastSync?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncStatus?: StringFilter<"Integration"> | string
    errorMessage?: StringNullableFilter<"Integration"> | string | null
    metadata?: JsonNullableFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    scope?: SortOrder
    profile?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider_type?: IntegrationUserIdProviderTypeCompoundUniqueInput
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    userId?: StringFilter<"Integration"> | string
    provider?: StringFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    isActive?: BoolFilter<"Integration"> | boolean
    accessToken?: StringNullableFilter<"Integration"> | string | null
    refreshToken?: StringNullableFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    scope?: StringNullableListFilter<"Integration">
    profile?: JsonNullableFilter<"Integration">
    settings?: JsonNullableFilter<"Integration">
    lastSync?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncStatus?: StringFilter<"Integration"> | string
    errorMessage?: StringNullableFilter<"Integration"> | string | null
    metadata?: JsonNullableFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_provider_type">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    scope?: SortOrder
    profile?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    userId?: StringWithAggregatesFilter<"Integration"> | string
    provider?: StringWithAggregatesFilter<"Integration"> | string
    type?: StringWithAggregatesFilter<"Integration"> | string
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    accessToken?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    scope?: StringNullableListFilter<"Integration">
    profile?: JsonNullableWithAggregatesFilter<"Integration">
    settings?: JsonNullableWithAggregatesFilter<"Integration">
    lastSync?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    syncStatus?: StringWithAggregatesFilter<"Integration"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Integration">
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    userId?: StringFilter<"Deal"> | string
    company?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    sector?: StringNullableFilter<"Deal"> | string | null
    stage?: StringFilter<"Deal"> | string
    status?: StringFilter<"Deal"> | string
    value?: FloatNullableFilter<"Deal"> | number | null
    probability?: FloatNullableFilter<"Deal"> | number | null
    leadPartner?: StringNullableFilter<"Deal"> | string | null
    team?: StringNullableListFilter<"Deal">
    tags?: StringNullableListFilter<"Deal">
    priority?: StringFilter<"Deal"> | string
    targetClose?: DateTimeNullableFilter<"Deal"> | Date | string | null
    actualClose?: DateTimeNullableFilter<"Deal"> | Date | string | null
    nextStep?: StringNullableFilter<"Deal"> | string | null
    lastActivity?: DateTimeNullableFilter<"Deal"> | Date | string | null
    source?: StringNullableFilter<"Deal"> | string | null
    geography?: StringNullableFilter<"Deal"> | string | null
    dealSize?: StringNullableFilter<"Deal"> | string | null
    metrics?: JsonNullableFilter<"Deal">
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contacts?: ContactListRelationFilter
    documents?: DocumentListRelationFilter
    activities?: ActivityListRelationFilter
    communications?: CommunicationListRelationFilter
    teamsMessages?: TeamsMessageListRelationFilter
    slackMessages?: SlackMessageListRelationFilter
    zoomMeetings?: ZoomMeetingListRelationFilter
    salesforceAccounts?: SalesforceAccountListRelationFilter
    salesforceOpportunities?: SalesforceOpportunityListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    description?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    stage?: SortOrder
    status?: SortOrder
    value?: SortOrderInput | SortOrder
    probability?: SortOrderInput | SortOrder
    leadPartner?: SortOrderInput | SortOrder
    team?: SortOrder
    tags?: SortOrder
    priority?: SortOrder
    targetClose?: SortOrderInput | SortOrder
    actualClose?: SortOrderInput | SortOrder
    nextStep?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    geography?: SortOrderInput | SortOrder
    dealSize?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    contacts?: ContactOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
    teamsMessages?: TeamsMessageOrderByRelationAggregateInput
    slackMessages?: SlackMessageOrderByRelationAggregateInput
    zoomMeetings?: ZoomMeetingOrderByRelationAggregateInput
    salesforceAccounts?: SalesforceAccountOrderByRelationAggregateInput
    salesforceOpportunities?: SalesforceOpportunityOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    userId?: StringFilter<"Deal"> | string
    company?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    sector?: StringNullableFilter<"Deal"> | string | null
    stage?: StringFilter<"Deal"> | string
    status?: StringFilter<"Deal"> | string
    value?: FloatNullableFilter<"Deal"> | number | null
    probability?: FloatNullableFilter<"Deal"> | number | null
    leadPartner?: StringNullableFilter<"Deal"> | string | null
    team?: StringNullableListFilter<"Deal">
    tags?: StringNullableListFilter<"Deal">
    priority?: StringFilter<"Deal"> | string
    targetClose?: DateTimeNullableFilter<"Deal"> | Date | string | null
    actualClose?: DateTimeNullableFilter<"Deal"> | Date | string | null
    nextStep?: StringNullableFilter<"Deal"> | string | null
    lastActivity?: DateTimeNullableFilter<"Deal"> | Date | string | null
    source?: StringNullableFilter<"Deal"> | string | null
    geography?: StringNullableFilter<"Deal"> | string | null
    dealSize?: StringNullableFilter<"Deal"> | string | null
    metrics?: JsonNullableFilter<"Deal">
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    contacts?: ContactListRelationFilter
    documents?: DocumentListRelationFilter
    activities?: ActivityListRelationFilter
    communications?: CommunicationListRelationFilter
    teamsMessages?: TeamsMessageListRelationFilter
    slackMessages?: SlackMessageListRelationFilter
    zoomMeetings?: ZoomMeetingListRelationFilter
    salesforceAccounts?: SalesforceAccountListRelationFilter
    salesforceOpportunities?: SalesforceOpportunityListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    description?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    stage?: SortOrder
    status?: SortOrder
    value?: SortOrderInput | SortOrder
    probability?: SortOrderInput | SortOrder
    leadPartner?: SortOrderInput | SortOrder
    team?: SortOrder
    tags?: SortOrder
    priority?: SortOrder
    targetClose?: SortOrderInput | SortOrder
    actualClose?: SortOrderInput | SortOrder
    nextStep?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    geography?: SortOrderInput | SortOrder
    dealSize?: SortOrderInput | SortOrder
    metrics?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    userId?: StringWithAggregatesFilter<"Deal"> | string
    company?: StringWithAggregatesFilter<"Deal"> | string
    description?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    sector?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    stage?: StringWithAggregatesFilter<"Deal"> | string
    status?: StringWithAggregatesFilter<"Deal"> | string
    value?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    probability?: FloatNullableWithAggregatesFilter<"Deal"> | number | null
    leadPartner?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    team?: StringNullableListFilter<"Deal">
    tags?: StringNullableListFilter<"Deal">
    priority?: StringWithAggregatesFilter<"Deal"> | string
    targetClose?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    actualClose?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    nextStep?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    lastActivity?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    source?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    geography?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    dealSize?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    metrics?: JsonNullableWithAggregatesFilter<"Deal">
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    dealId?: StringNullableFilter<"Contact"> | string | null
    googleContactId?: StringNullableFilter<"Contact"> | string | null
    name?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    title?: StringNullableFilter<"Contact"> | string | null
    role?: StringNullableFilter<"Contact"> | string | null
    linkedinUrl?: StringNullableFilter<"Contact"> | string | null
    avatar?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    relationshipScore?: FloatNullableFilter<"Contact"> | number | null
    lastContact?: DateTimeNullableFilter<"Contact"> | Date | string | null
    status?: StringFilter<"Contact"> | string
    isKeyContact?: BoolFilter<"Contact"> | boolean
    source?: StringNullableFilter<"Contact"> | string | null
    metadata?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    activities?: ActivityListRelationFilter
    communications?: CommunicationListRelationFilter
    teamsMessages?: TeamsMessageListRelationFilter
    slackMessages?: SlackMessageListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    googleContactId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    relationshipScore?: SortOrderInput | SortOrder
    lastContact?: SortOrderInput | SortOrder
    status?: SortOrder
    isKeyContact?: SortOrder
    source?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    activities?: ActivityOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
    teamsMessages?: TeamsMessageOrderByRelationAggregateInput
    slackMessages?: SlackMessageOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_email?: ContactUserIdEmailCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    userId?: StringFilter<"Contact"> | string
    dealId?: StringNullableFilter<"Contact"> | string | null
    googleContactId?: StringNullableFilter<"Contact"> | string | null
    name?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    title?: StringNullableFilter<"Contact"> | string | null
    role?: StringNullableFilter<"Contact"> | string | null
    linkedinUrl?: StringNullableFilter<"Contact"> | string | null
    avatar?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    relationshipScore?: FloatNullableFilter<"Contact"> | number | null
    lastContact?: DateTimeNullableFilter<"Contact"> | Date | string | null
    status?: StringFilter<"Contact"> | string
    isKeyContact?: BoolFilter<"Contact"> | boolean
    source?: StringNullableFilter<"Contact"> | string | null
    metadata?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    activities?: ActivityListRelationFilter
    communications?: CommunicationListRelationFilter
    teamsMessages?: TeamsMessageListRelationFilter
    slackMessages?: SlackMessageListRelationFilter
  }, "id" | "userId_email">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    googleContactId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    relationshipScore?: SortOrderInput | SortOrder
    lastContact?: SortOrderInput | SortOrder
    status?: SortOrder
    isKeyContact?: SortOrder
    source?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    userId?: StringWithAggregatesFilter<"Contact"> | string
    dealId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    googleContactId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    title?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    role?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    relationshipScore?: FloatNullableWithAggregatesFilter<"Contact"> | number | null
    lastContact?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    status?: StringWithAggregatesFilter<"Contact"> | string
    isKeyContact?: BoolWithAggregatesFilter<"Contact"> | boolean
    source?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Contact">
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    dealId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    content?: StringNullableFilter<"Activity"> | string | null
    date?: DateTimeFilter<"Activity"> | Date | string
    duration?: IntNullableFilter<"Activity"> | number | null
    location?: StringNullableFilter<"Activity"> | string | null
    attendees?: StringNullableListFilter<"Activity">
    status?: StringFilter<"Activity"> | string
    priority?: StringFilter<"Activity"> | string
    outcome?: StringNullableFilter<"Activity"> | string | null
    nextSteps?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonNullableFilter<"Activity">
    externalId?: StringNullableFilter<"Activity"> | string | null
    syncedFrom?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    date?: SortOrder
    duration?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    attendees?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    outcome?: SortOrderInput | SortOrder
    nextSteps?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    syncedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    dealId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    content?: StringNullableFilter<"Activity"> | string | null
    date?: DateTimeFilter<"Activity"> | Date | string
    duration?: IntNullableFilter<"Activity"> | number | null
    location?: StringNullableFilter<"Activity"> | string | null
    attendees?: StringNullableListFilter<"Activity">
    status?: StringFilter<"Activity"> | string
    priority?: StringFilter<"Activity"> | string
    outcome?: StringNullableFilter<"Activity"> | string | null
    nextSteps?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonNullableFilter<"Activity">
    externalId?: StringNullableFilter<"Activity"> | string | null
    syncedFrom?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    date?: SortOrder
    duration?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    attendees?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    outcome?: SortOrderInput | SortOrder
    nextSteps?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    syncedFrom?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    dealId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    type?: StringWithAggregatesFilter<"Activity"> | string
    title?: StringWithAggregatesFilter<"Activity"> | string
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    content?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    date?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    duration?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    location?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    attendees?: StringNullableListFilter<"Activity">
    status?: StringWithAggregatesFilter<"Activity"> | string
    priority?: StringWithAggregatesFilter<"Activity"> | string
    outcome?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    nextSteps?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Activity">
    externalId?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    syncedFrom?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    dealId?: StringNullableFilter<"Document"> | string | null
    name?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    type?: StringFilter<"Document"> | string
    category?: StringNullableFilter<"Document"> | string | null
    size?: IntNullableFilter<"Document"> | number | null
    url?: StringNullableFilter<"Document"> | string | null
    googleDriveId?: StringNullableFilter<"Document"> | string | null
    path?: StringNullableFilter<"Document"> | string | null
    version?: StringFilter<"Document"> | string
    isConfidential?: BoolFilter<"Document"> | boolean
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    tags?: StringNullableListFilter<"Document">
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    googleDriveId?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    version?: SortOrder
    isConfidential?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringFilter<"Document"> | string
    dealId?: StringNullableFilter<"Document"> | string | null
    name?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    type?: StringFilter<"Document"> | string
    category?: StringNullableFilter<"Document"> | string | null
    size?: IntNullableFilter<"Document"> | number | null
    url?: StringNullableFilter<"Document"> | string | null
    googleDriveId?: StringNullableFilter<"Document"> | string | null
    path?: StringNullableFilter<"Document"> | string | null
    version?: StringFilter<"Document"> | string
    isConfidential?: BoolFilter<"Document"> | boolean
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    tags?: StringNullableListFilter<"Document">
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    googleDriveId?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    version?: SortOrder
    isConfidential?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    userId?: StringWithAggregatesFilter<"Document"> | string
    dealId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    name?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    type?: StringWithAggregatesFilter<"Document"> | string
    category?: StringNullableWithAggregatesFilter<"Document"> | string | null
    size?: IntNullableWithAggregatesFilter<"Document"> | number | null
    url?: StringNullableWithAggregatesFilter<"Document"> | string | null
    googleDriveId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    path?: StringNullableWithAggregatesFilter<"Document"> | string | null
    version?: StringWithAggregatesFilter<"Document"> | string
    isConfidential?: BoolWithAggregatesFilter<"Document"> | boolean
    uploadedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    tags?: StringNullableListFilter<"Document">
    metadata?: JsonNullableWithAggregatesFilter<"Document">
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type CommunicationWhereInput = {
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    id?: StringFilter<"Communication"> | string
    userId?: StringFilter<"Communication"> | string
    dealId?: StringNullableFilter<"Communication"> | string | null
    contactId?: StringNullableFilter<"Communication"> | string | null
    type?: StringFilter<"Communication"> | string
    subject?: StringNullableFilter<"Communication"> | string | null
    content?: StringNullableFilter<"Communication"> | string | null
    htmlContent?: StringNullableFilter<"Communication"> | string | null
    fromEmail?: StringNullableFilter<"Communication"> | string | null
    toEmails?: StringNullableListFilter<"Communication">
    ccEmails?: StringNullableListFilter<"Communication">
    bccEmails?: StringNullableListFilter<"Communication">
    threadId?: StringNullableFilter<"Communication"> | string | null
    messageId?: StringNullableFilter<"Communication"> | string | null
    status?: StringFilter<"Communication"> | string
    direction?: StringFilter<"Communication"> | string
    isRead?: BoolFilter<"Communication"> | boolean
    isImportant?: BoolFilter<"Communication"> | boolean
    labels?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableFilter<"Communication">
    metadata?: JsonNullableFilter<"Communication">
    sentAt?: DateTimeNullableFilter<"Communication"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type CommunicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    fromEmail?: SortOrderInput | SortOrder
    toEmails?: SortOrder
    ccEmails?: SortOrder
    bccEmails?: SortOrder
    threadId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    status?: SortOrder
    direction?: SortOrder
    isRead?: SortOrder
    isImportant?: SortOrder
    labels?: SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type CommunicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    userId?: StringFilter<"Communication"> | string
    dealId?: StringNullableFilter<"Communication"> | string | null
    contactId?: StringNullableFilter<"Communication"> | string | null
    type?: StringFilter<"Communication"> | string
    subject?: StringNullableFilter<"Communication"> | string | null
    content?: StringNullableFilter<"Communication"> | string | null
    htmlContent?: StringNullableFilter<"Communication"> | string | null
    fromEmail?: StringNullableFilter<"Communication"> | string | null
    toEmails?: StringNullableListFilter<"Communication">
    ccEmails?: StringNullableListFilter<"Communication">
    bccEmails?: StringNullableListFilter<"Communication">
    threadId?: StringNullableFilter<"Communication"> | string | null
    messageId?: StringNullableFilter<"Communication"> | string | null
    status?: StringFilter<"Communication"> | string
    direction?: StringFilter<"Communication"> | string
    isRead?: BoolFilter<"Communication"> | boolean
    isImportant?: BoolFilter<"Communication"> | boolean
    labels?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableFilter<"Communication">
    metadata?: JsonNullableFilter<"Communication">
    sentAt?: DateTimeNullableFilter<"Communication"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id">

  export type CommunicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    htmlContent?: SortOrderInput | SortOrder
    fromEmail?: SortOrderInput | SortOrder
    toEmails?: SortOrder
    ccEmails?: SortOrder
    bccEmails?: SortOrder
    threadId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    status?: SortOrder
    direction?: SortOrder
    isRead?: SortOrder
    isImportant?: SortOrder
    labels?: SortOrder
    attachments?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    receivedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunicationCountOrderByAggregateInput
    _max?: CommunicationMaxOrderByAggregateInput
    _min?: CommunicationMinOrderByAggregateInput
  }

  export type CommunicationScalarWhereWithAggregatesInput = {
    AND?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    OR?: CommunicationScalarWhereWithAggregatesInput[]
    NOT?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Communication"> | string
    userId?: StringWithAggregatesFilter<"Communication"> | string
    dealId?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    type?: StringWithAggregatesFilter<"Communication"> | string
    subject?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    content?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    htmlContent?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    fromEmail?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    toEmails?: StringNullableListFilter<"Communication">
    ccEmails?: StringNullableListFilter<"Communication">
    bccEmails?: StringNullableListFilter<"Communication">
    threadId?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    status?: StringWithAggregatesFilter<"Communication"> | string
    direction?: StringWithAggregatesFilter<"Communication"> | string
    isRead?: BoolWithAggregatesFilter<"Communication"> | boolean
    isImportant?: BoolWithAggregatesFilter<"Communication"> | boolean
    labels?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableWithAggregatesFilter<"Communication">
    metadata?: JsonNullableWithAggregatesFilter<"Communication">
    sentAt?: DateTimeNullableWithAggregatesFilter<"Communication"> | Date | string | null
    receivedAt?: DateTimeNullableWithAggregatesFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
  }

  export type InvestorWhereInput = {
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    id?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: StringFilter<"Investor"> | string
    status?: StringFilter<"Investor"> | string
    totalCommitment?: FloatNullableFilter<"Investor"> | number | null
    totalCalled?: FloatNullableFilter<"Investor"> | number | null
    description?: StringNullableFilter<"Investor"> | string | null
    website?: StringNullableFilter<"Investor"> | string | null
    location?: StringNullableFilter<"Investor"> | string | null
    founded?: DateTimeNullableFilter<"Investor"> | Date | string | null
    aum?: FloatNullableFilter<"Investor"> | number | null
    tags?: StringNullableListFilter<"Investor">
    metadata?: JsonNullableFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    entities?: InvestorEntityListRelationFilter
    groupMemberships?: InvestorGroupMemberListRelationFilter
  }

  export type InvestorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalCommitment?: SortOrderInput | SortOrder
    totalCalled?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    founded?: SortOrderInput | SortOrder
    aum?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    entities?: InvestorEntityOrderByRelationAggregateInput
    groupMemberships?: InvestorGroupMemberOrderByRelationAggregateInput
  }

  export type InvestorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestorWhereInput | InvestorWhereInput[]
    OR?: InvestorWhereInput[]
    NOT?: InvestorWhereInput | InvestorWhereInput[]
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: StringFilter<"Investor"> | string
    status?: StringFilter<"Investor"> | string
    totalCommitment?: FloatNullableFilter<"Investor"> | number | null
    totalCalled?: FloatNullableFilter<"Investor"> | number | null
    description?: StringNullableFilter<"Investor"> | string | null
    website?: StringNullableFilter<"Investor"> | string | null
    location?: StringNullableFilter<"Investor"> | string | null
    founded?: DateTimeNullableFilter<"Investor"> | Date | string | null
    aum?: FloatNullableFilter<"Investor"> | number | null
    tags?: StringNullableListFilter<"Investor">
    metadata?: JsonNullableFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    entities?: InvestorEntityListRelationFilter
    groupMemberships?: InvestorGroupMemberListRelationFilter
  }, "id">

  export type InvestorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalCommitment?: SortOrderInput | SortOrder
    totalCalled?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    founded?: SortOrderInput | SortOrder
    aum?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorCountOrderByAggregateInput
    _avg?: InvestorAvgOrderByAggregateInput
    _max?: InvestorMaxOrderByAggregateInput
    _min?: InvestorMinOrderByAggregateInput
    _sum?: InvestorSumOrderByAggregateInput
  }

  export type InvestorScalarWhereWithAggregatesInput = {
    AND?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    OR?: InvestorScalarWhereWithAggregatesInput[]
    NOT?: InvestorScalarWhereWithAggregatesInput | InvestorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Investor"> | string
    userId?: StringWithAggregatesFilter<"Investor"> | string
    name?: StringWithAggregatesFilter<"Investor"> | string
    type?: StringWithAggregatesFilter<"Investor"> | string
    status?: StringWithAggregatesFilter<"Investor"> | string
    totalCommitment?: FloatNullableWithAggregatesFilter<"Investor"> | number | null
    totalCalled?: FloatNullableWithAggregatesFilter<"Investor"> | number | null
    description?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    website?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    location?: StringNullableWithAggregatesFilter<"Investor"> | string | null
    founded?: DateTimeNullableWithAggregatesFilter<"Investor"> | Date | string | null
    aum?: FloatNullableWithAggregatesFilter<"Investor"> | number | null
    tags?: StringNullableListFilter<"Investor">
    metadata?: JsonNullableWithAggregatesFilter<"Investor">
    createdAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Investor"> | Date | string
  }

  export type FundWhereInput = {
    AND?: FundWhereInput | FundWhereInput[]
    OR?: FundWhereInput[]
    NOT?: FundWhereInput | FundWhereInput[]
    id?: StringFilter<"Fund"> | string
    userId?: StringFilter<"Fund"> | string
    name?: StringFilter<"Fund"> | string
    type?: StringFilter<"Fund"> | string
    strategy?: StringNullableFilter<"Fund"> | string | null
    targetSize?: FloatFilter<"Fund"> | number
    minimumCommitment?: FloatNullableFilter<"Fund"> | number | null
    managementFee?: FloatNullableFilter<"Fund"> | number | null
    carriedInterest?: FloatNullableFilter<"Fund"> | number | null
    currency?: StringFilter<"Fund"> | string
    vintage?: IntNullableFilter<"Fund"> | number | null
    investmentPeriod?: IntNullableFilter<"Fund"> | number | null
    fundTerm?: IntNullableFilter<"Fund"> | number | null
    geoFocus?: StringNullableFilter<"Fund"> | string | null
    sectorFocus?: StringNullableFilter<"Fund"> | string | null
    description?: StringNullableFilter<"Fund"> | string | null
    status?: StringFilter<"Fund"> | string
    raisedAmount?: FloatFilter<"Fund"> | number
    investorCount?: IntFilter<"Fund"> | number
    metadata?: JsonNullableFilter<"Fund">
    createdAt?: DateTimeFilter<"Fund"> | Date | string
    updatedAt?: DateTimeFilter<"Fund"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FundOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    strategy?: SortOrderInput | SortOrder
    targetSize?: SortOrder
    minimumCommitment?: SortOrderInput | SortOrder
    managementFee?: SortOrderInput | SortOrder
    carriedInterest?: SortOrderInput | SortOrder
    currency?: SortOrder
    vintage?: SortOrderInput | SortOrder
    investmentPeriod?: SortOrderInput | SortOrder
    fundTerm?: SortOrderInput | SortOrder
    geoFocus?: SortOrderInput | SortOrder
    sectorFocus?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FundWhereInput | FundWhereInput[]
    OR?: FundWhereInput[]
    NOT?: FundWhereInput | FundWhereInput[]
    userId?: StringFilter<"Fund"> | string
    name?: StringFilter<"Fund"> | string
    type?: StringFilter<"Fund"> | string
    strategy?: StringNullableFilter<"Fund"> | string | null
    targetSize?: FloatFilter<"Fund"> | number
    minimumCommitment?: FloatNullableFilter<"Fund"> | number | null
    managementFee?: FloatNullableFilter<"Fund"> | number | null
    carriedInterest?: FloatNullableFilter<"Fund"> | number | null
    currency?: StringFilter<"Fund"> | string
    vintage?: IntNullableFilter<"Fund"> | number | null
    investmentPeriod?: IntNullableFilter<"Fund"> | number | null
    fundTerm?: IntNullableFilter<"Fund"> | number | null
    geoFocus?: StringNullableFilter<"Fund"> | string | null
    sectorFocus?: StringNullableFilter<"Fund"> | string | null
    description?: StringNullableFilter<"Fund"> | string | null
    status?: StringFilter<"Fund"> | string
    raisedAmount?: FloatFilter<"Fund"> | number
    investorCount?: IntFilter<"Fund"> | number
    metadata?: JsonNullableFilter<"Fund">
    createdAt?: DateTimeFilter<"Fund"> | Date | string
    updatedAt?: DateTimeFilter<"Fund"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FundOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    strategy?: SortOrderInput | SortOrder
    targetSize?: SortOrder
    minimumCommitment?: SortOrderInput | SortOrder
    managementFee?: SortOrderInput | SortOrder
    carriedInterest?: SortOrderInput | SortOrder
    currency?: SortOrder
    vintage?: SortOrderInput | SortOrder
    investmentPeriod?: SortOrderInput | SortOrder
    fundTerm?: SortOrderInput | SortOrder
    geoFocus?: SortOrderInput | SortOrder
    sectorFocus?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FundCountOrderByAggregateInput
    _avg?: FundAvgOrderByAggregateInput
    _max?: FundMaxOrderByAggregateInput
    _min?: FundMinOrderByAggregateInput
    _sum?: FundSumOrderByAggregateInput
  }

  export type FundScalarWhereWithAggregatesInput = {
    AND?: FundScalarWhereWithAggregatesInput | FundScalarWhereWithAggregatesInput[]
    OR?: FundScalarWhereWithAggregatesInput[]
    NOT?: FundScalarWhereWithAggregatesInput | FundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fund"> | string
    userId?: StringWithAggregatesFilter<"Fund"> | string
    name?: StringWithAggregatesFilter<"Fund"> | string
    type?: StringWithAggregatesFilter<"Fund"> | string
    strategy?: StringNullableWithAggregatesFilter<"Fund"> | string | null
    targetSize?: FloatWithAggregatesFilter<"Fund"> | number
    minimumCommitment?: FloatNullableWithAggregatesFilter<"Fund"> | number | null
    managementFee?: FloatNullableWithAggregatesFilter<"Fund"> | number | null
    carriedInterest?: FloatNullableWithAggregatesFilter<"Fund"> | number | null
    currency?: StringWithAggregatesFilter<"Fund"> | string
    vintage?: IntNullableWithAggregatesFilter<"Fund"> | number | null
    investmentPeriod?: IntNullableWithAggregatesFilter<"Fund"> | number | null
    fundTerm?: IntNullableWithAggregatesFilter<"Fund"> | number | null
    geoFocus?: StringNullableWithAggregatesFilter<"Fund"> | string | null
    sectorFocus?: StringNullableWithAggregatesFilter<"Fund"> | string | null
    description?: StringNullableWithAggregatesFilter<"Fund"> | string | null
    status?: StringWithAggregatesFilter<"Fund"> | string
    raisedAmount?: FloatWithAggregatesFilter<"Fund"> | number
    investorCount?: IntWithAggregatesFilter<"Fund"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Fund">
    createdAt?: DateTimeWithAggregatesFilter<"Fund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fund"> | Date | string
  }

  export type InvestorEntityWhereInput = {
    AND?: InvestorEntityWhereInput | InvestorEntityWhereInput[]
    OR?: InvestorEntityWhereInput[]
    NOT?: InvestorEntityWhereInput | InvestorEntityWhereInput[]
    id?: StringFilter<"InvestorEntity"> | string
    investorId?: StringFilter<"InvestorEntity"> | string
    name?: StringFilter<"InvestorEntity"> | string
    type?: StringFilter<"InvestorEntity"> | string
    investmentType?: StringFilter<"InvestorEntity"> | string
    commitment?: FloatNullableFilter<"InvestorEntity"> | number | null
    called?: FloatNullableFilter<"InvestorEntity"> | number | null
    status?: StringFilter<"InvestorEntity"> | string
    documents?: JsonNullableFilter<"InvestorEntity">
    fundInvestments?: JsonNullableFilter<"InvestorEntity">
    createdAt?: DateTimeFilter<"InvestorEntity"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorEntity"> | Date | string
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
  }

  export type InvestorEntityOrderByWithRelationInput = {
    id?: SortOrder
    investorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    investmentType?: SortOrder
    commitment?: SortOrderInput | SortOrder
    called?: SortOrderInput | SortOrder
    status?: SortOrder
    documents?: SortOrderInput | SortOrder
    fundInvestments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    investor?: InvestorOrderByWithRelationInput
  }

  export type InvestorEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestorEntityWhereInput | InvestorEntityWhereInput[]
    OR?: InvestorEntityWhereInput[]
    NOT?: InvestorEntityWhereInput | InvestorEntityWhereInput[]
    investorId?: StringFilter<"InvestorEntity"> | string
    name?: StringFilter<"InvestorEntity"> | string
    type?: StringFilter<"InvestorEntity"> | string
    investmentType?: StringFilter<"InvestorEntity"> | string
    commitment?: FloatNullableFilter<"InvestorEntity"> | number | null
    called?: FloatNullableFilter<"InvestorEntity"> | number | null
    status?: StringFilter<"InvestorEntity"> | string
    documents?: JsonNullableFilter<"InvestorEntity">
    fundInvestments?: JsonNullableFilter<"InvestorEntity">
    createdAt?: DateTimeFilter<"InvestorEntity"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorEntity"> | Date | string
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
  }, "id">

  export type InvestorEntityOrderByWithAggregationInput = {
    id?: SortOrder
    investorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    investmentType?: SortOrder
    commitment?: SortOrderInput | SortOrder
    called?: SortOrderInput | SortOrder
    status?: SortOrder
    documents?: SortOrderInput | SortOrder
    fundInvestments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvestorEntityCountOrderByAggregateInput
    _avg?: InvestorEntityAvgOrderByAggregateInput
    _max?: InvestorEntityMaxOrderByAggregateInput
    _min?: InvestorEntityMinOrderByAggregateInput
    _sum?: InvestorEntitySumOrderByAggregateInput
  }

  export type InvestorEntityScalarWhereWithAggregatesInput = {
    AND?: InvestorEntityScalarWhereWithAggregatesInput | InvestorEntityScalarWhereWithAggregatesInput[]
    OR?: InvestorEntityScalarWhereWithAggregatesInput[]
    NOT?: InvestorEntityScalarWhereWithAggregatesInput | InvestorEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorEntity"> | string
    investorId?: StringWithAggregatesFilter<"InvestorEntity"> | string
    name?: StringWithAggregatesFilter<"InvestorEntity"> | string
    type?: StringWithAggregatesFilter<"InvestorEntity"> | string
    investmentType?: StringWithAggregatesFilter<"InvestorEntity"> | string
    commitment?: FloatNullableWithAggregatesFilter<"InvestorEntity"> | number | null
    called?: FloatNullableWithAggregatesFilter<"InvestorEntity"> | number | null
    status?: StringWithAggregatesFilter<"InvestorEntity"> | string
    documents?: JsonNullableWithAggregatesFilter<"InvestorEntity">
    fundInvestments?: JsonNullableWithAggregatesFilter<"InvestorEntity">
    createdAt?: DateTimeWithAggregatesFilter<"InvestorEntity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvestorEntity"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    content?: StringNullableFilter<"Report"> | string | null
    data?: JsonNullableFilter<"Report">
    url?: StringNullableFilter<"Report"> | string | null
    status?: StringFilter<"Report"> | string
    recipients?: StringNullableListFilter<"Report">
    sentAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    generatedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    metadata?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    status?: SortOrder
    recipients?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    userId?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    format?: StringFilter<"Report"> | string
    content?: StringNullableFilter<"Report"> | string | null
    data?: JsonNullableFilter<"Report">
    url?: StringNullableFilter<"Report"> | string | null
    status?: StringFilter<"Report"> | string
    recipients?: StringNullableListFilter<"Report">
    sentAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    generatedAt?: DateTimeNullableFilter<"Report"> | Date | string | null
    metadata?: JsonNullableFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    format?: SortOrder
    content?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    status?: SortOrder
    recipients?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    generatedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    userId?: StringWithAggregatesFilter<"Report"> | string
    title?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    format?: StringWithAggregatesFilter<"Report"> | string
    content?: StringNullableWithAggregatesFilter<"Report"> | string | null
    data?: JsonNullableWithAggregatesFilter<"Report">
    url?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: StringWithAggregatesFilter<"Report"> | string
    recipients?: StringNullableListFilter<"Report">
    sentAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    generatedAt?: DateTimeNullableWithAggregatesFilter<"Report"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Report">
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type SyncJobWhereInput = {
    AND?: SyncJobWhereInput | SyncJobWhereInput[]
    OR?: SyncJobWhereInput[]
    NOT?: SyncJobWhereInput | SyncJobWhereInput[]
    id?: StringFilter<"SyncJob"> | string
    userId?: StringFilter<"SyncJob"> | string
    type?: StringFilter<"SyncJob"> | string
    status?: StringFilter<"SyncJob"> | string
    startedAt?: DateTimeNullableFilter<"SyncJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SyncJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"SyncJob"> | string | null
    itemsProcessed?: IntNullableFilter<"SyncJob"> | number | null
    metadata?: JsonNullableFilter<"SyncJob">
    createdAt?: DateTimeFilter<"SyncJob"> | Date | string
    updatedAt?: DateTimeFilter<"SyncJob"> | Date | string
  }

  export type SyncJobOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    itemsProcessed?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncJobWhereInput | SyncJobWhereInput[]
    OR?: SyncJobWhereInput[]
    NOT?: SyncJobWhereInput | SyncJobWhereInput[]
    userId?: StringFilter<"SyncJob"> | string
    type?: StringFilter<"SyncJob"> | string
    status?: StringFilter<"SyncJob"> | string
    startedAt?: DateTimeNullableFilter<"SyncJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"SyncJob"> | Date | string | null
    errorMessage?: StringNullableFilter<"SyncJob"> | string | null
    itemsProcessed?: IntNullableFilter<"SyncJob"> | number | null
    metadata?: JsonNullableFilter<"SyncJob">
    createdAt?: DateTimeFilter<"SyncJob"> | Date | string
    updatedAt?: DateTimeFilter<"SyncJob"> | Date | string
  }, "id">

  export type SyncJobOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    itemsProcessed?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SyncJobCountOrderByAggregateInput
    _avg?: SyncJobAvgOrderByAggregateInput
    _max?: SyncJobMaxOrderByAggregateInput
    _min?: SyncJobMinOrderByAggregateInput
    _sum?: SyncJobSumOrderByAggregateInput
  }

  export type SyncJobScalarWhereWithAggregatesInput = {
    AND?: SyncJobScalarWhereWithAggregatesInput | SyncJobScalarWhereWithAggregatesInput[]
    OR?: SyncJobScalarWhereWithAggregatesInput[]
    NOT?: SyncJobScalarWhereWithAggregatesInput | SyncJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncJob"> | string
    userId?: StringWithAggregatesFilter<"SyncJob"> | string
    type?: StringWithAggregatesFilter<"SyncJob"> | string
    status?: StringWithAggregatesFilter<"SyncJob"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"SyncJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncJob"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"SyncJob"> | string | null
    itemsProcessed?: IntNullableWithAggregatesFilter<"SyncJob"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"SyncJob">
    createdAt?: DateTimeWithAggregatesFilter<"SyncJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SyncJob"> | Date | string
  }

  export type TeamsMessageWhereInput = {
    AND?: TeamsMessageWhereInput | TeamsMessageWhereInput[]
    OR?: TeamsMessageWhereInput[]
    NOT?: TeamsMessageWhereInput | TeamsMessageWhereInput[]
    id?: StringFilter<"TeamsMessage"> | string
    userId?: StringFilter<"TeamsMessage"> | string
    dealId?: StringNullableFilter<"TeamsMessage"> | string | null
    contactId?: StringNullableFilter<"TeamsMessage"> | string | null
    messageId?: StringFilter<"TeamsMessage"> | string
    chatId?: StringNullableFilter<"TeamsMessage"> | string | null
    channelId?: StringNullableFilter<"TeamsMessage"> | string | null
    teamId?: StringNullableFilter<"TeamsMessage"> | string | null
    fromEmail?: StringFilter<"TeamsMessage"> | string
    fromName?: StringFilter<"TeamsMessage"> | string
    content?: StringFilter<"TeamsMessage"> | string
    contentType?: StringFilter<"TeamsMessage"> | string
    importance?: StringFilter<"TeamsMessage"> | string
    messageType?: StringFilter<"TeamsMessage"> | string
    attachments?: JsonNullableFilter<"TeamsMessage">
    mentions?: StringNullableListFilter<"TeamsMessage">
    createdAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    updatedAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    sentAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type TeamsMessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    messageId?: SortOrder
    chatId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    importance?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrderInput | SortOrder
    mentions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type TeamsMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: TeamsMessageWhereInput | TeamsMessageWhereInput[]
    OR?: TeamsMessageWhereInput[]
    NOT?: TeamsMessageWhereInput | TeamsMessageWhereInput[]
    userId?: StringFilter<"TeamsMessage"> | string
    dealId?: StringNullableFilter<"TeamsMessage"> | string | null
    contactId?: StringNullableFilter<"TeamsMessage"> | string | null
    chatId?: StringNullableFilter<"TeamsMessage"> | string | null
    channelId?: StringNullableFilter<"TeamsMessage"> | string | null
    teamId?: StringNullableFilter<"TeamsMessage"> | string | null
    fromEmail?: StringFilter<"TeamsMessage"> | string
    fromName?: StringFilter<"TeamsMessage"> | string
    content?: StringFilter<"TeamsMessage"> | string
    contentType?: StringFilter<"TeamsMessage"> | string
    importance?: StringFilter<"TeamsMessage"> | string
    messageType?: StringFilter<"TeamsMessage"> | string
    attachments?: JsonNullableFilter<"TeamsMessage">
    mentions?: StringNullableListFilter<"TeamsMessage">
    createdAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    updatedAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    sentAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id" | "messageId">

  export type TeamsMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    messageId?: SortOrder
    chatId?: SortOrderInput | SortOrder
    channelId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    importance?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrderInput | SortOrder
    mentions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
    _count?: TeamsMessageCountOrderByAggregateInput
    _max?: TeamsMessageMaxOrderByAggregateInput
    _min?: TeamsMessageMinOrderByAggregateInput
  }

  export type TeamsMessageScalarWhereWithAggregatesInput = {
    AND?: TeamsMessageScalarWhereWithAggregatesInput | TeamsMessageScalarWhereWithAggregatesInput[]
    OR?: TeamsMessageScalarWhereWithAggregatesInput[]
    NOT?: TeamsMessageScalarWhereWithAggregatesInput | TeamsMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamsMessage"> | string
    userId?: StringWithAggregatesFilter<"TeamsMessage"> | string
    dealId?: StringNullableWithAggregatesFilter<"TeamsMessage"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"TeamsMessage"> | string | null
    messageId?: StringWithAggregatesFilter<"TeamsMessage"> | string
    chatId?: StringNullableWithAggregatesFilter<"TeamsMessage"> | string | null
    channelId?: StringNullableWithAggregatesFilter<"TeamsMessage"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"TeamsMessage"> | string | null
    fromEmail?: StringWithAggregatesFilter<"TeamsMessage"> | string
    fromName?: StringWithAggregatesFilter<"TeamsMessage"> | string
    content?: StringWithAggregatesFilter<"TeamsMessage"> | string
    contentType?: StringWithAggregatesFilter<"TeamsMessage"> | string
    importance?: StringWithAggregatesFilter<"TeamsMessage"> | string
    messageType?: StringWithAggregatesFilter<"TeamsMessage"> | string
    attachments?: JsonNullableWithAggregatesFilter<"TeamsMessage">
    mentions?: StringNullableListFilter<"TeamsMessage">
    createdAt?: DateTimeWithAggregatesFilter<"TeamsMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamsMessage"> | Date | string
    sentAt?: DateTimeWithAggregatesFilter<"TeamsMessage"> | Date | string
  }

  export type TeamsChannelWhereInput = {
    AND?: TeamsChannelWhereInput | TeamsChannelWhereInput[]
    OR?: TeamsChannelWhereInput[]
    NOT?: TeamsChannelWhereInput | TeamsChannelWhereInput[]
    id?: StringFilter<"TeamsChannel"> | string
    userId?: StringFilter<"TeamsChannel"> | string
    channelId?: StringFilter<"TeamsChannel"> | string
    teamId?: StringFilter<"TeamsChannel"> | string
    name?: StringFilter<"TeamsChannel"> | string
    description?: StringNullableFilter<"TeamsChannel"> | string | null
    type?: StringFilter<"TeamsChannel"> | string
    webUrl?: StringNullableFilter<"TeamsChannel"> | string | null
    memberCount?: IntNullableFilter<"TeamsChannel"> | number | null
    isArchived?: BoolFilter<"TeamsChannel"> | boolean
    metadata?: JsonNullableFilter<"TeamsChannel">
    createdAt?: DateTimeFilter<"TeamsChannel"> | Date | string
    updatedAt?: DateTimeFilter<"TeamsChannel"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamsChannelOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    webUrl?: SortOrderInput | SortOrder
    memberCount?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TeamsChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId?: string
    AND?: TeamsChannelWhereInput | TeamsChannelWhereInput[]
    OR?: TeamsChannelWhereInput[]
    NOT?: TeamsChannelWhereInput | TeamsChannelWhereInput[]
    userId?: StringFilter<"TeamsChannel"> | string
    teamId?: StringFilter<"TeamsChannel"> | string
    name?: StringFilter<"TeamsChannel"> | string
    description?: StringNullableFilter<"TeamsChannel"> | string | null
    type?: StringFilter<"TeamsChannel"> | string
    webUrl?: StringNullableFilter<"TeamsChannel"> | string | null
    memberCount?: IntNullableFilter<"TeamsChannel"> | number | null
    isArchived?: BoolFilter<"TeamsChannel"> | boolean
    metadata?: JsonNullableFilter<"TeamsChannel">
    createdAt?: DateTimeFilter<"TeamsChannel"> | Date | string
    updatedAt?: DateTimeFilter<"TeamsChannel"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "channelId">

  export type TeamsChannelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    webUrl?: SortOrderInput | SortOrder
    memberCount?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamsChannelCountOrderByAggregateInput
    _avg?: TeamsChannelAvgOrderByAggregateInput
    _max?: TeamsChannelMaxOrderByAggregateInput
    _min?: TeamsChannelMinOrderByAggregateInput
    _sum?: TeamsChannelSumOrderByAggregateInput
  }

  export type TeamsChannelScalarWhereWithAggregatesInput = {
    AND?: TeamsChannelScalarWhereWithAggregatesInput | TeamsChannelScalarWhereWithAggregatesInput[]
    OR?: TeamsChannelScalarWhereWithAggregatesInput[]
    NOT?: TeamsChannelScalarWhereWithAggregatesInput | TeamsChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamsChannel"> | string
    userId?: StringWithAggregatesFilter<"TeamsChannel"> | string
    channelId?: StringWithAggregatesFilter<"TeamsChannel"> | string
    teamId?: StringWithAggregatesFilter<"TeamsChannel"> | string
    name?: StringWithAggregatesFilter<"TeamsChannel"> | string
    description?: StringNullableWithAggregatesFilter<"TeamsChannel"> | string | null
    type?: StringWithAggregatesFilter<"TeamsChannel"> | string
    webUrl?: StringNullableWithAggregatesFilter<"TeamsChannel"> | string | null
    memberCount?: IntNullableWithAggregatesFilter<"TeamsChannel"> | number | null
    isArchived?: BoolWithAggregatesFilter<"TeamsChannel"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"TeamsChannel">
    createdAt?: DateTimeWithAggregatesFilter<"TeamsChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamsChannel"> | Date | string
  }

  export type SlackMessageWhereInput = {
    AND?: SlackMessageWhereInput | SlackMessageWhereInput[]
    OR?: SlackMessageWhereInput[]
    NOT?: SlackMessageWhereInput | SlackMessageWhereInput[]
    id?: StringFilter<"SlackMessage"> | string
    userId?: StringFilter<"SlackMessage"> | string
    dealId?: StringNullableFilter<"SlackMessage"> | string | null
    contactId?: StringNullableFilter<"SlackMessage"> | string | null
    messageId?: StringFilter<"SlackMessage"> | string
    channelId?: StringFilter<"SlackMessage"> | string
    channelName?: StringNullableFilter<"SlackMessage"> | string | null
    fromUserId?: StringFilter<"SlackMessage"> | string
    fromName?: StringFilter<"SlackMessage"> | string
    text?: StringFilter<"SlackMessage"> | string
    messageType?: StringFilter<"SlackMessage"> | string
    threadTs?: StringNullableFilter<"SlackMessage"> | string | null
    attachments?: JsonNullableFilter<"SlackMessage">
    reactions?: JsonNullableFilter<"SlackMessage">
    mentions?: StringNullableListFilter<"SlackMessage">
    sentAt?: DateTimeFilter<"SlackMessage"> | Date | string
    createdAt?: DateTimeFilter<"SlackMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SlackMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type SlackMessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    messageId?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrderInput | SortOrder
    fromUserId?: SortOrder
    fromName?: SortOrder
    text?: SortOrder
    messageType?: SortOrder
    threadTs?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    mentions?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type SlackMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: SlackMessageWhereInput | SlackMessageWhereInput[]
    OR?: SlackMessageWhereInput[]
    NOT?: SlackMessageWhereInput | SlackMessageWhereInput[]
    userId?: StringFilter<"SlackMessage"> | string
    dealId?: StringNullableFilter<"SlackMessage"> | string | null
    contactId?: StringNullableFilter<"SlackMessage"> | string | null
    channelId?: StringFilter<"SlackMessage"> | string
    channelName?: StringNullableFilter<"SlackMessage"> | string | null
    fromUserId?: StringFilter<"SlackMessage"> | string
    fromName?: StringFilter<"SlackMessage"> | string
    text?: StringFilter<"SlackMessage"> | string
    messageType?: StringFilter<"SlackMessage"> | string
    threadTs?: StringNullableFilter<"SlackMessage"> | string | null
    attachments?: JsonNullableFilter<"SlackMessage">
    reactions?: JsonNullableFilter<"SlackMessage">
    mentions?: StringNullableListFilter<"SlackMessage">
    sentAt?: DateTimeFilter<"SlackMessage"> | Date | string
    createdAt?: DateTimeFilter<"SlackMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SlackMessage"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id" | "messageId">

  export type SlackMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    messageId?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrderInput | SortOrder
    fromUserId?: SortOrder
    fromName?: SortOrder
    text?: SortOrder
    messageType?: SortOrder
    threadTs?: SortOrderInput | SortOrder
    attachments?: SortOrderInput | SortOrder
    reactions?: SortOrderInput | SortOrder
    mentions?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SlackMessageCountOrderByAggregateInput
    _max?: SlackMessageMaxOrderByAggregateInput
    _min?: SlackMessageMinOrderByAggregateInput
  }

  export type SlackMessageScalarWhereWithAggregatesInput = {
    AND?: SlackMessageScalarWhereWithAggregatesInput | SlackMessageScalarWhereWithAggregatesInput[]
    OR?: SlackMessageScalarWhereWithAggregatesInput[]
    NOT?: SlackMessageScalarWhereWithAggregatesInput | SlackMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SlackMessage"> | string
    userId?: StringWithAggregatesFilter<"SlackMessage"> | string
    dealId?: StringNullableWithAggregatesFilter<"SlackMessage"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"SlackMessage"> | string | null
    messageId?: StringWithAggregatesFilter<"SlackMessage"> | string
    channelId?: StringWithAggregatesFilter<"SlackMessage"> | string
    channelName?: StringNullableWithAggregatesFilter<"SlackMessage"> | string | null
    fromUserId?: StringWithAggregatesFilter<"SlackMessage"> | string
    fromName?: StringWithAggregatesFilter<"SlackMessage"> | string
    text?: StringWithAggregatesFilter<"SlackMessage"> | string
    messageType?: StringWithAggregatesFilter<"SlackMessage"> | string
    threadTs?: StringNullableWithAggregatesFilter<"SlackMessage"> | string | null
    attachments?: JsonNullableWithAggregatesFilter<"SlackMessage">
    reactions?: JsonNullableWithAggregatesFilter<"SlackMessage">
    mentions?: StringNullableListFilter<"SlackMessage">
    sentAt?: DateTimeWithAggregatesFilter<"SlackMessage"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SlackMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SlackMessage"> | Date | string
  }

  export type SlackChannelWhereInput = {
    AND?: SlackChannelWhereInput | SlackChannelWhereInput[]
    OR?: SlackChannelWhereInput[]
    NOT?: SlackChannelWhereInput | SlackChannelWhereInput[]
    id?: StringFilter<"SlackChannel"> | string
    userId?: StringFilter<"SlackChannel"> | string
    channelId?: StringFilter<"SlackChannel"> | string
    name?: StringFilter<"SlackChannel"> | string
    purpose?: StringNullableFilter<"SlackChannel"> | string | null
    topic?: StringNullableFilter<"SlackChannel"> | string | null
    isPrivate?: BoolFilter<"SlackChannel"> | boolean
    isArchived?: BoolFilter<"SlackChannel"> | boolean
    memberCount?: IntNullableFilter<"SlackChannel"> | number | null
    metadata?: JsonNullableFilter<"SlackChannel">
    createdAt?: DateTimeFilter<"SlackChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SlackChannel"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SlackChannelOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    purpose?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    isArchived?: SortOrder
    memberCount?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SlackChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId?: string
    AND?: SlackChannelWhereInput | SlackChannelWhereInput[]
    OR?: SlackChannelWhereInput[]
    NOT?: SlackChannelWhereInput | SlackChannelWhereInput[]
    userId?: StringFilter<"SlackChannel"> | string
    name?: StringFilter<"SlackChannel"> | string
    purpose?: StringNullableFilter<"SlackChannel"> | string | null
    topic?: StringNullableFilter<"SlackChannel"> | string | null
    isPrivate?: BoolFilter<"SlackChannel"> | boolean
    isArchived?: BoolFilter<"SlackChannel"> | boolean
    memberCount?: IntNullableFilter<"SlackChannel"> | number | null
    metadata?: JsonNullableFilter<"SlackChannel">
    createdAt?: DateTimeFilter<"SlackChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SlackChannel"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "channelId">

  export type SlackChannelOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    purpose?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    isArchived?: SortOrder
    memberCount?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SlackChannelCountOrderByAggregateInput
    _avg?: SlackChannelAvgOrderByAggregateInput
    _max?: SlackChannelMaxOrderByAggregateInput
    _min?: SlackChannelMinOrderByAggregateInput
    _sum?: SlackChannelSumOrderByAggregateInput
  }

  export type SlackChannelScalarWhereWithAggregatesInput = {
    AND?: SlackChannelScalarWhereWithAggregatesInput | SlackChannelScalarWhereWithAggregatesInput[]
    OR?: SlackChannelScalarWhereWithAggregatesInput[]
    NOT?: SlackChannelScalarWhereWithAggregatesInput | SlackChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SlackChannel"> | string
    userId?: StringWithAggregatesFilter<"SlackChannel"> | string
    channelId?: StringWithAggregatesFilter<"SlackChannel"> | string
    name?: StringWithAggregatesFilter<"SlackChannel"> | string
    purpose?: StringNullableWithAggregatesFilter<"SlackChannel"> | string | null
    topic?: StringNullableWithAggregatesFilter<"SlackChannel"> | string | null
    isPrivate?: BoolWithAggregatesFilter<"SlackChannel"> | boolean
    isArchived?: BoolWithAggregatesFilter<"SlackChannel"> | boolean
    memberCount?: IntNullableWithAggregatesFilter<"SlackChannel"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"SlackChannel">
    createdAt?: DateTimeWithAggregatesFilter<"SlackChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SlackChannel"> | Date | string
  }

  export type ZoomMeetingWhereInput = {
    AND?: ZoomMeetingWhereInput | ZoomMeetingWhereInput[]
    OR?: ZoomMeetingWhereInput[]
    NOT?: ZoomMeetingWhereInput | ZoomMeetingWhereInput[]
    id?: StringFilter<"ZoomMeeting"> | string
    userId?: StringFilter<"ZoomMeeting"> | string
    dealId?: StringNullableFilter<"ZoomMeeting"> | string | null
    meetingId?: StringFilter<"ZoomMeeting"> | string
    uuid?: StringNullableFilter<"ZoomMeeting"> | string | null
    topic?: StringFilter<"ZoomMeeting"> | string
    agenda?: StringNullableFilter<"ZoomMeeting"> | string | null
    startTime?: DateTimeFilter<"ZoomMeeting"> | Date | string
    duration?: IntFilter<"ZoomMeeting"> | number
    timezone?: StringFilter<"ZoomMeeting"> | string
    status?: StringFilter<"ZoomMeeting"> | string
    meetingType?: StringFilter<"ZoomMeeting"> | string
    joinUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    startUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    password?: StringNullableFilter<"ZoomMeeting"> | string | null
    hostEmail?: StringNullableFilter<"ZoomMeeting"> | string | null
    participantCount?: IntNullableFilter<"ZoomMeeting"> | number | null
    hasRecording?: BoolFilter<"ZoomMeeting"> | boolean
    recordingUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    metadata?: JsonNullableFilter<"ZoomMeeting">
    createdAt?: DateTimeFilter<"ZoomMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"ZoomMeeting"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    participants?: ZoomParticipantListRelationFilter
  }

  export type ZoomMeetingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    meetingId?: SortOrder
    uuid?: SortOrderInput | SortOrder
    topic?: SortOrder
    agenda?: SortOrderInput | SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    meetingType?: SortOrder
    joinUrl?: SortOrderInput | SortOrder
    startUrl?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    hostEmail?: SortOrderInput | SortOrder
    participantCount?: SortOrderInput | SortOrder
    hasRecording?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    participants?: ZoomParticipantOrderByRelationAggregateInput
  }

  export type ZoomMeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meetingId?: string
    AND?: ZoomMeetingWhereInput | ZoomMeetingWhereInput[]
    OR?: ZoomMeetingWhereInput[]
    NOT?: ZoomMeetingWhereInput | ZoomMeetingWhereInput[]
    userId?: StringFilter<"ZoomMeeting"> | string
    dealId?: StringNullableFilter<"ZoomMeeting"> | string | null
    uuid?: StringNullableFilter<"ZoomMeeting"> | string | null
    topic?: StringFilter<"ZoomMeeting"> | string
    agenda?: StringNullableFilter<"ZoomMeeting"> | string | null
    startTime?: DateTimeFilter<"ZoomMeeting"> | Date | string
    duration?: IntFilter<"ZoomMeeting"> | number
    timezone?: StringFilter<"ZoomMeeting"> | string
    status?: StringFilter<"ZoomMeeting"> | string
    meetingType?: StringFilter<"ZoomMeeting"> | string
    joinUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    startUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    password?: StringNullableFilter<"ZoomMeeting"> | string | null
    hostEmail?: StringNullableFilter<"ZoomMeeting"> | string | null
    participantCount?: IntNullableFilter<"ZoomMeeting"> | number | null
    hasRecording?: BoolFilter<"ZoomMeeting"> | boolean
    recordingUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    metadata?: JsonNullableFilter<"ZoomMeeting">
    createdAt?: DateTimeFilter<"ZoomMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"ZoomMeeting"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    participants?: ZoomParticipantListRelationFilter
  }, "id" | "meetingId">

  export type ZoomMeetingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    meetingId?: SortOrder
    uuid?: SortOrderInput | SortOrder
    topic?: SortOrder
    agenda?: SortOrderInput | SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    meetingType?: SortOrder
    joinUrl?: SortOrderInput | SortOrder
    startUrl?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    hostEmail?: SortOrderInput | SortOrder
    participantCount?: SortOrderInput | SortOrder
    hasRecording?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoomMeetingCountOrderByAggregateInput
    _avg?: ZoomMeetingAvgOrderByAggregateInput
    _max?: ZoomMeetingMaxOrderByAggregateInput
    _min?: ZoomMeetingMinOrderByAggregateInput
    _sum?: ZoomMeetingSumOrderByAggregateInput
  }

  export type ZoomMeetingScalarWhereWithAggregatesInput = {
    AND?: ZoomMeetingScalarWhereWithAggregatesInput | ZoomMeetingScalarWhereWithAggregatesInput[]
    OR?: ZoomMeetingScalarWhereWithAggregatesInput[]
    NOT?: ZoomMeetingScalarWhereWithAggregatesInput | ZoomMeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    userId?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    dealId?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    meetingId?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    uuid?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    topic?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    agenda?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"ZoomMeeting"> | Date | string
    duration?: IntWithAggregatesFilter<"ZoomMeeting"> | number
    timezone?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    status?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    meetingType?: StringWithAggregatesFilter<"ZoomMeeting"> | string
    joinUrl?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    startUrl?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    password?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    hostEmail?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    participantCount?: IntNullableWithAggregatesFilter<"ZoomMeeting"> | number | null
    hasRecording?: BoolWithAggregatesFilter<"ZoomMeeting"> | boolean
    recordingUrl?: StringNullableWithAggregatesFilter<"ZoomMeeting"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ZoomMeeting">
    createdAt?: DateTimeWithAggregatesFilter<"ZoomMeeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ZoomMeeting"> | Date | string
  }

  export type ZoomParticipantWhereInput = {
    AND?: ZoomParticipantWhereInput | ZoomParticipantWhereInput[]
    OR?: ZoomParticipantWhereInput[]
    NOT?: ZoomParticipantWhereInput | ZoomParticipantWhereInput[]
    id?: StringFilter<"ZoomParticipant"> | string
    meetingId?: StringFilter<"ZoomParticipant"> | string
    userId?: StringNullableFilter<"ZoomParticipant"> | string | null
    zoomUserId?: StringNullableFilter<"ZoomParticipant"> | string | null
    name?: StringFilter<"ZoomParticipant"> | string
    email?: StringNullableFilter<"ZoomParticipant"> | string | null
    joinTime?: DateTimeFilter<"ZoomParticipant"> | Date | string
    leaveTime?: DateTimeNullableFilter<"ZoomParticipant"> | Date | string | null
    duration?: IntNullableFilter<"ZoomParticipant"> | number | null
    status?: StringFilter<"ZoomParticipant"> | string
    metadata?: JsonNullableFilter<"ZoomParticipant">
    createdAt?: DateTimeFilter<"ZoomParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ZoomParticipant"> | Date | string
    meeting?: XOR<ZoomMeetingScalarRelationFilter, ZoomMeetingWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ZoomParticipantOrderByWithRelationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrderInput | SortOrder
    zoomUserId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meeting?: ZoomMeetingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ZoomParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoomParticipantWhereInput | ZoomParticipantWhereInput[]
    OR?: ZoomParticipantWhereInput[]
    NOT?: ZoomParticipantWhereInput | ZoomParticipantWhereInput[]
    meetingId?: StringFilter<"ZoomParticipant"> | string
    userId?: StringNullableFilter<"ZoomParticipant"> | string | null
    zoomUserId?: StringNullableFilter<"ZoomParticipant"> | string | null
    name?: StringFilter<"ZoomParticipant"> | string
    email?: StringNullableFilter<"ZoomParticipant"> | string | null
    joinTime?: DateTimeFilter<"ZoomParticipant"> | Date | string
    leaveTime?: DateTimeNullableFilter<"ZoomParticipant"> | Date | string | null
    duration?: IntNullableFilter<"ZoomParticipant"> | number | null
    status?: StringFilter<"ZoomParticipant"> | string
    metadata?: JsonNullableFilter<"ZoomParticipant">
    createdAt?: DateTimeFilter<"ZoomParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ZoomParticipant"> | Date | string
    meeting?: XOR<ZoomMeetingScalarRelationFilter, ZoomMeetingWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ZoomParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrderInput | SortOrder
    zoomUserId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoomParticipantCountOrderByAggregateInput
    _avg?: ZoomParticipantAvgOrderByAggregateInput
    _max?: ZoomParticipantMaxOrderByAggregateInput
    _min?: ZoomParticipantMinOrderByAggregateInput
    _sum?: ZoomParticipantSumOrderByAggregateInput
  }

  export type ZoomParticipantScalarWhereWithAggregatesInput = {
    AND?: ZoomParticipantScalarWhereWithAggregatesInput | ZoomParticipantScalarWhereWithAggregatesInput[]
    OR?: ZoomParticipantScalarWhereWithAggregatesInput[]
    NOT?: ZoomParticipantScalarWhereWithAggregatesInput | ZoomParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ZoomParticipant"> | string
    meetingId?: StringWithAggregatesFilter<"ZoomParticipant"> | string
    userId?: StringNullableWithAggregatesFilter<"ZoomParticipant"> | string | null
    zoomUserId?: StringNullableWithAggregatesFilter<"ZoomParticipant"> | string | null
    name?: StringWithAggregatesFilter<"ZoomParticipant"> | string
    email?: StringNullableWithAggregatesFilter<"ZoomParticipant"> | string | null
    joinTime?: DateTimeWithAggregatesFilter<"ZoomParticipant"> | Date | string
    leaveTime?: DateTimeNullableWithAggregatesFilter<"ZoomParticipant"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"ZoomParticipant"> | number | null
    status?: StringWithAggregatesFilter<"ZoomParticipant"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ZoomParticipant">
    createdAt?: DateTimeWithAggregatesFilter<"ZoomParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ZoomParticipant"> | Date | string
  }

  export type SalesforceAccountWhereInput = {
    AND?: SalesforceAccountWhereInput | SalesforceAccountWhereInput[]
    OR?: SalesforceAccountWhereInput[]
    NOT?: SalesforceAccountWhereInput | SalesforceAccountWhereInput[]
    id?: StringFilter<"SalesforceAccount"> | string
    userId?: StringFilter<"SalesforceAccount"> | string
    dealId?: StringNullableFilter<"SalesforceAccount"> | string | null
    accountId?: StringFilter<"SalesforceAccount"> | string
    name?: StringFilter<"SalesforceAccount"> | string
    type?: StringNullableFilter<"SalesforceAccount"> | string | null
    industry?: StringNullableFilter<"SalesforceAccount"> | string | null
    website?: StringNullableFilter<"SalesforceAccount"> | string | null
    phone?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingCity?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingState?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingCountry?: StringNullableFilter<"SalesforceAccount"> | string | null
    description?: StringNullableFilter<"SalesforceAccount"> | string | null
    revenue?: FloatNullableFilter<"SalesforceAccount"> | number | null
    employees?: IntNullableFilter<"SalesforceAccount"> | number | null
    ownerId?: StringNullableFilter<"SalesforceAccount"> | string | null
    metadata?: JsonNullableFilter<"SalesforceAccount">
    lastSync?: DateTimeFilter<"SalesforceAccount"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contacts?: SalesforceContactListRelationFilter
    opportunities?: SalesforceOpportunityListRelationFilter
  }

  export type SalesforceAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    billingCity?: SortOrderInput | SortOrder
    billingState?: SortOrderInput | SortOrder
    billingCountry?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    employees?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    contacts?: SalesforceContactOrderByRelationAggregateInput
    opportunities?: SalesforceOpportunityOrderByRelationAggregateInput
  }

  export type SalesforceAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: SalesforceAccountWhereInput | SalesforceAccountWhereInput[]
    OR?: SalesforceAccountWhereInput[]
    NOT?: SalesforceAccountWhereInput | SalesforceAccountWhereInput[]
    userId?: StringFilter<"SalesforceAccount"> | string
    dealId?: StringNullableFilter<"SalesforceAccount"> | string | null
    name?: StringFilter<"SalesforceAccount"> | string
    type?: StringNullableFilter<"SalesforceAccount"> | string | null
    industry?: StringNullableFilter<"SalesforceAccount"> | string | null
    website?: StringNullableFilter<"SalesforceAccount"> | string | null
    phone?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingCity?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingState?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingCountry?: StringNullableFilter<"SalesforceAccount"> | string | null
    description?: StringNullableFilter<"SalesforceAccount"> | string | null
    revenue?: FloatNullableFilter<"SalesforceAccount"> | number | null
    employees?: IntNullableFilter<"SalesforceAccount"> | number | null
    ownerId?: StringNullableFilter<"SalesforceAccount"> | string | null
    metadata?: JsonNullableFilter<"SalesforceAccount">
    lastSync?: DateTimeFilter<"SalesforceAccount"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    contacts?: SalesforceContactListRelationFilter
    opportunities?: SalesforceOpportunityListRelationFilter
  }, "id" | "accountId">

  export type SalesforceAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    billingCity?: SortOrderInput | SortOrder
    billingState?: SortOrderInput | SortOrder
    billingCountry?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    employees?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesforceAccountCountOrderByAggregateInput
    _avg?: SalesforceAccountAvgOrderByAggregateInput
    _max?: SalesforceAccountMaxOrderByAggregateInput
    _min?: SalesforceAccountMinOrderByAggregateInput
    _sum?: SalesforceAccountSumOrderByAggregateInput
  }

  export type SalesforceAccountScalarWhereWithAggregatesInput = {
    AND?: SalesforceAccountScalarWhereWithAggregatesInput | SalesforceAccountScalarWhereWithAggregatesInput[]
    OR?: SalesforceAccountScalarWhereWithAggregatesInput[]
    NOT?: SalesforceAccountScalarWhereWithAggregatesInput | SalesforceAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesforceAccount"> | string
    userId?: StringWithAggregatesFilter<"SalesforceAccount"> | string
    dealId?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    accountId?: StringWithAggregatesFilter<"SalesforceAccount"> | string
    name?: StringWithAggregatesFilter<"SalesforceAccount"> | string
    type?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    industry?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    website?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    billingCity?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    billingState?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    billingCountry?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    description?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    revenue?: FloatNullableWithAggregatesFilter<"SalesforceAccount"> | number | null
    employees?: IntNullableWithAggregatesFilter<"SalesforceAccount"> | number | null
    ownerId?: StringNullableWithAggregatesFilter<"SalesforceAccount"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SalesforceAccount">
    lastSync?: DateTimeWithAggregatesFilter<"SalesforceAccount"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesforceAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesforceAccount"> | Date | string
  }

  export type SalesforceContactWhereInput = {
    AND?: SalesforceContactWhereInput | SalesforceContactWhereInput[]
    OR?: SalesforceContactWhereInput[]
    NOT?: SalesforceContactWhereInput | SalesforceContactWhereInput[]
    id?: StringFilter<"SalesforceContact"> | string
    userId?: StringFilter<"SalesforceContact"> | string
    contactId?: StringFilter<"SalesforceContact"> | string
    accountId?: StringNullableFilter<"SalesforceContact"> | string | null
    name?: StringFilter<"SalesforceContact"> | string
    email?: StringNullableFilter<"SalesforceContact"> | string | null
    phone?: StringNullableFilter<"SalesforceContact"> | string | null
    title?: StringNullableFilter<"SalesforceContact"> | string | null
    department?: StringNullableFilter<"SalesforceContact"> | string | null
    leadSource?: StringNullableFilter<"SalesforceContact"> | string | null
    description?: StringNullableFilter<"SalesforceContact"> | string | null
    ownerId?: StringNullableFilter<"SalesforceContact"> | string | null
    metadata?: JsonNullableFilter<"SalesforceContact">
    lastSync?: DateTimeFilter<"SalesforceContact"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceContact"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<SalesforceAccountNullableScalarRelationFilter, SalesforceAccountWhereInput> | null
  }

  export type SalesforceContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    leadSource?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    account?: SalesforceAccountOrderByWithRelationInput
  }

  export type SalesforceContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contactId?: string
    AND?: SalesforceContactWhereInput | SalesforceContactWhereInput[]
    OR?: SalesforceContactWhereInput[]
    NOT?: SalesforceContactWhereInput | SalesforceContactWhereInput[]
    userId?: StringFilter<"SalesforceContact"> | string
    accountId?: StringNullableFilter<"SalesforceContact"> | string | null
    name?: StringFilter<"SalesforceContact"> | string
    email?: StringNullableFilter<"SalesforceContact"> | string | null
    phone?: StringNullableFilter<"SalesforceContact"> | string | null
    title?: StringNullableFilter<"SalesforceContact"> | string | null
    department?: StringNullableFilter<"SalesforceContact"> | string | null
    leadSource?: StringNullableFilter<"SalesforceContact"> | string | null
    description?: StringNullableFilter<"SalesforceContact"> | string | null
    ownerId?: StringNullableFilter<"SalesforceContact"> | string | null
    metadata?: JsonNullableFilter<"SalesforceContact">
    lastSync?: DateTimeFilter<"SalesforceContact"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceContact"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceContact"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<SalesforceAccountNullableScalarRelationFilter, SalesforceAccountWhereInput> | null
  }, "id" | "contactId">

  export type SalesforceContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    leadSource?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesforceContactCountOrderByAggregateInput
    _max?: SalesforceContactMaxOrderByAggregateInput
    _min?: SalesforceContactMinOrderByAggregateInput
  }

  export type SalesforceContactScalarWhereWithAggregatesInput = {
    AND?: SalesforceContactScalarWhereWithAggregatesInput | SalesforceContactScalarWhereWithAggregatesInput[]
    OR?: SalesforceContactScalarWhereWithAggregatesInput[]
    NOT?: SalesforceContactScalarWhereWithAggregatesInput | SalesforceContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesforceContact"> | string
    userId?: StringWithAggregatesFilter<"SalesforceContact"> | string
    contactId?: StringWithAggregatesFilter<"SalesforceContact"> | string
    accountId?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    name?: StringWithAggregatesFilter<"SalesforceContact"> | string
    email?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    title?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    department?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    leadSource?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    description?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"SalesforceContact"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SalesforceContact">
    lastSync?: DateTimeWithAggregatesFilter<"SalesforceContact"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesforceContact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesforceContact"> | Date | string
  }

  export type SalesforceOpportunityWhereInput = {
    AND?: SalesforceOpportunityWhereInput | SalesforceOpportunityWhereInput[]
    OR?: SalesforceOpportunityWhereInput[]
    NOT?: SalesforceOpportunityWhereInput | SalesforceOpportunityWhereInput[]
    id?: StringFilter<"SalesforceOpportunity"> | string
    userId?: StringFilter<"SalesforceOpportunity"> | string
    dealId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    opportunityId?: StringFilter<"SalesforceOpportunity"> | string
    accountId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    name?: StringFilter<"SalesforceOpportunity"> | string
    amount?: FloatNullableFilter<"SalesforceOpportunity"> | number | null
    stage?: StringFilter<"SalesforceOpportunity"> | string
    probability?: FloatNullableFilter<"SalesforceOpportunity"> | number | null
    closeDate?: DateTimeNullableFilter<"SalesforceOpportunity"> | Date | string | null
    type?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    leadSource?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    description?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    ownerId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    metadata?: JsonNullableFilter<"SalesforceOpportunity">
    lastSync?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    account?: XOR<SalesforceAccountNullableScalarRelationFilter, SalesforceAccountWhereInput> | null
  }

  export type SalesforceOpportunityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    opportunityId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    name?: SortOrder
    amount?: SortOrderInput | SortOrder
    stage?: SortOrder
    probability?: SortOrderInput | SortOrder
    closeDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    leadSource?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    account?: SalesforceAccountOrderByWithRelationInput
  }

  export type SalesforceOpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    opportunityId?: string
    AND?: SalesforceOpportunityWhereInput | SalesforceOpportunityWhereInput[]
    OR?: SalesforceOpportunityWhereInput[]
    NOT?: SalesforceOpportunityWhereInput | SalesforceOpportunityWhereInput[]
    userId?: StringFilter<"SalesforceOpportunity"> | string
    dealId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    accountId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    name?: StringFilter<"SalesforceOpportunity"> | string
    amount?: FloatNullableFilter<"SalesforceOpportunity"> | number | null
    stage?: StringFilter<"SalesforceOpportunity"> | string
    probability?: FloatNullableFilter<"SalesforceOpportunity"> | number | null
    closeDate?: DateTimeNullableFilter<"SalesforceOpportunity"> | Date | string | null
    type?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    leadSource?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    description?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    ownerId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    metadata?: JsonNullableFilter<"SalesforceOpportunity">
    lastSync?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    account?: XOR<SalesforceAccountNullableScalarRelationFilter, SalesforceAccountWhereInput> | null
  }, "id" | "opportunityId">

  export type SalesforceOpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    opportunityId?: SortOrder
    accountId?: SortOrderInput | SortOrder
    name?: SortOrder
    amount?: SortOrderInput | SortOrder
    stage?: SortOrder
    probability?: SortOrderInput | SortOrder
    closeDate?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    leadSource?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesforceOpportunityCountOrderByAggregateInput
    _avg?: SalesforceOpportunityAvgOrderByAggregateInput
    _max?: SalesforceOpportunityMaxOrderByAggregateInput
    _min?: SalesforceOpportunityMinOrderByAggregateInput
    _sum?: SalesforceOpportunitySumOrderByAggregateInput
  }

  export type SalesforceOpportunityScalarWhereWithAggregatesInput = {
    AND?: SalesforceOpportunityScalarWhereWithAggregatesInput | SalesforceOpportunityScalarWhereWithAggregatesInput[]
    OR?: SalesforceOpportunityScalarWhereWithAggregatesInput[]
    NOT?: SalesforceOpportunityScalarWhereWithAggregatesInput | SalesforceOpportunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesforceOpportunity"> | string
    userId?: StringWithAggregatesFilter<"SalesforceOpportunity"> | string
    dealId?: StringNullableWithAggregatesFilter<"SalesforceOpportunity"> | string | null
    opportunityId?: StringWithAggregatesFilter<"SalesforceOpportunity"> | string
    accountId?: StringNullableWithAggregatesFilter<"SalesforceOpportunity"> | string | null
    name?: StringWithAggregatesFilter<"SalesforceOpportunity"> | string
    amount?: FloatNullableWithAggregatesFilter<"SalesforceOpportunity"> | number | null
    stage?: StringWithAggregatesFilter<"SalesforceOpportunity"> | string
    probability?: FloatNullableWithAggregatesFilter<"SalesforceOpportunity"> | number | null
    closeDate?: DateTimeNullableWithAggregatesFilter<"SalesforceOpportunity"> | Date | string | null
    type?: StringNullableWithAggregatesFilter<"SalesforceOpportunity"> | string | null
    leadSource?: StringNullableWithAggregatesFilter<"SalesforceOpportunity"> | string | null
    description?: StringNullableWithAggregatesFilter<"SalesforceOpportunity"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"SalesforceOpportunity"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SalesforceOpportunity">
    lastSync?: DateTimeWithAggregatesFilter<"SalesforceOpportunity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesforceOpportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesforceOpportunity"> | Date | string
  }

  export type LPGroupWhereInput = {
    AND?: LPGroupWhereInput | LPGroupWhereInput[]
    OR?: LPGroupWhereInput[]
    NOT?: LPGroupWhereInput | LPGroupWhereInput[]
    id?: StringFilter<"LPGroup"> | string
    userId?: StringFilter<"LPGroup"> | string
    name?: StringFilter<"LPGroup"> | string
    description?: StringNullableFilter<"LPGroup"> | string | null
    type?: StringFilter<"LPGroup"> | string
    criteria?: JsonNullableFilter<"LPGroup">
    autoAssign?: BoolFilter<"LPGroup"> | boolean
    emailPreferences?: JsonNullableFilter<"LPGroup">
    createdAt?: DateTimeFilter<"LPGroup"> | Date | string
    updatedAt?: DateTimeFilter<"LPGroup"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: InvestorGroupMemberListRelationFilter
  }

  export type LPGroupOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    criteria?: SortOrderInput | SortOrder
    autoAssign?: SortOrder
    emailPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    members?: InvestorGroupMemberOrderByRelationAggregateInput
  }

  export type LPGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LPGroupWhereInput | LPGroupWhereInput[]
    OR?: LPGroupWhereInput[]
    NOT?: LPGroupWhereInput | LPGroupWhereInput[]
    userId?: StringFilter<"LPGroup"> | string
    name?: StringFilter<"LPGroup"> | string
    description?: StringNullableFilter<"LPGroup"> | string | null
    type?: StringFilter<"LPGroup"> | string
    criteria?: JsonNullableFilter<"LPGroup">
    autoAssign?: BoolFilter<"LPGroup"> | boolean
    emailPreferences?: JsonNullableFilter<"LPGroup">
    createdAt?: DateTimeFilter<"LPGroup"> | Date | string
    updatedAt?: DateTimeFilter<"LPGroup"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: InvestorGroupMemberListRelationFilter
  }, "id">

  export type LPGroupOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    criteria?: SortOrderInput | SortOrder
    autoAssign?: SortOrder
    emailPreferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LPGroupCountOrderByAggregateInput
    _max?: LPGroupMaxOrderByAggregateInput
    _min?: LPGroupMinOrderByAggregateInput
  }

  export type LPGroupScalarWhereWithAggregatesInput = {
    AND?: LPGroupScalarWhereWithAggregatesInput | LPGroupScalarWhereWithAggregatesInput[]
    OR?: LPGroupScalarWhereWithAggregatesInput[]
    NOT?: LPGroupScalarWhereWithAggregatesInput | LPGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LPGroup"> | string
    userId?: StringWithAggregatesFilter<"LPGroup"> | string
    name?: StringWithAggregatesFilter<"LPGroup"> | string
    description?: StringNullableWithAggregatesFilter<"LPGroup"> | string | null
    type?: StringWithAggregatesFilter<"LPGroup"> | string
    criteria?: JsonNullableWithAggregatesFilter<"LPGroup">
    autoAssign?: BoolWithAggregatesFilter<"LPGroup"> | boolean
    emailPreferences?: JsonNullableWithAggregatesFilter<"LPGroup">
    createdAt?: DateTimeWithAggregatesFilter<"LPGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LPGroup"> | Date | string
  }

  export type InvestorGroupMemberWhereInput = {
    AND?: InvestorGroupMemberWhereInput | InvestorGroupMemberWhereInput[]
    OR?: InvestorGroupMemberWhereInput[]
    NOT?: InvestorGroupMemberWhereInput | InvestorGroupMemberWhereInput[]
    id?: StringFilter<"InvestorGroupMember"> | string
    investorId?: StringFilter<"InvestorGroupMember"> | string
    groupId?: StringFilter<"InvestorGroupMember"> | string
    assignedAt?: DateTimeFilter<"InvestorGroupMember"> | Date | string
    autoAssigned?: BoolFilter<"InvestorGroupMember"> | boolean
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
    group?: XOR<LPGroupScalarRelationFilter, LPGroupWhereInput>
  }

  export type InvestorGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    investorId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    autoAssigned?: SortOrder
    investor?: InvestorOrderByWithRelationInput
    group?: LPGroupOrderByWithRelationInput
  }

  export type InvestorGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    investorId_groupId?: InvestorGroupMemberInvestorIdGroupIdCompoundUniqueInput
    AND?: InvestorGroupMemberWhereInput | InvestorGroupMemberWhereInput[]
    OR?: InvestorGroupMemberWhereInput[]
    NOT?: InvestorGroupMemberWhereInput | InvestorGroupMemberWhereInput[]
    investorId?: StringFilter<"InvestorGroupMember"> | string
    groupId?: StringFilter<"InvestorGroupMember"> | string
    assignedAt?: DateTimeFilter<"InvestorGroupMember"> | Date | string
    autoAssigned?: BoolFilter<"InvestorGroupMember"> | boolean
    investor?: XOR<InvestorScalarRelationFilter, InvestorWhereInput>
    group?: XOR<LPGroupScalarRelationFilter, LPGroupWhereInput>
  }, "id" | "investorId_groupId">

  export type InvestorGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    investorId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    autoAssigned?: SortOrder
    _count?: InvestorGroupMemberCountOrderByAggregateInput
    _max?: InvestorGroupMemberMaxOrderByAggregateInput
    _min?: InvestorGroupMemberMinOrderByAggregateInput
  }

  export type InvestorGroupMemberScalarWhereWithAggregatesInput = {
    AND?: InvestorGroupMemberScalarWhereWithAggregatesInput | InvestorGroupMemberScalarWhereWithAggregatesInput[]
    OR?: InvestorGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: InvestorGroupMemberScalarWhereWithAggregatesInput | InvestorGroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestorGroupMember"> | string
    investorId?: StringWithAggregatesFilter<"InvestorGroupMember"> | string
    groupId?: StringWithAggregatesFilter<"InvestorGroupMember"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"InvestorGroupMember"> | Date | string
    autoAssigned?: BoolWithAggregatesFilter<"InvestorGroupMember"> | boolean
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    title?: string | null
    bio?: string | null
    joinDate?: Date | string
    timezone?: string
    language?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    title?: string | null
    bio?: string | null
    joinDate?: Date | string
    timezone?: string
    language?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    title?: string | null
    bio?: string | null
    joinDate?: Date | string
    timezone?: string
    language?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceCreateInput = {
    id?: string
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    smsNotify?: BoolFieldUpdateOperationsInput | boolean
    calendarNotify?: BoolFieldUpdateOperationsInput | boolean
    dealNotify?: BoolFieldUpdateOperationsInput | boolean
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    smsNotify?: BoolFieldUpdateOperationsInput | boolean
    calendarNotify?: BoolFieldUpdateOperationsInput | boolean
    dealNotify?: BoolFieldUpdateOperationsInput | boolean
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceCreateManyInput = {
    id?: string
    userId: string
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    smsNotify?: BoolFieldUpdateOperationsInput | boolean
    calendarNotify?: BoolFieldUpdateOperationsInput | boolean
    dealNotify?: BoolFieldUpdateOperationsInput | boolean
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    smsNotify?: BoolFieldUpdateOperationsInput | boolean
    calendarNotify?: BoolFieldUpdateOperationsInput | boolean
    dealNotify?: BoolFieldUpdateOperationsInput | boolean
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    provider: string
    type: string
    isActive?: boolean
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: IntegrationCreatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    syncStatus?: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    type: string
    isActive?: boolean
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: IntegrationCreatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    syncStatus?: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    userId: string
    provider: string
    type: string
    isActive?: boolean
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: IntegrationCreatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    syncStatus?: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOwnedContactsInput
    deal?: DealCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
    communications?: CommunicationCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    deal?: DealUpdateOneWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
    communications?: CommunicationUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationCreateInput = {
    id?: string
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommunicationsInput
    deal?: DealCreateNestedOneWithoutCommunicationsInput
    contact?: ContactCreateNestedOneWithoutCommunicationsInput
  }

  export type CommunicationUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    deal?: DealUpdateOneWithoutCommunicationsNestedInput
    contact?: ContactUpdateOneWithoutCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorCreateInput = {
    id?: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorsInput
    entities?: InvestorEntityCreateNestedManyWithoutInvestorInput
    groupMemberships?: InvestorGroupMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: InvestorEntityUncheckedCreateNestedManyWithoutInvestorInput
    groupMemberships?: InvestorGroupMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorsNestedInput
    entities?: InvestorEntityUpdateManyWithoutInvestorNestedInput
    groupMemberships?: InvestorGroupMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: InvestorEntityUncheckedUpdateManyWithoutInvestorNestedInput
    groupMemberships?: InvestorGroupMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorCreateManyInput = {
    id?: string
    userId: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundCreateInput = {
    id?: string
    name: string
    type: string
    strategy?: string | null
    targetSize: number
    minimumCommitment?: number | null
    managementFee?: number | null
    carriedInterest?: number | null
    currency?: string
    vintage?: number | null
    investmentPeriod?: number | null
    fundTerm?: number | null
    geoFocus?: string | null
    sectorFocus?: string | null
    description?: string | null
    status?: string
    raisedAmount?: number
    investorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFundsInput
  }

  export type FundUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    type: string
    strategy?: string | null
    targetSize: number
    minimumCommitment?: number | null
    managementFee?: number | null
    carriedInterest?: number | null
    currency?: string
    vintage?: number | null
    investmentPeriod?: number | null
    fundTerm?: number | null
    geoFocus?: string | null
    sectorFocus?: string | null
    description?: string | null
    status?: string
    raisedAmount?: number
    investorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFundsNestedInput
  }

  export type FundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundCreateManyInput = {
    id?: string
    userId: string
    name: string
    type: string
    strategy?: string | null
    targetSize: number
    minimumCommitment?: number | null
    managementFee?: number | null
    carriedInterest?: number | null
    currency?: string
    vintage?: number | null
    investmentPeriod?: number | null
    fundTerm?: number | null
    geoFocus?: string | null
    sectorFocus?: string | null
    description?: string | null
    status?: string
    raisedAmount?: number
    investorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorEntityCreateInput = {
    id?: string
    name: string
    type: string
    investmentType: string
    commitment?: number | null
    called?: number | null
    status?: string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    investor: InvestorCreateNestedOneWithoutEntitiesInput
  }

  export type InvestorEntityUncheckedCreateInput = {
    id?: string
    investorId: string
    name: string
    type: string
    investmentType: string
    commitment?: number | null
    called?: number | null
    status?: string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investor?: InvestorUpdateOneRequiredWithoutEntitiesNestedInput
  }

  export type InvestorEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorEntityCreateManyInput = {
    id?: string
    investorId: string
    name: string
    type: string
    investmentType: string
    commitment?: number | null
    called?: number | null
    status?: string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    userId: string
    title: string
    type: string
    format?: string
    content?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    status?: string
    recipients?: ReportCreaterecipientsInput | string[]
    sentAt?: Date | string | null
    generatedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    type: string
    format?: string
    content?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    status?: string
    recipients?: ReportCreaterecipientsInput | string[]
    sentAt?: Date | string | null
    generatedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: ReportUpdaterecipientsInput | string[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: ReportUpdaterecipientsInput | string[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    userId: string
    title: string
    type: string
    format?: string
    content?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: string | null
    status?: string
    recipients?: ReportCreaterecipientsInput | string[]
    sentAt?: Date | string | null
    generatedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: ReportUpdaterecipientsInput | string[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    url?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    recipients?: ReportUpdaterecipientsInput | string[]
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncJobCreateInput = {
    id?: string
    userId: string
    type: string
    status: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    itemsProcessed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncJobUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    status: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    itemsProcessed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    itemsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    itemsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncJobCreateManyInput = {
    id?: string
    userId: string
    type: string
    status: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    itemsProcessed?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    itemsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    itemsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageCreateInput = {
    id?: string
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
    user: UserCreateNestedOneWithoutTeamsMessagesInput
    deal?: DealCreateNestedOneWithoutTeamsMessagesInput
    contact?: ContactCreateNestedOneWithoutTeamsMessagesInput
  }

  export type TeamsMessageUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type TeamsMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsMessagesNestedInput
    deal?: DealUpdateOneWithoutTeamsMessagesNestedInput
    contact?: ContactUpdateOneWithoutTeamsMessagesNestedInput
  }

  export type TeamsMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type TeamsMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsChannelCreateInput = {
    id?: string
    channelId: string
    teamId: string
    name: string
    description?: string | null
    type: string
    webUrl?: string | null
    memberCount?: number | null
    isArchived?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamsChannelsInput
  }

  export type TeamsChannelUncheckedCreateInput = {
    id?: string
    userId: string
    channelId: string
    teamId: string
    name: string
    description?: string | null
    type: string
    webUrl?: string | null
    memberCount?: number | null
    isArchived?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsChannelsNestedInput
  }

  export type TeamsChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsChannelCreateManyInput = {
    id?: string
    userId: string
    channelId: string
    teamId: string
    name: string
    description?: string | null
    type: string
    webUrl?: string | null
    memberCount?: number | null
    isArchived?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageCreateInput = {
    id?: string
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSlackMessagesInput
    deal?: DealCreateNestedOneWithoutSlackMessagesInput
    contact?: ContactCreateNestedOneWithoutSlackMessagesInput
  }

  export type SlackMessageUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSlackMessagesNestedInput
    deal?: DealUpdateOneWithoutSlackMessagesNestedInput
    contact?: ContactUpdateOneWithoutSlackMessagesNestedInput
  }

  export type SlackMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackChannelCreateInput = {
    id?: string
    channelId: string
    name: string
    purpose?: string | null
    topic?: string | null
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSlackChannelsInput
  }

  export type SlackChannelUncheckedCreateInput = {
    id?: string
    userId: string
    channelId: string
    name: string
    purpose?: string | null
    topic?: string | null
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSlackChannelsNestedInput
  }

  export type SlackChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackChannelCreateManyInput = {
    id?: string
    userId: string
    channelId: string
    name: string
    purpose?: string | null
    topic?: string | null
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomMeetingCreateInput = {
    id?: string
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZoomMeetingsInput
    deal?: DealCreateNestedOneWithoutZoomMeetingsInput
    participants?: ZoomParticipantCreateNestedManyWithoutMeetingInput
  }

  export type ZoomMeetingUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ZoomParticipantUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type ZoomMeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZoomMeetingsNestedInput
    deal?: DealUpdateOneWithoutZoomMeetingsNestedInput
    participants?: ZoomParticipantUpdateManyWithoutMeetingNestedInput
  }

  export type ZoomMeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ZoomParticipantUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type ZoomMeetingCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomMeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomMeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomParticipantCreateInput = {
    id?: string
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: ZoomMeetingCreateNestedOneWithoutParticipantsInput
    user?: UserCreateNestedOneWithoutZoomParticipantsInput
  }

  export type ZoomParticipantUncheckedCreateInput = {
    id?: string
    meetingId: string
    userId?: string | null
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: ZoomMeetingUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneWithoutZoomParticipantsNestedInput
  }

  export type ZoomParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomParticipantCreateManyInput = {
    id?: string
    meetingId: string
    userId?: string | null
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceAccountCreateInput = {
    id?: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceAccountsInput
    deal?: DealCreateNestedOneWithoutSalesforceAccountsInput
    contacts?: SalesforceContactCreateNestedManyWithoutAccountInput
    opportunities?: SalesforceOpportunityCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: SalesforceContactUncheckedCreateNestedManyWithoutAccountInput
    opportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceAccountsNestedInput
    deal?: DealUpdateOneWithoutSalesforceAccountsNestedInput
    contacts?: SalesforceContactUpdateManyWithoutAccountNestedInput
    opportunities?: SalesforceOpportunityUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: SalesforceContactUncheckedUpdateManyWithoutAccountNestedInput
    opportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactCreateInput = {
    id?: string
    contactId: string
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceContactsInput
    account?: SalesforceAccountCreateNestedOneWithoutContactsInput
  }

  export type SalesforceContactUncheckedCreateInput = {
    id?: string
    userId: string
    contactId: string
    accountId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceContactsNestedInput
    account?: SalesforceAccountUpdateOneWithoutContactsNestedInput
  }

  export type SalesforceContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactCreateManyInput = {
    id?: string
    userId: string
    contactId: string
    accountId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityCreateInput = {
    id?: string
    opportunityId: string
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceOpportunitiesInput
    deal?: DealCreateNestedOneWithoutSalesforceOpportunitiesInput
    account?: SalesforceAccountCreateNestedOneWithoutOpportunitiesInput
  }

  export type SalesforceOpportunityUncheckedCreateInput = {
    id?: string
    userId: string
    dealId?: string | null
    opportunityId: string
    accountId?: string | null
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceOpportunitiesNestedInput
    deal?: DealUpdateOneWithoutSalesforceOpportunitiesNestedInput
    account?: SalesforceAccountUpdateOneWithoutOpportunitiesNestedInput
  }

  export type SalesforceOpportunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityCreateManyInput = {
    id?: string
    userId: string
    dealId?: string | null
    opportunityId: string
    accountId?: string | null
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LPGroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLpGroupsInput
    members?: InvestorGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type LPGroupUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: InvestorGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type LPGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLpGroupsNestedInput
    members?: InvestorGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type LPGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: InvestorGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type LPGroupCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LPGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LPGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorGroupMemberCreateInput = {
    id?: string
    assignedAt?: Date | string
    autoAssigned?: boolean
    investor: InvestorCreateNestedOneWithoutGroupMembershipsInput
    group: LPGroupCreateNestedOneWithoutMembersInput
  }

  export type InvestorGroupMemberUncheckedCreateInput = {
    id?: string
    investorId: string
    groupId: string
    assignedAt?: Date | string
    autoAssigned?: boolean
  }

  export type InvestorGroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
    investor?: InvestorUpdateOneRequiredWithoutGroupMembershipsNestedInput
    group?: LPGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type InvestorGroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvestorGroupMemberCreateManyInput = {
    id?: string
    investorId: string
    groupId: string
    assignedAt?: Date | string
    autoAssigned?: boolean
  }

  export type InvestorGroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvestorGroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type CommunicationListRelationFilter = {
    every?: CommunicationWhereInput
    some?: CommunicationWhereInput
    none?: CommunicationWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type UserPreferenceNullableScalarRelationFilter = {
    is?: UserPreferenceWhereInput | null
    isNot?: UserPreferenceWhereInput | null
  }

  export type TeamsMessageListRelationFilter = {
    every?: TeamsMessageWhereInput
    some?: TeamsMessageWhereInput
    none?: TeamsMessageWhereInput
  }

  export type TeamsChannelListRelationFilter = {
    every?: TeamsChannelWhereInput
    some?: TeamsChannelWhereInput
    none?: TeamsChannelWhereInput
  }

  export type SlackMessageListRelationFilter = {
    every?: SlackMessageWhereInput
    some?: SlackMessageWhereInput
    none?: SlackMessageWhereInput
  }

  export type SlackChannelListRelationFilter = {
    every?: SlackChannelWhereInput
    some?: SlackChannelWhereInput
    none?: SlackChannelWhereInput
  }

  export type ZoomMeetingListRelationFilter = {
    every?: ZoomMeetingWhereInput
    some?: ZoomMeetingWhereInput
    none?: ZoomMeetingWhereInput
  }

  export type ZoomParticipantListRelationFilter = {
    every?: ZoomParticipantWhereInput
    some?: ZoomParticipantWhereInput
    none?: ZoomParticipantWhereInput
  }

  export type SalesforceAccountListRelationFilter = {
    every?: SalesforceAccountWhereInput
    some?: SalesforceAccountWhereInput
    none?: SalesforceAccountWhereInput
  }

  export type SalesforceContactListRelationFilter = {
    every?: SalesforceContactWhereInput
    some?: SalesforceContactWhereInput
    none?: SalesforceContactWhereInput
  }

  export type SalesforceOpportunityListRelationFilter = {
    every?: SalesforceOpportunityWhereInput
    some?: SalesforceOpportunityWhereInput
    none?: SalesforceOpportunityWhereInput
  }

  export type FundListRelationFilter = {
    every?: FundWhereInput
    some?: FundWhereInput
    none?: FundWhereInput
  }

  export type InvestorListRelationFilter = {
    every?: InvestorWhereInput
    some?: InvestorWhereInput
    none?: InvestorWhereInput
  }

  export type LPGroupListRelationFilter = {
    every?: LPGroupWhereInput
    some?: LPGroupWhereInput
    none?: LPGroupWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamsMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamsChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SlackMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SlackChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoomMeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoomParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesforceAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesforceContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesforceOpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LPGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firm?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    avatar?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firm?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    avatar?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    firm?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    avatar?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    bio?: SortOrder
    joinDate?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    bio?: SortOrder
    joinDate?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    bio?: SortOrder
    joinDate?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    theme?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    smsNotify?: SortOrder
    calendarNotify?: SortOrder
    dealNotify?: SortOrder
    autoSave?: SortOrder
    darkMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    smsNotify?: SortOrder
    calendarNotify?: SortOrder
    dealNotify?: SortOrder
    autoSave?: SortOrder
    darkMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    emailNotify?: SortOrder
    pushNotify?: SortOrder
    smsNotify?: SortOrder
    calendarNotify?: SortOrder
    dealNotify?: SortOrder
    autoSave?: SortOrder
    darkMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntegrationUserIdProviderTypeCompoundUniqueInput = {
    userId: string
    provider: string
    type: string
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    profile?: SortOrder
    settings?: SortOrder
    lastSync?: SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    lastSync?: SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    isActive?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    lastSync?: SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    leadPartner?: SortOrder
    team?: SortOrder
    tags?: SortOrder
    priority?: SortOrder
    targetClose?: SortOrder
    actualClose?: SortOrder
    nextStep?: SortOrder
    lastActivity?: SortOrder
    source?: SortOrder
    geography?: SortOrder
    dealSize?: SortOrder
    metrics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    leadPartner?: SortOrder
    priority?: SortOrder
    targetClose?: SortOrder
    actualClose?: SortOrder
    nextStep?: SortOrder
    lastActivity?: SortOrder
    source?: SortOrder
    geography?: SortOrder
    dealSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    company?: SortOrder
    description?: SortOrder
    sector?: SortOrder
    stage?: SortOrder
    status?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    leadPartner?: SortOrder
    priority?: SortOrder
    targetClose?: SortOrder
    actualClose?: SortOrder
    nextStep?: SortOrder
    lastActivity?: SortOrder
    source?: SortOrder
    geography?: SortOrder
    dealSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DealNullableScalarRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type ContactUserIdEmailCompoundUniqueInput = {
    userId: string
    email: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    googleContactId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    title?: SortOrder
    role?: SortOrder
    linkedinUrl?: SortOrder
    avatar?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    relationshipScore?: SortOrder
    lastContact?: SortOrder
    status?: SortOrder
    isKeyContact?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    relationshipScore?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    googleContactId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    title?: SortOrder
    role?: SortOrder
    linkedinUrl?: SortOrder
    avatar?: SortOrder
    notes?: SortOrder
    relationshipScore?: SortOrder
    lastContact?: SortOrder
    status?: SortOrder
    isKeyContact?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    googleContactId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    title?: SortOrder
    role?: SortOrder
    linkedinUrl?: SortOrder
    avatar?: SortOrder
    notes?: SortOrder
    relationshipScore?: SortOrder
    lastContact?: SortOrder
    status?: SortOrder
    isKeyContact?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    relationshipScore?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    attendees?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    outcome?: SortOrder
    nextSteps?: SortOrder
    metadata?: SortOrder
    externalId?: SortOrder
    syncedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    outcome?: SortOrder
    nextSteps?: SortOrder
    externalId?: SortOrder
    syncedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    location?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    outcome?: SortOrder
    nextSteps?: SortOrder
    externalId?: SortOrder
    syncedFrom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    size?: SortOrder
    url?: SortOrder
    googleDriveId?: SortOrder
    path?: SortOrder
    version?: SortOrder
    isConfidential?: SortOrder
    uploadedBy?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    size?: SortOrder
    url?: SortOrder
    googleDriveId?: SortOrder
    path?: SortOrder
    version?: SortOrder
    isConfidential?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    size?: SortOrder
    url?: SortOrder
    googleDriveId?: SortOrder
    path?: SortOrder
    version?: SortOrder
    isConfidential?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type CommunicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    fromEmail?: SortOrder
    toEmails?: SortOrder
    ccEmails?: SortOrder
    bccEmails?: SortOrder
    threadId?: SortOrder
    messageId?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    isRead?: SortOrder
    isImportant?: SortOrder
    labels?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    fromEmail?: SortOrder
    threadId?: SortOrder
    messageId?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    isRead?: SortOrder
    isImportant?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    htmlContent?: SortOrder
    fromEmail?: SortOrder
    threadId?: SortOrder
    messageId?: SortOrder
    status?: SortOrder
    direction?: SortOrder
    isRead?: SortOrder
    isImportant?: SortOrder
    sentAt?: SortOrder
    receivedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorEntityListRelationFilter = {
    every?: InvestorEntityWhereInput
    some?: InvestorEntityWhereInput
    none?: InvestorEntityWhereInput
  }

  export type InvestorGroupMemberListRelationFilter = {
    every?: InvestorGroupMemberWhereInput
    some?: InvestorGroupMemberWhereInput
    none?: InvestorGroupMemberWhereInput
  }

  export type InvestorEntityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvestorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalCommitment?: SortOrder
    totalCalled?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    founded?: SortOrder
    aum?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorAvgOrderByAggregateInput = {
    totalCommitment?: SortOrder
    totalCalled?: SortOrder
    aum?: SortOrder
  }

  export type InvestorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalCommitment?: SortOrder
    totalCalled?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    founded?: SortOrder
    aum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    totalCommitment?: SortOrder
    totalCalled?: SortOrder
    description?: SortOrder
    website?: SortOrder
    location?: SortOrder
    founded?: SortOrder
    aum?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorSumOrderByAggregateInput = {
    totalCommitment?: SortOrder
    totalCalled?: SortOrder
    aum?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FundCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    strategy?: SortOrder
    targetSize?: SortOrder
    minimumCommitment?: SortOrder
    managementFee?: SortOrder
    carriedInterest?: SortOrder
    currency?: SortOrder
    vintage?: SortOrder
    investmentPeriod?: SortOrder
    fundTerm?: SortOrder
    geoFocus?: SortOrder
    sectorFocus?: SortOrder
    description?: SortOrder
    status?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundAvgOrderByAggregateInput = {
    targetSize?: SortOrder
    minimumCommitment?: SortOrder
    managementFee?: SortOrder
    carriedInterest?: SortOrder
    vintage?: SortOrder
    investmentPeriod?: SortOrder
    fundTerm?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
  }

  export type FundMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    strategy?: SortOrder
    targetSize?: SortOrder
    minimumCommitment?: SortOrder
    managementFee?: SortOrder
    carriedInterest?: SortOrder
    currency?: SortOrder
    vintage?: SortOrder
    investmentPeriod?: SortOrder
    fundTerm?: SortOrder
    geoFocus?: SortOrder
    sectorFocus?: SortOrder
    description?: SortOrder
    status?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    strategy?: SortOrder
    targetSize?: SortOrder
    minimumCommitment?: SortOrder
    managementFee?: SortOrder
    carriedInterest?: SortOrder
    currency?: SortOrder
    vintage?: SortOrder
    investmentPeriod?: SortOrder
    fundTerm?: SortOrder
    geoFocus?: SortOrder
    sectorFocus?: SortOrder
    description?: SortOrder
    status?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FundSumOrderByAggregateInput = {
    targetSize?: SortOrder
    minimumCommitment?: SortOrder
    managementFee?: SortOrder
    carriedInterest?: SortOrder
    vintage?: SortOrder
    investmentPeriod?: SortOrder
    fundTerm?: SortOrder
    raisedAmount?: SortOrder
    investorCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InvestorScalarRelationFilter = {
    is?: InvestorWhereInput
    isNot?: InvestorWhereInput
  }

  export type InvestorEntityCountOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    investmentType?: SortOrder
    commitment?: SortOrder
    called?: SortOrder
    status?: SortOrder
    documents?: SortOrder
    fundInvestments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorEntityAvgOrderByAggregateInput = {
    commitment?: SortOrder
    called?: SortOrder
  }

  export type InvestorEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    investmentType?: SortOrder
    commitment?: SortOrder
    called?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorEntityMinOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    investmentType?: SortOrder
    commitment?: SortOrder
    called?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvestorEntitySumOrderByAggregateInput = {
    commitment?: SortOrder
    called?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    format?: SortOrder
    content?: SortOrder
    data?: SortOrder
    url?: SortOrder
    status?: SortOrder
    recipients?: SortOrder
    sentAt?: SortOrder
    generatedAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    format?: SortOrder
    content?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    format?: SortOrder
    content?: SortOrder
    url?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncJobCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    itemsProcessed?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncJobAvgOrderByAggregateInput = {
    itemsProcessed?: SortOrder
  }

  export type SyncJobMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    itemsProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncJobMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    itemsProcessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncJobSumOrderByAggregateInput = {
    itemsProcessed?: SortOrder
  }

  export type TeamsMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    chatId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    importance?: SortOrder
    messageType?: SortOrder
    attachments?: SortOrder
    mentions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type TeamsMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    chatId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    importance?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type TeamsMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    chatId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    fromEmail?: SortOrder
    fromName?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    importance?: SortOrder
    messageType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sentAt?: SortOrder
  }

  export type TeamsChannelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    webUrl?: SortOrder
    memberCount?: SortOrder
    isArchived?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamsChannelAvgOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type TeamsChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    webUrl?: SortOrder
    memberCount?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamsChannelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    webUrl?: SortOrder
    memberCount?: SortOrder
    isArchived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamsChannelSumOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type SlackMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrder
    fromUserId?: SortOrder
    fromName?: SortOrder
    text?: SortOrder
    messageType?: SortOrder
    threadTs?: SortOrder
    attachments?: SortOrder
    reactions?: SortOrder
    mentions?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlackMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrder
    fromUserId?: SortOrder
    fromName?: SortOrder
    text?: SortOrder
    messageType?: SortOrder
    threadTs?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlackMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    contactId?: SortOrder
    messageId?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrder
    fromUserId?: SortOrder
    fromName?: SortOrder
    text?: SortOrder
    messageType?: SortOrder
    threadTs?: SortOrder
    sentAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlackChannelCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    purpose?: SortOrder
    topic?: SortOrder
    isPrivate?: SortOrder
    isArchived?: SortOrder
    memberCount?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlackChannelAvgOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type SlackChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    purpose?: SortOrder
    topic?: SortOrder
    isPrivate?: SortOrder
    isArchived?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlackChannelMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    channelId?: SortOrder
    name?: SortOrder
    purpose?: SortOrder
    topic?: SortOrder
    isPrivate?: SortOrder
    isArchived?: SortOrder
    memberCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlackChannelSumOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type ZoomMeetingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    meetingId?: SortOrder
    uuid?: SortOrder
    topic?: SortOrder
    agenda?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    meetingType?: SortOrder
    joinUrl?: SortOrder
    startUrl?: SortOrder
    password?: SortOrder
    hostEmail?: SortOrder
    participantCount?: SortOrder
    hasRecording?: SortOrder
    recordingUrl?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoomMeetingAvgOrderByAggregateInput = {
    duration?: SortOrder
    participantCount?: SortOrder
  }

  export type ZoomMeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    meetingId?: SortOrder
    uuid?: SortOrder
    topic?: SortOrder
    agenda?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    meetingType?: SortOrder
    joinUrl?: SortOrder
    startUrl?: SortOrder
    password?: SortOrder
    hostEmail?: SortOrder
    participantCount?: SortOrder
    hasRecording?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoomMeetingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    meetingId?: SortOrder
    uuid?: SortOrder
    topic?: SortOrder
    agenda?: SortOrder
    startTime?: SortOrder
    duration?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    meetingType?: SortOrder
    joinUrl?: SortOrder
    startUrl?: SortOrder
    password?: SortOrder
    hostEmail?: SortOrder
    participantCount?: SortOrder
    hasRecording?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoomMeetingSumOrderByAggregateInput = {
    duration?: SortOrder
    participantCount?: SortOrder
  }

  export type ZoomMeetingScalarRelationFilter = {
    is?: ZoomMeetingWhereInput
    isNot?: ZoomMeetingWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ZoomParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    zoomUserId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoomParticipantAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ZoomParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    zoomUserId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoomParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    zoomUserId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    joinTime?: SortOrder
    leaveTime?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoomParticipantSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type SalesforceAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    billingCity?: SortOrder
    billingState?: SortOrder
    billingCountry?: SortOrder
    description?: SortOrder
    revenue?: SortOrder
    employees?: SortOrder
    ownerId?: SortOrder
    metadata?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceAccountAvgOrderByAggregateInput = {
    revenue?: SortOrder
    employees?: SortOrder
  }

  export type SalesforceAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    billingCity?: SortOrder
    billingState?: SortOrder
    billingCountry?: SortOrder
    description?: SortOrder
    revenue?: SortOrder
    employees?: SortOrder
    ownerId?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    billingCity?: SortOrder
    billingState?: SortOrder
    billingCountry?: SortOrder
    description?: SortOrder
    revenue?: SortOrder
    employees?: SortOrder
    ownerId?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceAccountSumOrderByAggregateInput = {
    revenue?: SortOrder
    employees?: SortOrder
  }

  export type SalesforceAccountNullableScalarRelationFilter = {
    is?: SalesforceAccountWhereInput | null
    isNot?: SalesforceAccountWhereInput | null
  }

  export type SalesforceContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    department?: SortOrder
    leadSource?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    metadata?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    department?: SortOrder
    leadSource?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    title?: SortOrder
    department?: SortOrder
    leadSource?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceOpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    opportunityId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    type?: SortOrder
    leadSource?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    metadata?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceOpportunityAvgOrderByAggregateInput = {
    amount?: SortOrder
    probability?: SortOrder
  }

  export type SalesforceOpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    opportunityId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    type?: SortOrder
    leadSource?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceOpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dealId?: SortOrder
    opportunityId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    stage?: SortOrder
    probability?: SortOrder
    closeDate?: SortOrder
    type?: SortOrder
    leadSource?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesforceOpportunitySumOrderByAggregateInput = {
    amount?: SortOrder
    probability?: SortOrder
  }

  export type LPGroupCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    criteria?: SortOrder
    autoAssign?: SortOrder
    emailPreferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LPGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    autoAssign?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LPGroupMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    autoAssign?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LPGroupScalarRelationFilter = {
    is?: LPGroupWhereInput
    isNot?: LPGroupWhereInput
  }

  export type InvestorGroupMemberInvestorIdGroupIdCompoundUniqueInput = {
    investorId: string
    groupId: string
  }

  export type InvestorGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    autoAssigned?: SortOrder
  }

  export type InvestorGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    autoAssigned?: SortOrder
  }

  export type InvestorGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    investorId?: SortOrder
    groupId?: SortOrder
    assignedAt?: SortOrder
    autoAssigned?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type IntegrationCreateNestedManyWithoutUserInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutUserInput = {
    create?: XOR<DealCreateWithoutUserInput, DealUncheckedCreateWithoutUserInput> | DealCreateWithoutUserInput[] | DealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealCreateOrConnectWithoutUserInput | DealCreateOrConnectWithoutUserInput[]
    createMany?: DealCreateManyUserInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunicationCreateWithoutUserInput, CommunicationUncheckedCreateWithoutUserInput> | CommunicationCreateWithoutUserInput[] | CommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUserInput | CommunicationCreateOrConnectWithoutUserInput[]
    createMany?: CommunicationCreateManyUserInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type TeamsMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamsMessageCreateWithoutUserInput, TeamsMessageUncheckedCreateWithoutUserInput> | TeamsMessageCreateWithoutUserInput[] | TeamsMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutUserInput | TeamsMessageCreateOrConnectWithoutUserInput[]
    createMany?: TeamsMessageCreateManyUserInputEnvelope
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
  }

  export type TeamsChannelCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamsChannelCreateWithoutUserInput, TeamsChannelUncheckedCreateWithoutUserInput> | TeamsChannelCreateWithoutUserInput[] | TeamsChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsChannelCreateOrConnectWithoutUserInput | TeamsChannelCreateOrConnectWithoutUserInput[]
    createMany?: TeamsChannelCreateManyUserInputEnvelope
    connect?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
  }

  export type SlackMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<SlackMessageCreateWithoutUserInput, SlackMessageUncheckedCreateWithoutUserInput> | SlackMessageCreateWithoutUserInput[] | SlackMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutUserInput | SlackMessageCreateOrConnectWithoutUserInput[]
    createMany?: SlackMessageCreateManyUserInputEnvelope
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
  }

  export type SlackChannelCreateNestedManyWithoutUserInput = {
    create?: XOR<SlackChannelCreateWithoutUserInput, SlackChannelUncheckedCreateWithoutUserInput> | SlackChannelCreateWithoutUserInput[] | SlackChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackChannelCreateOrConnectWithoutUserInput | SlackChannelCreateOrConnectWithoutUserInput[]
    createMany?: SlackChannelCreateManyUserInputEnvelope
    connect?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
  }

  export type ZoomMeetingCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoomMeetingCreateWithoutUserInput, ZoomMeetingUncheckedCreateWithoutUserInput> | ZoomMeetingCreateWithoutUserInput[] | ZoomMeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutUserInput | ZoomMeetingCreateOrConnectWithoutUserInput[]
    createMany?: ZoomMeetingCreateManyUserInputEnvelope
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
  }

  export type ZoomParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoomParticipantCreateWithoutUserInput, ZoomParticipantUncheckedCreateWithoutUserInput> | ZoomParticipantCreateWithoutUserInput[] | ZoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutUserInput | ZoomParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ZoomParticipantCreateManyUserInputEnvelope
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
  }

  export type SalesforceAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesforceAccountCreateWithoutUserInput, SalesforceAccountUncheckedCreateWithoutUserInput> | SalesforceAccountCreateWithoutUserInput[] | SalesforceAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutUserInput | SalesforceAccountCreateOrConnectWithoutUserInput[]
    createMany?: SalesforceAccountCreateManyUserInputEnvelope
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
  }

  export type SalesforceContactCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesforceContactCreateWithoutUserInput, SalesforceContactUncheckedCreateWithoutUserInput> | SalesforceContactCreateWithoutUserInput[] | SalesforceContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutUserInput | SalesforceContactCreateOrConnectWithoutUserInput[]
    createMany?: SalesforceContactCreateManyUserInputEnvelope
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
  }

  export type SalesforceOpportunityCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutUserInput, SalesforceOpportunityUncheckedCreateWithoutUserInput> | SalesforceOpportunityCreateWithoutUserInput[] | SalesforceOpportunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutUserInput | SalesforceOpportunityCreateOrConnectWithoutUserInput[]
    createMany?: SalesforceOpportunityCreateManyUserInputEnvelope
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
  }

  export type FundCreateNestedManyWithoutUserInput = {
    create?: XOR<FundCreateWithoutUserInput, FundUncheckedCreateWithoutUserInput> | FundCreateWithoutUserInput[] | FundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FundCreateOrConnectWithoutUserInput | FundCreateOrConnectWithoutUserInput[]
    createMany?: FundCreateManyUserInputEnvelope
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
  }

  export type InvestorCreateNestedManyWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput> | InvestorCreateWithoutUserInput[] | InvestorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput | InvestorCreateOrConnectWithoutUserInput[]
    createMany?: InvestorCreateManyUserInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type LPGroupCreateNestedManyWithoutUserInput = {
    create?: XOR<LPGroupCreateWithoutUserInput, LPGroupUncheckedCreateWithoutUserInput> | LPGroupCreateWithoutUserInput[] | LPGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LPGroupCreateOrConnectWithoutUserInput | LPGroupCreateOrConnectWithoutUserInput[]
    createMany?: LPGroupCreateManyUserInputEnvelope
    connect?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type IntegrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DealCreateWithoutUserInput, DealUncheckedCreateWithoutUserInput> | DealCreateWithoutUserInput[] | DealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealCreateOrConnectWithoutUserInput | DealCreateOrConnectWithoutUserInput[]
    createMany?: DealCreateManyUserInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunicationCreateWithoutUserInput, CommunicationUncheckedCreateWithoutUserInput> | CommunicationCreateWithoutUserInput[] | CommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUserInput | CommunicationCreateOrConnectWithoutUserInput[]
    createMany?: CommunicationCreateManyUserInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type TeamsMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamsMessageCreateWithoutUserInput, TeamsMessageUncheckedCreateWithoutUserInput> | TeamsMessageCreateWithoutUserInput[] | TeamsMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutUserInput | TeamsMessageCreateOrConnectWithoutUserInput[]
    createMany?: TeamsMessageCreateManyUserInputEnvelope
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
  }

  export type TeamsChannelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamsChannelCreateWithoutUserInput, TeamsChannelUncheckedCreateWithoutUserInput> | TeamsChannelCreateWithoutUserInput[] | TeamsChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsChannelCreateOrConnectWithoutUserInput | TeamsChannelCreateOrConnectWithoutUserInput[]
    createMany?: TeamsChannelCreateManyUserInputEnvelope
    connect?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
  }

  export type SlackMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SlackMessageCreateWithoutUserInput, SlackMessageUncheckedCreateWithoutUserInput> | SlackMessageCreateWithoutUserInput[] | SlackMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutUserInput | SlackMessageCreateOrConnectWithoutUserInput[]
    createMany?: SlackMessageCreateManyUserInputEnvelope
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
  }

  export type SlackChannelUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SlackChannelCreateWithoutUserInput, SlackChannelUncheckedCreateWithoutUserInput> | SlackChannelCreateWithoutUserInput[] | SlackChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackChannelCreateOrConnectWithoutUserInput | SlackChannelCreateOrConnectWithoutUserInput[]
    createMany?: SlackChannelCreateManyUserInputEnvelope
    connect?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
  }

  export type ZoomMeetingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoomMeetingCreateWithoutUserInput, ZoomMeetingUncheckedCreateWithoutUserInput> | ZoomMeetingCreateWithoutUserInput[] | ZoomMeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutUserInput | ZoomMeetingCreateOrConnectWithoutUserInput[]
    createMany?: ZoomMeetingCreateManyUserInputEnvelope
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
  }

  export type ZoomParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ZoomParticipantCreateWithoutUserInput, ZoomParticipantUncheckedCreateWithoutUserInput> | ZoomParticipantCreateWithoutUserInput[] | ZoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutUserInput | ZoomParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ZoomParticipantCreateManyUserInputEnvelope
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
  }

  export type SalesforceAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesforceAccountCreateWithoutUserInput, SalesforceAccountUncheckedCreateWithoutUserInput> | SalesforceAccountCreateWithoutUserInput[] | SalesforceAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutUserInput | SalesforceAccountCreateOrConnectWithoutUserInput[]
    createMany?: SalesforceAccountCreateManyUserInputEnvelope
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
  }

  export type SalesforceContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesforceContactCreateWithoutUserInput, SalesforceContactUncheckedCreateWithoutUserInput> | SalesforceContactCreateWithoutUserInput[] | SalesforceContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutUserInput | SalesforceContactCreateOrConnectWithoutUserInput[]
    createMany?: SalesforceContactCreateManyUserInputEnvelope
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
  }

  export type SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutUserInput, SalesforceOpportunityUncheckedCreateWithoutUserInput> | SalesforceOpportunityCreateWithoutUserInput[] | SalesforceOpportunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutUserInput | SalesforceOpportunityCreateOrConnectWithoutUserInput[]
    createMany?: SalesforceOpportunityCreateManyUserInputEnvelope
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
  }

  export type FundUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FundCreateWithoutUserInput, FundUncheckedCreateWithoutUserInput> | FundCreateWithoutUserInput[] | FundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FundCreateOrConnectWithoutUserInput | FundCreateOrConnectWithoutUserInput[]
    createMany?: FundCreateManyUserInputEnvelope
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
  }

  export type InvestorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput> | InvestorCreateWithoutUserInput[] | InvestorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput | InvestorCreateOrConnectWithoutUserInput[]
    createMany?: InvestorCreateManyUserInputEnvelope
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
  }

  export type LPGroupUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LPGroupCreateWithoutUserInput, LPGroupUncheckedCreateWithoutUserInput> | LPGroupCreateWithoutUserInput[] | LPGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LPGroupCreateOrConnectWithoutUserInput | LPGroupCreateOrConnectWithoutUserInput[]
    createMany?: LPGroupCreateManyUserInputEnvelope
    connect?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutUserInput | IntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutUserInput | IntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutUserInput | IntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type DealUpdateManyWithoutUserNestedInput = {
    create?: XOR<DealCreateWithoutUserInput, DealUncheckedCreateWithoutUserInput> | DealCreateWithoutUserInput[] | DealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealCreateOrConnectWithoutUserInput | DealCreateOrConnectWithoutUserInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutUserInput | DealUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DealCreateManyUserInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutUserInput | DealUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DealUpdateManyWithWhereWithoutUserInput | DealUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunicationCreateWithoutUserInput, CommunicationUncheckedCreateWithoutUserInput> | CommunicationCreateWithoutUserInput[] | CommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUserInput | CommunicationCreateOrConnectWithoutUserInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutUserInput | CommunicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunicationCreateManyUserInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutUserInput | CommunicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutUserInput | CommunicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type TeamsMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamsMessageCreateWithoutUserInput, TeamsMessageUncheckedCreateWithoutUserInput> | TeamsMessageCreateWithoutUserInput[] | TeamsMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutUserInput | TeamsMessageCreateOrConnectWithoutUserInput[]
    upsert?: TeamsMessageUpsertWithWhereUniqueWithoutUserInput | TeamsMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamsMessageCreateManyUserInputEnvelope
    set?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    disconnect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    delete?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    update?: TeamsMessageUpdateWithWhereUniqueWithoutUserInput | TeamsMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamsMessageUpdateManyWithWhereWithoutUserInput | TeamsMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
  }

  export type TeamsChannelUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamsChannelCreateWithoutUserInput, TeamsChannelUncheckedCreateWithoutUserInput> | TeamsChannelCreateWithoutUserInput[] | TeamsChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsChannelCreateOrConnectWithoutUserInput | TeamsChannelCreateOrConnectWithoutUserInput[]
    upsert?: TeamsChannelUpsertWithWhereUniqueWithoutUserInput | TeamsChannelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamsChannelCreateManyUserInputEnvelope
    set?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    disconnect?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    delete?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    connect?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    update?: TeamsChannelUpdateWithWhereUniqueWithoutUserInput | TeamsChannelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamsChannelUpdateManyWithWhereWithoutUserInput | TeamsChannelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamsChannelScalarWhereInput | TeamsChannelScalarWhereInput[]
  }

  export type SlackMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<SlackMessageCreateWithoutUserInput, SlackMessageUncheckedCreateWithoutUserInput> | SlackMessageCreateWithoutUserInput[] | SlackMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutUserInput | SlackMessageCreateOrConnectWithoutUserInput[]
    upsert?: SlackMessageUpsertWithWhereUniqueWithoutUserInput | SlackMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SlackMessageCreateManyUserInputEnvelope
    set?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    disconnect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    delete?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    update?: SlackMessageUpdateWithWhereUniqueWithoutUserInput | SlackMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SlackMessageUpdateManyWithWhereWithoutUserInput | SlackMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
  }

  export type SlackChannelUpdateManyWithoutUserNestedInput = {
    create?: XOR<SlackChannelCreateWithoutUserInput, SlackChannelUncheckedCreateWithoutUserInput> | SlackChannelCreateWithoutUserInput[] | SlackChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackChannelCreateOrConnectWithoutUserInput | SlackChannelCreateOrConnectWithoutUserInput[]
    upsert?: SlackChannelUpsertWithWhereUniqueWithoutUserInput | SlackChannelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SlackChannelCreateManyUserInputEnvelope
    set?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    disconnect?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    delete?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    connect?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    update?: SlackChannelUpdateWithWhereUniqueWithoutUserInput | SlackChannelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SlackChannelUpdateManyWithWhereWithoutUserInput | SlackChannelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SlackChannelScalarWhereInput | SlackChannelScalarWhereInput[]
  }

  export type ZoomMeetingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoomMeetingCreateWithoutUserInput, ZoomMeetingUncheckedCreateWithoutUserInput> | ZoomMeetingCreateWithoutUserInput[] | ZoomMeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutUserInput | ZoomMeetingCreateOrConnectWithoutUserInput[]
    upsert?: ZoomMeetingUpsertWithWhereUniqueWithoutUserInput | ZoomMeetingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoomMeetingCreateManyUserInputEnvelope
    set?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    disconnect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    delete?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    update?: ZoomMeetingUpdateWithWhereUniqueWithoutUserInput | ZoomMeetingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoomMeetingUpdateManyWithWhereWithoutUserInput | ZoomMeetingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoomMeetingScalarWhereInput | ZoomMeetingScalarWhereInput[]
  }

  export type ZoomParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoomParticipantCreateWithoutUserInput, ZoomParticipantUncheckedCreateWithoutUserInput> | ZoomParticipantCreateWithoutUserInput[] | ZoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutUserInput | ZoomParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ZoomParticipantUpsertWithWhereUniqueWithoutUserInput | ZoomParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoomParticipantCreateManyUserInputEnvelope
    set?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    disconnect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    delete?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    update?: ZoomParticipantUpdateWithWhereUniqueWithoutUserInput | ZoomParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoomParticipantUpdateManyWithWhereWithoutUserInput | ZoomParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoomParticipantScalarWhereInput | ZoomParticipantScalarWhereInput[]
  }

  export type SalesforceAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesforceAccountCreateWithoutUserInput, SalesforceAccountUncheckedCreateWithoutUserInput> | SalesforceAccountCreateWithoutUserInput[] | SalesforceAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutUserInput | SalesforceAccountCreateOrConnectWithoutUserInput[]
    upsert?: SalesforceAccountUpsertWithWhereUniqueWithoutUserInput | SalesforceAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesforceAccountCreateManyUserInputEnvelope
    set?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    disconnect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    delete?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    update?: SalesforceAccountUpdateWithWhereUniqueWithoutUserInput | SalesforceAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesforceAccountUpdateManyWithWhereWithoutUserInput | SalesforceAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesforceAccountScalarWhereInput | SalesforceAccountScalarWhereInput[]
  }

  export type SalesforceContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesforceContactCreateWithoutUserInput, SalesforceContactUncheckedCreateWithoutUserInput> | SalesforceContactCreateWithoutUserInput[] | SalesforceContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutUserInput | SalesforceContactCreateOrConnectWithoutUserInput[]
    upsert?: SalesforceContactUpsertWithWhereUniqueWithoutUserInput | SalesforceContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesforceContactCreateManyUserInputEnvelope
    set?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    disconnect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    delete?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    update?: SalesforceContactUpdateWithWhereUniqueWithoutUserInput | SalesforceContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesforceContactUpdateManyWithWhereWithoutUserInput | SalesforceContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesforceContactScalarWhereInput | SalesforceContactScalarWhereInput[]
  }

  export type SalesforceOpportunityUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutUserInput, SalesforceOpportunityUncheckedCreateWithoutUserInput> | SalesforceOpportunityCreateWithoutUserInput[] | SalesforceOpportunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutUserInput | SalesforceOpportunityCreateOrConnectWithoutUserInput[]
    upsert?: SalesforceOpportunityUpsertWithWhereUniqueWithoutUserInput | SalesforceOpportunityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesforceOpportunityCreateManyUserInputEnvelope
    set?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    disconnect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    delete?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    update?: SalesforceOpportunityUpdateWithWhereUniqueWithoutUserInput | SalesforceOpportunityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesforceOpportunityUpdateManyWithWhereWithoutUserInput | SalesforceOpportunityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
  }

  export type FundUpdateManyWithoutUserNestedInput = {
    create?: XOR<FundCreateWithoutUserInput, FundUncheckedCreateWithoutUserInput> | FundCreateWithoutUserInput[] | FundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FundCreateOrConnectWithoutUserInput | FundCreateOrConnectWithoutUserInput[]
    upsert?: FundUpsertWithWhereUniqueWithoutUserInput | FundUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FundCreateManyUserInputEnvelope
    set?: FundWhereUniqueInput | FundWhereUniqueInput[]
    disconnect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    delete?: FundWhereUniqueInput | FundWhereUniqueInput[]
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    update?: FundUpdateWithWhereUniqueWithoutUserInput | FundUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FundUpdateManyWithWhereWithoutUserInput | FundUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FundScalarWhereInput | FundScalarWhereInput[]
  }

  export type InvestorUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput> | InvestorCreateWithoutUserInput[] | InvestorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput | InvestorCreateOrConnectWithoutUserInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutUserInput | InvestorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvestorCreateManyUserInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutUserInput | InvestorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutUserInput | InvestorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type LPGroupUpdateManyWithoutUserNestedInput = {
    create?: XOR<LPGroupCreateWithoutUserInput, LPGroupUncheckedCreateWithoutUserInput> | LPGroupCreateWithoutUserInput[] | LPGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LPGroupCreateOrConnectWithoutUserInput | LPGroupCreateOrConnectWithoutUserInput[]
    upsert?: LPGroupUpsertWithWhereUniqueWithoutUserInput | LPGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LPGroupCreateManyUserInputEnvelope
    set?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    disconnect?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    delete?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    connect?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    update?: LPGroupUpdateWithWhereUniqueWithoutUserInput | LPGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LPGroupUpdateManyWithWhereWithoutUserInput | LPGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LPGroupScalarWhereInput | LPGroupScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutUserInput | IntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutUserInput | IntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutUserInput | IntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DealCreateWithoutUserInput, DealUncheckedCreateWithoutUserInput> | DealCreateWithoutUserInput[] | DealUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DealCreateOrConnectWithoutUserInput | DealCreateOrConnectWithoutUserInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutUserInput | DealUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DealCreateManyUserInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutUserInput | DealUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DealUpdateManyWithWhereWithoutUserInput | DealUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput> | ContactCreateWithoutUserInput[] | ContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUserInput | ContactCreateOrConnectWithoutUserInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUserInput | ContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactCreateManyUserInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUserInput | ContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUserInput | ContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunicationCreateWithoutUserInput, CommunicationUncheckedCreateWithoutUserInput> | CommunicationCreateWithoutUserInput[] | CommunicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUserInput | CommunicationCreateOrConnectWithoutUserInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutUserInput | CommunicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunicationCreateManyUserInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutUserInput | CommunicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutUserInput | CommunicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type TeamsMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamsMessageCreateWithoutUserInput, TeamsMessageUncheckedCreateWithoutUserInput> | TeamsMessageCreateWithoutUserInput[] | TeamsMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutUserInput | TeamsMessageCreateOrConnectWithoutUserInput[]
    upsert?: TeamsMessageUpsertWithWhereUniqueWithoutUserInput | TeamsMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamsMessageCreateManyUserInputEnvelope
    set?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    disconnect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    delete?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    update?: TeamsMessageUpdateWithWhereUniqueWithoutUserInput | TeamsMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamsMessageUpdateManyWithWhereWithoutUserInput | TeamsMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
  }

  export type TeamsChannelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamsChannelCreateWithoutUserInput, TeamsChannelUncheckedCreateWithoutUserInput> | TeamsChannelCreateWithoutUserInput[] | TeamsChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamsChannelCreateOrConnectWithoutUserInput | TeamsChannelCreateOrConnectWithoutUserInput[]
    upsert?: TeamsChannelUpsertWithWhereUniqueWithoutUserInput | TeamsChannelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamsChannelCreateManyUserInputEnvelope
    set?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    disconnect?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    delete?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    connect?: TeamsChannelWhereUniqueInput | TeamsChannelWhereUniqueInput[]
    update?: TeamsChannelUpdateWithWhereUniqueWithoutUserInput | TeamsChannelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamsChannelUpdateManyWithWhereWithoutUserInput | TeamsChannelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamsChannelScalarWhereInput | TeamsChannelScalarWhereInput[]
  }

  export type SlackMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SlackMessageCreateWithoutUserInput, SlackMessageUncheckedCreateWithoutUserInput> | SlackMessageCreateWithoutUserInput[] | SlackMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutUserInput | SlackMessageCreateOrConnectWithoutUserInput[]
    upsert?: SlackMessageUpsertWithWhereUniqueWithoutUserInput | SlackMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SlackMessageCreateManyUserInputEnvelope
    set?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    disconnect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    delete?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    update?: SlackMessageUpdateWithWhereUniqueWithoutUserInput | SlackMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SlackMessageUpdateManyWithWhereWithoutUserInput | SlackMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
  }

  export type SlackChannelUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SlackChannelCreateWithoutUserInput, SlackChannelUncheckedCreateWithoutUserInput> | SlackChannelCreateWithoutUserInput[] | SlackChannelUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SlackChannelCreateOrConnectWithoutUserInput | SlackChannelCreateOrConnectWithoutUserInput[]
    upsert?: SlackChannelUpsertWithWhereUniqueWithoutUserInput | SlackChannelUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SlackChannelCreateManyUserInputEnvelope
    set?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    disconnect?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    delete?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    connect?: SlackChannelWhereUniqueInput | SlackChannelWhereUniqueInput[]
    update?: SlackChannelUpdateWithWhereUniqueWithoutUserInput | SlackChannelUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SlackChannelUpdateManyWithWhereWithoutUserInput | SlackChannelUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SlackChannelScalarWhereInput | SlackChannelScalarWhereInput[]
  }

  export type ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoomMeetingCreateWithoutUserInput, ZoomMeetingUncheckedCreateWithoutUserInput> | ZoomMeetingCreateWithoutUserInput[] | ZoomMeetingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutUserInput | ZoomMeetingCreateOrConnectWithoutUserInput[]
    upsert?: ZoomMeetingUpsertWithWhereUniqueWithoutUserInput | ZoomMeetingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoomMeetingCreateManyUserInputEnvelope
    set?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    disconnect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    delete?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    update?: ZoomMeetingUpdateWithWhereUniqueWithoutUserInput | ZoomMeetingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoomMeetingUpdateManyWithWhereWithoutUserInput | ZoomMeetingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoomMeetingScalarWhereInput | ZoomMeetingScalarWhereInput[]
  }

  export type ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ZoomParticipantCreateWithoutUserInput, ZoomParticipantUncheckedCreateWithoutUserInput> | ZoomParticipantCreateWithoutUserInput[] | ZoomParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutUserInput | ZoomParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ZoomParticipantUpsertWithWhereUniqueWithoutUserInput | ZoomParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ZoomParticipantCreateManyUserInputEnvelope
    set?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    disconnect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    delete?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    update?: ZoomParticipantUpdateWithWhereUniqueWithoutUserInput | ZoomParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ZoomParticipantUpdateManyWithWhereWithoutUserInput | ZoomParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ZoomParticipantScalarWhereInput | ZoomParticipantScalarWhereInput[]
  }

  export type SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesforceAccountCreateWithoutUserInput, SalesforceAccountUncheckedCreateWithoutUserInput> | SalesforceAccountCreateWithoutUserInput[] | SalesforceAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutUserInput | SalesforceAccountCreateOrConnectWithoutUserInput[]
    upsert?: SalesforceAccountUpsertWithWhereUniqueWithoutUserInput | SalesforceAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesforceAccountCreateManyUserInputEnvelope
    set?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    disconnect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    delete?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    update?: SalesforceAccountUpdateWithWhereUniqueWithoutUserInput | SalesforceAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesforceAccountUpdateManyWithWhereWithoutUserInput | SalesforceAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesforceAccountScalarWhereInput | SalesforceAccountScalarWhereInput[]
  }

  export type SalesforceContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesforceContactCreateWithoutUserInput, SalesforceContactUncheckedCreateWithoutUserInput> | SalesforceContactCreateWithoutUserInput[] | SalesforceContactUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutUserInput | SalesforceContactCreateOrConnectWithoutUserInput[]
    upsert?: SalesforceContactUpsertWithWhereUniqueWithoutUserInput | SalesforceContactUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesforceContactCreateManyUserInputEnvelope
    set?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    disconnect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    delete?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    update?: SalesforceContactUpdateWithWhereUniqueWithoutUserInput | SalesforceContactUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesforceContactUpdateManyWithWhereWithoutUserInput | SalesforceContactUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesforceContactScalarWhereInput | SalesforceContactScalarWhereInput[]
  }

  export type SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutUserInput, SalesforceOpportunityUncheckedCreateWithoutUserInput> | SalesforceOpportunityCreateWithoutUserInput[] | SalesforceOpportunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutUserInput | SalesforceOpportunityCreateOrConnectWithoutUserInput[]
    upsert?: SalesforceOpportunityUpsertWithWhereUniqueWithoutUserInput | SalesforceOpportunityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SalesforceOpportunityCreateManyUserInputEnvelope
    set?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    disconnect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    delete?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    update?: SalesforceOpportunityUpdateWithWhereUniqueWithoutUserInput | SalesforceOpportunityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SalesforceOpportunityUpdateManyWithWhereWithoutUserInput | SalesforceOpportunityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
  }

  export type FundUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FundCreateWithoutUserInput, FundUncheckedCreateWithoutUserInput> | FundCreateWithoutUserInput[] | FundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FundCreateOrConnectWithoutUserInput | FundCreateOrConnectWithoutUserInput[]
    upsert?: FundUpsertWithWhereUniqueWithoutUserInput | FundUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FundCreateManyUserInputEnvelope
    set?: FundWhereUniqueInput | FundWhereUniqueInput[]
    disconnect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    delete?: FundWhereUniqueInput | FundWhereUniqueInput[]
    connect?: FundWhereUniqueInput | FundWhereUniqueInput[]
    update?: FundUpdateWithWhereUniqueWithoutUserInput | FundUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FundUpdateManyWithWhereWithoutUserInput | FundUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FundScalarWhereInput | FundScalarWhereInput[]
  }

  export type InvestorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput> | InvestorCreateWithoutUserInput[] | InvestorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvestorCreateOrConnectWithoutUserInput | InvestorCreateOrConnectWithoutUserInput[]
    upsert?: InvestorUpsertWithWhereUniqueWithoutUserInput | InvestorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvestorCreateManyUserInputEnvelope
    set?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    disconnect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    delete?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    connect?: InvestorWhereUniqueInput | InvestorWhereUniqueInput[]
    update?: InvestorUpdateWithWhereUniqueWithoutUserInput | InvestorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvestorUpdateManyWithWhereWithoutUserInput | InvestorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
  }

  export type LPGroupUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LPGroupCreateWithoutUserInput, LPGroupUncheckedCreateWithoutUserInput> | LPGroupCreateWithoutUserInput[] | LPGroupUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LPGroupCreateOrConnectWithoutUserInput | LPGroupCreateOrConnectWithoutUserInput[]
    upsert?: LPGroupUpsertWithWhereUniqueWithoutUserInput | LPGroupUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LPGroupCreateManyUserInputEnvelope
    set?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    disconnect?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    delete?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    connect?: LPGroupWhereUniqueInput | LPGroupWhereUniqueInput[]
    update?: LPGroupUpdateWithWhereUniqueWithoutUserInput | LPGroupUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LPGroupUpdateManyWithWhereWithoutUserInput | LPGroupUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LPGroupScalarWhereInput | LPGroupScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type IntegrationCreatescopeInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type IntegrationUpdatescopeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIntegrationsInput
    upsert?: UserUpsertWithoutIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIntegrationsInput, UserUpdateWithoutIntegrationsInput>, UserUncheckedUpdateWithoutIntegrationsInput>
  }

  export type DealCreateteamInput = {
    set: string[]
  }

  export type DealCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDealsInput = {
    create?: XOR<UserCreateWithoutDealsInput, UserUncheckedCreateWithoutDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealsInput
    connect?: UserWhereUniqueInput
  }

  export type ContactCreateNestedManyWithoutDealInput = {
    create?: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput> | ContactCreateWithoutDealInput[] | ContactUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDealInput | ContactCreateOrConnectWithoutDealInput[]
    createMany?: ContactCreateManyDealInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutDealInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutDealInput = {
    create?: XOR<CommunicationCreateWithoutDealInput, CommunicationUncheckedCreateWithoutDealInput> | CommunicationCreateWithoutDealInput[] | CommunicationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutDealInput | CommunicationCreateOrConnectWithoutDealInput[]
    createMany?: CommunicationCreateManyDealInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type TeamsMessageCreateNestedManyWithoutDealInput = {
    create?: XOR<TeamsMessageCreateWithoutDealInput, TeamsMessageUncheckedCreateWithoutDealInput> | TeamsMessageCreateWithoutDealInput[] | TeamsMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutDealInput | TeamsMessageCreateOrConnectWithoutDealInput[]
    createMany?: TeamsMessageCreateManyDealInputEnvelope
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
  }

  export type SlackMessageCreateNestedManyWithoutDealInput = {
    create?: XOR<SlackMessageCreateWithoutDealInput, SlackMessageUncheckedCreateWithoutDealInput> | SlackMessageCreateWithoutDealInput[] | SlackMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutDealInput | SlackMessageCreateOrConnectWithoutDealInput[]
    createMany?: SlackMessageCreateManyDealInputEnvelope
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
  }

  export type ZoomMeetingCreateNestedManyWithoutDealInput = {
    create?: XOR<ZoomMeetingCreateWithoutDealInput, ZoomMeetingUncheckedCreateWithoutDealInput> | ZoomMeetingCreateWithoutDealInput[] | ZoomMeetingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutDealInput | ZoomMeetingCreateOrConnectWithoutDealInput[]
    createMany?: ZoomMeetingCreateManyDealInputEnvelope
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
  }

  export type SalesforceAccountCreateNestedManyWithoutDealInput = {
    create?: XOR<SalesforceAccountCreateWithoutDealInput, SalesforceAccountUncheckedCreateWithoutDealInput> | SalesforceAccountCreateWithoutDealInput[] | SalesforceAccountUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutDealInput | SalesforceAccountCreateOrConnectWithoutDealInput[]
    createMany?: SalesforceAccountCreateManyDealInputEnvelope
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
  }

  export type SalesforceOpportunityCreateNestedManyWithoutDealInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutDealInput, SalesforceOpportunityUncheckedCreateWithoutDealInput> | SalesforceOpportunityCreateWithoutDealInput[] | SalesforceOpportunityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutDealInput | SalesforceOpportunityCreateOrConnectWithoutDealInput[]
    createMany?: SalesforceOpportunityCreateManyDealInputEnvelope
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput> | ContactCreateWithoutDealInput[] | ContactUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDealInput | ContactCreateOrConnectWithoutDealInput[]
    createMany?: ContactCreateManyDealInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<CommunicationCreateWithoutDealInput, CommunicationUncheckedCreateWithoutDealInput> | CommunicationCreateWithoutDealInput[] | CommunicationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutDealInput | CommunicationCreateOrConnectWithoutDealInput[]
    createMany?: CommunicationCreateManyDealInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type TeamsMessageUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<TeamsMessageCreateWithoutDealInput, TeamsMessageUncheckedCreateWithoutDealInput> | TeamsMessageCreateWithoutDealInput[] | TeamsMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutDealInput | TeamsMessageCreateOrConnectWithoutDealInput[]
    createMany?: TeamsMessageCreateManyDealInputEnvelope
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
  }

  export type SlackMessageUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<SlackMessageCreateWithoutDealInput, SlackMessageUncheckedCreateWithoutDealInput> | SlackMessageCreateWithoutDealInput[] | SlackMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutDealInput | SlackMessageCreateOrConnectWithoutDealInput[]
    createMany?: SlackMessageCreateManyDealInputEnvelope
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
  }

  export type ZoomMeetingUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<ZoomMeetingCreateWithoutDealInput, ZoomMeetingUncheckedCreateWithoutDealInput> | ZoomMeetingCreateWithoutDealInput[] | ZoomMeetingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutDealInput | ZoomMeetingCreateOrConnectWithoutDealInput[]
    createMany?: ZoomMeetingCreateManyDealInputEnvelope
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
  }

  export type SalesforceAccountUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<SalesforceAccountCreateWithoutDealInput, SalesforceAccountUncheckedCreateWithoutDealInput> | SalesforceAccountCreateWithoutDealInput[] | SalesforceAccountUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutDealInput | SalesforceAccountCreateOrConnectWithoutDealInput[]
    createMany?: SalesforceAccountCreateManyDealInputEnvelope
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
  }

  export type SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutDealInput, SalesforceOpportunityUncheckedCreateWithoutDealInput> | SalesforceOpportunityCreateWithoutDealInput[] | SalesforceOpportunityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutDealInput | SalesforceOpportunityCreateOrConnectWithoutDealInput[]
    createMany?: SalesforceOpportunityCreateManyDealInputEnvelope
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DealUpdateteamInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DealUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<UserCreateWithoutDealsInput, UserUncheckedCreateWithoutDealsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDealsInput
    upsert?: UserUpsertWithoutDealsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDealsInput, UserUpdateWithoutDealsInput>, UserUncheckedUpdateWithoutDealsInput>
  }

  export type ContactUpdateManyWithoutDealNestedInput = {
    create?: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput> | ContactCreateWithoutDealInput[] | ContactUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDealInput | ContactCreateOrConnectWithoutDealInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutDealInput | ContactUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ContactCreateManyDealInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutDealInput | ContactUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutDealInput | ContactUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutDealNestedInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDealInput | ActivityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDealInput | ActivityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDealInput | ActivityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutDealNestedInput = {
    create?: XOR<CommunicationCreateWithoutDealInput, CommunicationUncheckedCreateWithoutDealInput> | CommunicationCreateWithoutDealInput[] | CommunicationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutDealInput | CommunicationCreateOrConnectWithoutDealInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutDealInput | CommunicationUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CommunicationCreateManyDealInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutDealInput | CommunicationUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutDealInput | CommunicationUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type TeamsMessageUpdateManyWithoutDealNestedInput = {
    create?: XOR<TeamsMessageCreateWithoutDealInput, TeamsMessageUncheckedCreateWithoutDealInput> | TeamsMessageCreateWithoutDealInput[] | TeamsMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutDealInput | TeamsMessageCreateOrConnectWithoutDealInput[]
    upsert?: TeamsMessageUpsertWithWhereUniqueWithoutDealInput | TeamsMessageUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TeamsMessageCreateManyDealInputEnvelope
    set?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    disconnect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    delete?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    update?: TeamsMessageUpdateWithWhereUniqueWithoutDealInput | TeamsMessageUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TeamsMessageUpdateManyWithWhereWithoutDealInput | TeamsMessageUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
  }

  export type SlackMessageUpdateManyWithoutDealNestedInput = {
    create?: XOR<SlackMessageCreateWithoutDealInput, SlackMessageUncheckedCreateWithoutDealInput> | SlackMessageCreateWithoutDealInput[] | SlackMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutDealInput | SlackMessageCreateOrConnectWithoutDealInput[]
    upsert?: SlackMessageUpsertWithWhereUniqueWithoutDealInput | SlackMessageUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SlackMessageCreateManyDealInputEnvelope
    set?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    disconnect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    delete?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    update?: SlackMessageUpdateWithWhereUniqueWithoutDealInput | SlackMessageUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SlackMessageUpdateManyWithWhereWithoutDealInput | SlackMessageUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
  }

  export type ZoomMeetingUpdateManyWithoutDealNestedInput = {
    create?: XOR<ZoomMeetingCreateWithoutDealInput, ZoomMeetingUncheckedCreateWithoutDealInput> | ZoomMeetingCreateWithoutDealInput[] | ZoomMeetingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutDealInput | ZoomMeetingCreateOrConnectWithoutDealInput[]
    upsert?: ZoomMeetingUpsertWithWhereUniqueWithoutDealInput | ZoomMeetingUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ZoomMeetingCreateManyDealInputEnvelope
    set?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    disconnect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    delete?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    update?: ZoomMeetingUpdateWithWhereUniqueWithoutDealInput | ZoomMeetingUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ZoomMeetingUpdateManyWithWhereWithoutDealInput | ZoomMeetingUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ZoomMeetingScalarWhereInput | ZoomMeetingScalarWhereInput[]
  }

  export type SalesforceAccountUpdateManyWithoutDealNestedInput = {
    create?: XOR<SalesforceAccountCreateWithoutDealInput, SalesforceAccountUncheckedCreateWithoutDealInput> | SalesforceAccountCreateWithoutDealInput[] | SalesforceAccountUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutDealInput | SalesforceAccountCreateOrConnectWithoutDealInput[]
    upsert?: SalesforceAccountUpsertWithWhereUniqueWithoutDealInput | SalesforceAccountUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SalesforceAccountCreateManyDealInputEnvelope
    set?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    disconnect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    delete?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    update?: SalesforceAccountUpdateWithWhereUniqueWithoutDealInput | SalesforceAccountUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SalesforceAccountUpdateManyWithWhereWithoutDealInput | SalesforceAccountUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SalesforceAccountScalarWhereInput | SalesforceAccountScalarWhereInput[]
  }

  export type SalesforceOpportunityUpdateManyWithoutDealNestedInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutDealInput, SalesforceOpportunityUncheckedCreateWithoutDealInput> | SalesforceOpportunityCreateWithoutDealInput[] | SalesforceOpportunityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutDealInput | SalesforceOpportunityCreateOrConnectWithoutDealInput[]
    upsert?: SalesforceOpportunityUpsertWithWhereUniqueWithoutDealInput | SalesforceOpportunityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SalesforceOpportunityCreateManyDealInputEnvelope
    set?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    disconnect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    delete?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    update?: SalesforceOpportunityUpdateWithWhereUniqueWithoutDealInput | SalesforceOpportunityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SalesforceOpportunityUpdateManyWithWhereWithoutDealInput | SalesforceOpportunityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput> | ContactCreateWithoutDealInput[] | ContactUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutDealInput | ContactCreateOrConnectWithoutDealInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutDealInput | ContactUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ContactCreateManyDealInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutDealInput | ContactUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutDealInput | ContactUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput> | DocumentCreateWithoutDealInput[] | DocumentUncheckedCreateWithoutDealInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutDealInput | DocumentCreateOrConnectWithoutDealInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutDealInput | DocumentUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: DocumentCreateManyDealInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutDealInput | DocumentUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutDealInput | DocumentUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput> | ActivityCreateWithoutDealInput[] | ActivityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutDealInput | ActivityCreateOrConnectWithoutDealInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutDealInput | ActivityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ActivityCreateManyDealInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutDealInput | ActivityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutDealInput | ActivityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<CommunicationCreateWithoutDealInput, CommunicationUncheckedCreateWithoutDealInput> | CommunicationCreateWithoutDealInput[] | CommunicationUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutDealInput | CommunicationCreateOrConnectWithoutDealInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutDealInput | CommunicationUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CommunicationCreateManyDealInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutDealInput | CommunicationUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutDealInput | CommunicationUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type TeamsMessageUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<TeamsMessageCreateWithoutDealInput, TeamsMessageUncheckedCreateWithoutDealInput> | TeamsMessageCreateWithoutDealInput[] | TeamsMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutDealInput | TeamsMessageCreateOrConnectWithoutDealInput[]
    upsert?: TeamsMessageUpsertWithWhereUniqueWithoutDealInput | TeamsMessageUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TeamsMessageCreateManyDealInputEnvelope
    set?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    disconnect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    delete?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    update?: TeamsMessageUpdateWithWhereUniqueWithoutDealInput | TeamsMessageUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TeamsMessageUpdateManyWithWhereWithoutDealInput | TeamsMessageUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
  }

  export type SlackMessageUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<SlackMessageCreateWithoutDealInput, SlackMessageUncheckedCreateWithoutDealInput> | SlackMessageCreateWithoutDealInput[] | SlackMessageUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutDealInput | SlackMessageCreateOrConnectWithoutDealInput[]
    upsert?: SlackMessageUpsertWithWhereUniqueWithoutDealInput | SlackMessageUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SlackMessageCreateManyDealInputEnvelope
    set?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    disconnect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    delete?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    update?: SlackMessageUpdateWithWhereUniqueWithoutDealInput | SlackMessageUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SlackMessageUpdateManyWithWhereWithoutDealInput | SlackMessageUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
  }

  export type ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<ZoomMeetingCreateWithoutDealInput, ZoomMeetingUncheckedCreateWithoutDealInput> | ZoomMeetingCreateWithoutDealInput[] | ZoomMeetingUncheckedCreateWithoutDealInput[]
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutDealInput | ZoomMeetingCreateOrConnectWithoutDealInput[]
    upsert?: ZoomMeetingUpsertWithWhereUniqueWithoutDealInput | ZoomMeetingUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: ZoomMeetingCreateManyDealInputEnvelope
    set?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    disconnect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    delete?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    connect?: ZoomMeetingWhereUniqueInput | ZoomMeetingWhereUniqueInput[]
    update?: ZoomMeetingUpdateWithWhereUniqueWithoutDealInput | ZoomMeetingUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: ZoomMeetingUpdateManyWithWhereWithoutDealInput | ZoomMeetingUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: ZoomMeetingScalarWhereInput | ZoomMeetingScalarWhereInput[]
  }

  export type SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<SalesforceAccountCreateWithoutDealInput, SalesforceAccountUncheckedCreateWithoutDealInput> | SalesforceAccountCreateWithoutDealInput[] | SalesforceAccountUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutDealInput | SalesforceAccountCreateOrConnectWithoutDealInput[]
    upsert?: SalesforceAccountUpsertWithWhereUniqueWithoutDealInput | SalesforceAccountUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SalesforceAccountCreateManyDealInputEnvelope
    set?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    disconnect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    delete?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    connect?: SalesforceAccountWhereUniqueInput | SalesforceAccountWhereUniqueInput[]
    update?: SalesforceAccountUpdateWithWhereUniqueWithoutDealInput | SalesforceAccountUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SalesforceAccountUpdateManyWithWhereWithoutDealInput | SalesforceAccountUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SalesforceAccountScalarWhereInput | SalesforceAccountScalarWhereInput[]
  }

  export type SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutDealInput, SalesforceOpportunityUncheckedCreateWithoutDealInput> | SalesforceOpportunityCreateWithoutDealInput[] | SalesforceOpportunityUncheckedCreateWithoutDealInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutDealInput | SalesforceOpportunityCreateOrConnectWithoutDealInput[]
    upsert?: SalesforceOpportunityUpsertWithWhereUniqueWithoutDealInput | SalesforceOpportunityUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: SalesforceOpportunityCreateManyDealInputEnvelope
    set?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    disconnect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    delete?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    update?: SalesforceOpportunityUpdateWithWhereUniqueWithoutDealInput | SalesforceOpportunityUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: SalesforceOpportunityUpdateManyWithWhereWithoutDealInput | SalesforceOpportunityUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
  }

  export type ContactCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOwnedContactsInput = {
    create?: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedContactsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutContactsInput = {
    create?: XOR<DealCreateWithoutContactsInput, DealUncheckedCreateWithoutContactsInput>
    connectOrCreate?: DealCreateOrConnectWithoutContactsInput
    connect?: DealWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutContactInput = {
    create?: XOR<CommunicationCreateWithoutContactInput, CommunicationUncheckedCreateWithoutContactInput> | CommunicationCreateWithoutContactInput[] | CommunicationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutContactInput | CommunicationCreateOrConnectWithoutContactInput[]
    createMany?: CommunicationCreateManyContactInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type TeamsMessageCreateNestedManyWithoutContactInput = {
    create?: XOR<TeamsMessageCreateWithoutContactInput, TeamsMessageUncheckedCreateWithoutContactInput> | TeamsMessageCreateWithoutContactInput[] | TeamsMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutContactInput | TeamsMessageCreateOrConnectWithoutContactInput[]
    createMany?: TeamsMessageCreateManyContactInputEnvelope
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
  }

  export type SlackMessageCreateNestedManyWithoutContactInput = {
    create?: XOR<SlackMessageCreateWithoutContactInput, SlackMessageUncheckedCreateWithoutContactInput> | SlackMessageCreateWithoutContactInput[] | SlackMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutContactInput | SlackMessageCreateOrConnectWithoutContactInput[]
    createMany?: SlackMessageCreateManyContactInputEnvelope
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CommunicationCreateWithoutContactInput, CommunicationUncheckedCreateWithoutContactInput> | CommunicationCreateWithoutContactInput[] | CommunicationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutContactInput | CommunicationCreateOrConnectWithoutContactInput[]
    createMany?: CommunicationCreateManyContactInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type TeamsMessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<TeamsMessageCreateWithoutContactInput, TeamsMessageUncheckedCreateWithoutContactInput> | TeamsMessageCreateWithoutContactInput[] | TeamsMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutContactInput | TeamsMessageCreateOrConnectWithoutContactInput[]
    createMany?: TeamsMessageCreateManyContactInputEnvelope
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
  }

  export type SlackMessageUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<SlackMessageCreateWithoutContactInput, SlackMessageUncheckedCreateWithoutContactInput> | SlackMessageCreateWithoutContactInput[] | SlackMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutContactInput | SlackMessageCreateOrConnectWithoutContactInput[]
    createMany?: SlackMessageCreateManyContactInputEnvelope
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
  }

  export type ContactUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutOwnedContactsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedContactsInput
    upsert?: UserUpsertWithoutOwnedContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedContactsInput, UserUpdateWithoutOwnedContactsInput>, UserUncheckedUpdateWithoutOwnedContactsInput>
  }

  export type DealUpdateOneWithoutContactsNestedInput = {
    create?: XOR<DealCreateWithoutContactsInput, DealUncheckedCreateWithoutContactsInput>
    connectOrCreate?: DealCreateOrConnectWithoutContactsInput
    upsert?: DealUpsertWithoutContactsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutContactsInput, DealUpdateWithoutContactsInput>, DealUncheckedUpdateWithoutContactsInput>
  }

  export type ActivityUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutContactNestedInput = {
    create?: XOR<CommunicationCreateWithoutContactInput, CommunicationUncheckedCreateWithoutContactInput> | CommunicationCreateWithoutContactInput[] | CommunicationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutContactInput | CommunicationCreateOrConnectWithoutContactInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutContactInput | CommunicationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CommunicationCreateManyContactInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutContactInput | CommunicationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutContactInput | CommunicationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type TeamsMessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<TeamsMessageCreateWithoutContactInput, TeamsMessageUncheckedCreateWithoutContactInput> | TeamsMessageCreateWithoutContactInput[] | TeamsMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutContactInput | TeamsMessageCreateOrConnectWithoutContactInput[]
    upsert?: TeamsMessageUpsertWithWhereUniqueWithoutContactInput | TeamsMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TeamsMessageCreateManyContactInputEnvelope
    set?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    disconnect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    delete?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    update?: TeamsMessageUpdateWithWhereUniqueWithoutContactInput | TeamsMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TeamsMessageUpdateManyWithWhereWithoutContactInput | TeamsMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
  }

  export type SlackMessageUpdateManyWithoutContactNestedInput = {
    create?: XOR<SlackMessageCreateWithoutContactInput, SlackMessageUncheckedCreateWithoutContactInput> | SlackMessageCreateWithoutContactInput[] | SlackMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutContactInput | SlackMessageCreateOrConnectWithoutContactInput[]
    upsert?: SlackMessageUpsertWithWhereUniqueWithoutContactInput | SlackMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: SlackMessageCreateManyContactInputEnvelope
    set?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    disconnect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    delete?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    update?: SlackMessageUpdateWithWhereUniqueWithoutContactInput | SlackMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: SlackMessageUpdateManyWithWhereWithoutContactInput | SlackMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput> | ActivityCreateWithoutContactInput[] | ActivityUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutContactInput | ActivityCreateOrConnectWithoutContactInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutContactInput | ActivityUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ActivityCreateManyContactInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutContactInput | ActivityUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutContactInput | ActivityUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CommunicationCreateWithoutContactInput, CommunicationUncheckedCreateWithoutContactInput> | CommunicationCreateWithoutContactInput[] | CommunicationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutContactInput | CommunicationCreateOrConnectWithoutContactInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutContactInput | CommunicationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CommunicationCreateManyContactInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutContactInput | CommunicationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutContactInput | CommunicationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type TeamsMessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<TeamsMessageCreateWithoutContactInput, TeamsMessageUncheckedCreateWithoutContactInput> | TeamsMessageCreateWithoutContactInput[] | TeamsMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TeamsMessageCreateOrConnectWithoutContactInput | TeamsMessageCreateOrConnectWithoutContactInput[]
    upsert?: TeamsMessageUpsertWithWhereUniqueWithoutContactInput | TeamsMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TeamsMessageCreateManyContactInputEnvelope
    set?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    disconnect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    delete?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    connect?: TeamsMessageWhereUniqueInput | TeamsMessageWhereUniqueInput[]
    update?: TeamsMessageUpdateWithWhereUniqueWithoutContactInput | TeamsMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TeamsMessageUpdateManyWithWhereWithoutContactInput | TeamsMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
  }

  export type SlackMessageUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<SlackMessageCreateWithoutContactInput, SlackMessageUncheckedCreateWithoutContactInput> | SlackMessageCreateWithoutContactInput[] | SlackMessageUncheckedCreateWithoutContactInput[]
    connectOrCreate?: SlackMessageCreateOrConnectWithoutContactInput | SlackMessageCreateOrConnectWithoutContactInput[]
    upsert?: SlackMessageUpsertWithWhereUniqueWithoutContactInput | SlackMessageUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: SlackMessageCreateManyContactInputEnvelope
    set?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    disconnect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    delete?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    connect?: SlackMessageWhereUniqueInput | SlackMessageWhereUniqueInput[]
    update?: SlackMessageUpdateWithWhereUniqueWithoutContactInput | SlackMessageUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: SlackMessageUpdateManyWithWhereWithoutContactInput | SlackMessageUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
  }

  export type ActivityCreateattendeesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: DealCreateOrConnectWithoutActivitiesInput
    connect?: DealWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityUpdateattendeesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type DealUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: DealCreateOrConnectWithoutActivitiesInput
    upsert?: DealUpsertWithoutActivitiesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutActivitiesInput, DealUpdateWithoutActivitiesInput>, DealUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    upsert?: ContactUpsertWithoutActivitiesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutActivitiesInput, ContactUpdateWithoutActivitiesInput>, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type DocumentCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    connect?: DealWhereUniqueInput
  }

  export type DocumentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DealCreateOrConnectWithoutDocumentsInput
    upsert?: DealUpsertWithoutDocumentsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutDocumentsInput, DealUpdateWithoutDocumentsInput>, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type CommunicationCreatetoEmailsInput = {
    set: string[]
  }

  export type CommunicationCreateccEmailsInput = {
    set: string[]
  }

  export type CommunicationCreatebccEmailsInput = {
    set: string[]
  }

  export type CommunicationCreatelabelsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunicationsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<DealCreateWithoutCommunicationsInput, DealUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: DealCreateOrConnectWithoutCommunicationsInput
    connect?: DealWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<ContactCreateWithoutCommunicationsInput, ContactUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCommunicationsInput
    connect?: ContactWhereUniqueInput
  }

  export type CommunicationUpdatetoEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunicationUpdateccEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunicationUpdatebccEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunicationUpdatelabelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCommunicationsNestedInput = {
    create?: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunicationsInput
    upsert?: UserUpsertWithoutCommunicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunicationsInput, UserUpdateWithoutCommunicationsInput>, UserUncheckedUpdateWithoutCommunicationsInput>
  }

  export type DealUpdateOneWithoutCommunicationsNestedInput = {
    create?: XOR<DealCreateWithoutCommunicationsInput, DealUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: DealCreateOrConnectWithoutCommunicationsInput
    upsert?: DealUpsertWithoutCommunicationsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutCommunicationsInput, DealUpdateWithoutCommunicationsInput>, DealUncheckedUpdateWithoutCommunicationsInput>
  }

  export type ContactUpdateOneWithoutCommunicationsNestedInput = {
    create?: XOR<ContactCreateWithoutCommunicationsInput, ContactUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCommunicationsInput
    upsert?: ContactUpsertWithoutCommunicationsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCommunicationsInput, ContactUpdateWithoutCommunicationsInput>, ContactUncheckedUpdateWithoutCommunicationsInput>
  }

  export type InvestorCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutInvestorsInput = {
    create?: XOR<UserCreateWithoutInvestorsInput, UserUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorsInput
    connect?: UserWhereUniqueInput
  }

  export type InvestorEntityCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorEntityCreateWithoutInvestorInput, InvestorEntityUncheckedCreateWithoutInvestorInput> | InvestorEntityCreateWithoutInvestorInput[] | InvestorEntityUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorEntityCreateOrConnectWithoutInvestorInput | InvestorEntityCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorEntityCreateManyInvestorInputEnvelope
    connect?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
  }

  export type InvestorGroupMemberCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutInvestorInput, InvestorGroupMemberUncheckedCreateWithoutInvestorInput> | InvestorGroupMemberCreateWithoutInvestorInput[] | InvestorGroupMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutInvestorInput | InvestorGroupMemberCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorGroupMemberCreateManyInvestorInputEnvelope
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
  }

  export type InvestorEntityUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorEntityCreateWithoutInvestorInput, InvestorEntityUncheckedCreateWithoutInvestorInput> | InvestorEntityCreateWithoutInvestorInput[] | InvestorEntityUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorEntityCreateOrConnectWithoutInvestorInput | InvestorEntityCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorEntityCreateManyInvestorInputEnvelope
    connect?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
  }

  export type InvestorGroupMemberUncheckedCreateNestedManyWithoutInvestorInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutInvestorInput, InvestorGroupMemberUncheckedCreateWithoutInvestorInput> | InvestorGroupMemberCreateWithoutInvestorInput[] | InvestorGroupMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutInvestorInput | InvestorGroupMemberCreateOrConnectWithoutInvestorInput[]
    createMany?: InvestorGroupMemberCreateManyInvestorInputEnvelope
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
  }

  export type InvestorUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutInvestorsNestedInput = {
    create?: XOR<UserCreateWithoutInvestorsInput, UserUncheckedCreateWithoutInvestorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvestorsInput
    upsert?: UserUpsertWithoutInvestorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvestorsInput, UserUpdateWithoutInvestorsInput>, UserUncheckedUpdateWithoutInvestorsInput>
  }

  export type InvestorEntityUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorEntityCreateWithoutInvestorInput, InvestorEntityUncheckedCreateWithoutInvestorInput> | InvestorEntityCreateWithoutInvestorInput[] | InvestorEntityUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorEntityCreateOrConnectWithoutInvestorInput | InvestorEntityCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorEntityUpsertWithWhereUniqueWithoutInvestorInput | InvestorEntityUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorEntityCreateManyInvestorInputEnvelope
    set?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    disconnect?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    delete?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    connect?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    update?: InvestorEntityUpdateWithWhereUniqueWithoutInvestorInput | InvestorEntityUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorEntityUpdateManyWithWhereWithoutInvestorInput | InvestorEntityUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorEntityScalarWhereInput | InvestorEntityScalarWhereInput[]
  }

  export type InvestorGroupMemberUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutInvestorInput, InvestorGroupMemberUncheckedCreateWithoutInvestorInput> | InvestorGroupMemberCreateWithoutInvestorInput[] | InvestorGroupMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutInvestorInput | InvestorGroupMemberCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorGroupMemberUpsertWithWhereUniqueWithoutInvestorInput | InvestorGroupMemberUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorGroupMemberCreateManyInvestorInputEnvelope
    set?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    disconnect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    delete?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    update?: InvestorGroupMemberUpdateWithWhereUniqueWithoutInvestorInput | InvestorGroupMemberUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorGroupMemberUpdateManyWithWhereWithoutInvestorInput | InvestorGroupMemberUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorGroupMemberScalarWhereInput | InvestorGroupMemberScalarWhereInput[]
  }

  export type InvestorEntityUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorEntityCreateWithoutInvestorInput, InvestorEntityUncheckedCreateWithoutInvestorInput> | InvestorEntityCreateWithoutInvestorInput[] | InvestorEntityUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorEntityCreateOrConnectWithoutInvestorInput | InvestorEntityCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorEntityUpsertWithWhereUniqueWithoutInvestorInput | InvestorEntityUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorEntityCreateManyInvestorInputEnvelope
    set?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    disconnect?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    delete?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    connect?: InvestorEntityWhereUniqueInput | InvestorEntityWhereUniqueInput[]
    update?: InvestorEntityUpdateWithWhereUniqueWithoutInvestorInput | InvestorEntityUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorEntityUpdateManyWithWhereWithoutInvestorInput | InvestorEntityUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorEntityScalarWhereInput | InvestorEntityScalarWhereInput[]
  }

  export type InvestorGroupMemberUncheckedUpdateManyWithoutInvestorNestedInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutInvestorInput, InvestorGroupMemberUncheckedCreateWithoutInvestorInput> | InvestorGroupMemberCreateWithoutInvestorInput[] | InvestorGroupMemberUncheckedCreateWithoutInvestorInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutInvestorInput | InvestorGroupMemberCreateOrConnectWithoutInvestorInput[]
    upsert?: InvestorGroupMemberUpsertWithWhereUniqueWithoutInvestorInput | InvestorGroupMemberUpsertWithWhereUniqueWithoutInvestorInput[]
    createMany?: InvestorGroupMemberCreateManyInvestorInputEnvelope
    set?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    disconnect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    delete?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    update?: InvestorGroupMemberUpdateWithWhereUniqueWithoutInvestorInput | InvestorGroupMemberUpdateWithWhereUniqueWithoutInvestorInput[]
    updateMany?: InvestorGroupMemberUpdateManyWithWhereWithoutInvestorInput | InvestorGroupMemberUpdateManyWithWhereWithoutInvestorInput[]
    deleteMany?: InvestorGroupMemberScalarWhereInput | InvestorGroupMemberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFundsInput = {
    create?: XOR<UserCreateWithoutFundsInput, UserUncheckedCreateWithoutFundsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFundsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutFundsNestedInput = {
    create?: XOR<UserCreateWithoutFundsInput, UserUncheckedCreateWithoutFundsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFundsInput
    upsert?: UserUpsertWithoutFundsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFundsInput, UserUpdateWithoutFundsInput>, UserUncheckedUpdateWithoutFundsInput>
  }

  export type InvestorCreateNestedOneWithoutEntitiesInput = {
    create?: XOR<InvestorCreateWithoutEntitiesInput, InvestorUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutEntitiesInput
    connect?: InvestorWhereUniqueInput
  }

  export type InvestorUpdateOneRequiredWithoutEntitiesNestedInput = {
    create?: XOR<InvestorCreateWithoutEntitiesInput, InvestorUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutEntitiesInput
    upsert?: InvestorUpsertWithoutEntitiesInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutEntitiesInput, InvestorUpdateWithoutEntitiesInput>, InvestorUncheckedUpdateWithoutEntitiesInput>
  }

  export type ReportCreaterecipientsInput = {
    set: string[]
  }

  export type ReportUpdaterecipientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeamsMessageCreatementionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTeamsMessagesInput = {
    create?: XOR<UserCreateWithoutTeamsMessagesInput, UserUncheckedCreateWithoutTeamsMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutTeamsMessagesInput = {
    create?: XOR<DealCreateWithoutTeamsMessagesInput, DealUncheckedCreateWithoutTeamsMessagesInput>
    connectOrCreate?: DealCreateOrConnectWithoutTeamsMessagesInput
    connect?: DealWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutTeamsMessagesInput = {
    create?: XOR<ContactCreateWithoutTeamsMessagesInput, ContactUncheckedCreateWithoutTeamsMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTeamsMessagesInput
    connect?: ContactWhereUniqueInput
  }

  export type TeamsMessageUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutTeamsMessagesNestedInput = {
    create?: XOR<UserCreateWithoutTeamsMessagesInput, UserUncheckedCreateWithoutTeamsMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsMessagesInput
    upsert?: UserUpsertWithoutTeamsMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsMessagesInput, UserUpdateWithoutTeamsMessagesInput>, UserUncheckedUpdateWithoutTeamsMessagesInput>
  }

  export type DealUpdateOneWithoutTeamsMessagesNestedInput = {
    create?: XOR<DealCreateWithoutTeamsMessagesInput, DealUncheckedCreateWithoutTeamsMessagesInput>
    connectOrCreate?: DealCreateOrConnectWithoutTeamsMessagesInput
    upsert?: DealUpsertWithoutTeamsMessagesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutTeamsMessagesInput, DealUpdateWithoutTeamsMessagesInput>, DealUncheckedUpdateWithoutTeamsMessagesInput>
  }

  export type ContactUpdateOneWithoutTeamsMessagesNestedInput = {
    create?: XOR<ContactCreateWithoutTeamsMessagesInput, ContactUncheckedCreateWithoutTeamsMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTeamsMessagesInput
    upsert?: ContactUpsertWithoutTeamsMessagesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTeamsMessagesInput, ContactUpdateWithoutTeamsMessagesInput>, ContactUncheckedUpdateWithoutTeamsMessagesInput>
  }

  export type UserCreateNestedOneWithoutTeamsChannelsInput = {
    create?: XOR<UserCreateWithoutTeamsChannelsInput, UserUncheckedCreateWithoutTeamsChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsChannelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeamsChannelsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsChannelsInput, UserUncheckedCreateWithoutTeamsChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsChannelsInput
    upsert?: UserUpsertWithoutTeamsChannelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsChannelsInput, UserUpdateWithoutTeamsChannelsInput>, UserUncheckedUpdateWithoutTeamsChannelsInput>
  }

  export type SlackMessageCreatementionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSlackMessagesInput = {
    create?: XOR<UserCreateWithoutSlackMessagesInput, UserUncheckedCreateWithoutSlackMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSlackMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutSlackMessagesInput = {
    create?: XOR<DealCreateWithoutSlackMessagesInput, DealUncheckedCreateWithoutSlackMessagesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSlackMessagesInput
    connect?: DealWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutSlackMessagesInput = {
    create?: XOR<ContactCreateWithoutSlackMessagesInput, ContactUncheckedCreateWithoutSlackMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutSlackMessagesInput
    connect?: ContactWhereUniqueInput
  }

  export type SlackMessageUpdatementionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSlackMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSlackMessagesInput, UserUncheckedCreateWithoutSlackMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSlackMessagesInput
    upsert?: UserUpsertWithoutSlackMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSlackMessagesInput, UserUpdateWithoutSlackMessagesInput>, UserUncheckedUpdateWithoutSlackMessagesInput>
  }

  export type DealUpdateOneWithoutSlackMessagesNestedInput = {
    create?: XOR<DealCreateWithoutSlackMessagesInput, DealUncheckedCreateWithoutSlackMessagesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSlackMessagesInput
    upsert?: DealUpsertWithoutSlackMessagesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutSlackMessagesInput, DealUpdateWithoutSlackMessagesInput>, DealUncheckedUpdateWithoutSlackMessagesInput>
  }

  export type ContactUpdateOneWithoutSlackMessagesNestedInput = {
    create?: XOR<ContactCreateWithoutSlackMessagesInput, ContactUncheckedCreateWithoutSlackMessagesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutSlackMessagesInput
    upsert?: ContactUpsertWithoutSlackMessagesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutSlackMessagesInput, ContactUpdateWithoutSlackMessagesInput>, ContactUncheckedUpdateWithoutSlackMessagesInput>
  }

  export type UserCreateNestedOneWithoutSlackChannelsInput = {
    create?: XOR<UserCreateWithoutSlackChannelsInput, UserUncheckedCreateWithoutSlackChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSlackChannelsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSlackChannelsNestedInput = {
    create?: XOR<UserCreateWithoutSlackChannelsInput, UserUncheckedCreateWithoutSlackChannelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSlackChannelsInput
    upsert?: UserUpsertWithoutSlackChannelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSlackChannelsInput, UserUpdateWithoutSlackChannelsInput>, UserUncheckedUpdateWithoutSlackChannelsInput>
  }

  export type UserCreateNestedOneWithoutZoomMeetingsInput = {
    create?: XOR<UserCreateWithoutZoomMeetingsInput, UserUncheckedCreateWithoutZoomMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutZoomMeetingsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutZoomMeetingsInput = {
    create?: XOR<DealCreateWithoutZoomMeetingsInput, DealUncheckedCreateWithoutZoomMeetingsInput>
    connectOrCreate?: DealCreateOrConnectWithoutZoomMeetingsInput
    connect?: DealWhereUniqueInput
  }

  export type ZoomParticipantCreateNestedManyWithoutMeetingInput = {
    create?: XOR<ZoomParticipantCreateWithoutMeetingInput, ZoomParticipantUncheckedCreateWithoutMeetingInput> | ZoomParticipantCreateWithoutMeetingInput[] | ZoomParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutMeetingInput | ZoomParticipantCreateOrConnectWithoutMeetingInput[]
    createMany?: ZoomParticipantCreateManyMeetingInputEnvelope
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
  }

  export type ZoomParticipantUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<ZoomParticipantCreateWithoutMeetingInput, ZoomParticipantUncheckedCreateWithoutMeetingInput> | ZoomParticipantCreateWithoutMeetingInput[] | ZoomParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutMeetingInput | ZoomParticipantCreateOrConnectWithoutMeetingInput[]
    createMany?: ZoomParticipantCreateManyMeetingInputEnvelope
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutZoomMeetingsNestedInput = {
    create?: XOR<UserCreateWithoutZoomMeetingsInput, UserUncheckedCreateWithoutZoomMeetingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutZoomMeetingsInput
    upsert?: UserUpsertWithoutZoomMeetingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZoomMeetingsInput, UserUpdateWithoutZoomMeetingsInput>, UserUncheckedUpdateWithoutZoomMeetingsInput>
  }

  export type DealUpdateOneWithoutZoomMeetingsNestedInput = {
    create?: XOR<DealCreateWithoutZoomMeetingsInput, DealUncheckedCreateWithoutZoomMeetingsInput>
    connectOrCreate?: DealCreateOrConnectWithoutZoomMeetingsInput
    upsert?: DealUpsertWithoutZoomMeetingsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutZoomMeetingsInput, DealUpdateWithoutZoomMeetingsInput>, DealUncheckedUpdateWithoutZoomMeetingsInput>
  }

  export type ZoomParticipantUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<ZoomParticipantCreateWithoutMeetingInput, ZoomParticipantUncheckedCreateWithoutMeetingInput> | ZoomParticipantCreateWithoutMeetingInput[] | ZoomParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutMeetingInput | ZoomParticipantCreateOrConnectWithoutMeetingInput[]
    upsert?: ZoomParticipantUpsertWithWhereUniqueWithoutMeetingInput | ZoomParticipantUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: ZoomParticipantCreateManyMeetingInputEnvelope
    set?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    disconnect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    delete?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    update?: ZoomParticipantUpdateWithWhereUniqueWithoutMeetingInput | ZoomParticipantUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: ZoomParticipantUpdateManyWithWhereWithoutMeetingInput | ZoomParticipantUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: ZoomParticipantScalarWhereInput | ZoomParticipantScalarWhereInput[]
  }

  export type ZoomParticipantUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<ZoomParticipantCreateWithoutMeetingInput, ZoomParticipantUncheckedCreateWithoutMeetingInput> | ZoomParticipantCreateWithoutMeetingInput[] | ZoomParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ZoomParticipantCreateOrConnectWithoutMeetingInput | ZoomParticipantCreateOrConnectWithoutMeetingInput[]
    upsert?: ZoomParticipantUpsertWithWhereUniqueWithoutMeetingInput | ZoomParticipantUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: ZoomParticipantCreateManyMeetingInputEnvelope
    set?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    disconnect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    delete?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    connect?: ZoomParticipantWhereUniqueInput | ZoomParticipantWhereUniqueInput[]
    update?: ZoomParticipantUpdateWithWhereUniqueWithoutMeetingInput | ZoomParticipantUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: ZoomParticipantUpdateManyWithWhereWithoutMeetingInput | ZoomParticipantUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: ZoomParticipantScalarWhereInput | ZoomParticipantScalarWhereInput[]
  }

  export type ZoomMeetingCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ZoomMeetingCreateWithoutParticipantsInput, ZoomMeetingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutParticipantsInput
    connect?: ZoomMeetingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutZoomParticipantsInput = {
    create?: XOR<UserCreateWithoutZoomParticipantsInput, UserUncheckedCreateWithoutZoomParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutZoomParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type ZoomMeetingUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ZoomMeetingCreateWithoutParticipantsInput, ZoomMeetingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ZoomMeetingCreateOrConnectWithoutParticipantsInput
    upsert?: ZoomMeetingUpsertWithoutParticipantsInput
    connect?: ZoomMeetingWhereUniqueInput
    update?: XOR<XOR<ZoomMeetingUpdateToOneWithWhereWithoutParticipantsInput, ZoomMeetingUpdateWithoutParticipantsInput>, ZoomMeetingUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneWithoutZoomParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutZoomParticipantsInput, UserUncheckedCreateWithoutZoomParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutZoomParticipantsInput
    upsert?: UserUpsertWithoutZoomParticipantsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutZoomParticipantsInput, UserUpdateWithoutZoomParticipantsInput>, UserUncheckedUpdateWithoutZoomParticipantsInput>
  }

  export type UserCreateNestedOneWithoutSalesforceAccountsInput = {
    create?: XOR<UserCreateWithoutSalesforceAccountsInput, UserUncheckedCreateWithoutSalesforceAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesforceAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutSalesforceAccountsInput = {
    create?: XOR<DealCreateWithoutSalesforceAccountsInput, DealUncheckedCreateWithoutSalesforceAccountsInput>
    connectOrCreate?: DealCreateOrConnectWithoutSalesforceAccountsInput
    connect?: DealWhereUniqueInput
  }

  export type SalesforceContactCreateNestedManyWithoutAccountInput = {
    create?: XOR<SalesforceContactCreateWithoutAccountInput, SalesforceContactUncheckedCreateWithoutAccountInput> | SalesforceContactCreateWithoutAccountInput[] | SalesforceContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutAccountInput | SalesforceContactCreateOrConnectWithoutAccountInput[]
    createMany?: SalesforceContactCreateManyAccountInputEnvelope
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
  }

  export type SalesforceOpportunityCreateNestedManyWithoutAccountInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutAccountInput, SalesforceOpportunityUncheckedCreateWithoutAccountInput> | SalesforceOpportunityCreateWithoutAccountInput[] | SalesforceOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutAccountInput | SalesforceOpportunityCreateOrConnectWithoutAccountInput[]
    createMany?: SalesforceOpportunityCreateManyAccountInputEnvelope
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
  }

  export type SalesforceContactUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SalesforceContactCreateWithoutAccountInput, SalesforceContactUncheckedCreateWithoutAccountInput> | SalesforceContactCreateWithoutAccountInput[] | SalesforceContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutAccountInput | SalesforceContactCreateOrConnectWithoutAccountInput[]
    createMany?: SalesforceContactCreateManyAccountInputEnvelope
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
  }

  export type SalesforceOpportunityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutAccountInput, SalesforceOpportunityUncheckedCreateWithoutAccountInput> | SalesforceOpportunityCreateWithoutAccountInput[] | SalesforceOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutAccountInput | SalesforceOpportunityCreateOrConnectWithoutAccountInput[]
    createMany?: SalesforceOpportunityCreateManyAccountInputEnvelope
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSalesforceAccountsNestedInput = {
    create?: XOR<UserCreateWithoutSalesforceAccountsInput, UserUncheckedCreateWithoutSalesforceAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesforceAccountsInput
    upsert?: UserUpsertWithoutSalesforceAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesforceAccountsInput, UserUpdateWithoutSalesforceAccountsInput>, UserUncheckedUpdateWithoutSalesforceAccountsInput>
  }

  export type DealUpdateOneWithoutSalesforceAccountsNestedInput = {
    create?: XOR<DealCreateWithoutSalesforceAccountsInput, DealUncheckedCreateWithoutSalesforceAccountsInput>
    connectOrCreate?: DealCreateOrConnectWithoutSalesforceAccountsInput
    upsert?: DealUpsertWithoutSalesforceAccountsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutSalesforceAccountsInput, DealUpdateWithoutSalesforceAccountsInput>, DealUncheckedUpdateWithoutSalesforceAccountsInput>
  }

  export type SalesforceContactUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SalesforceContactCreateWithoutAccountInput, SalesforceContactUncheckedCreateWithoutAccountInput> | SalesforceContactCreateWithoutAccountInput[] | SalesforceContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutAccountInput | SalesforceContactCreateOrConnectWithoutAccountInput[]
    upsert?: SalesforceContactUpsertWithWhereUniqueWithoutAccountInput | SalesforceContactUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SalesforceContactCreateManyAccountInputEnvelope
    set?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    disconnect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    delete?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    update?: SalesforceContactUpdateWithWhereUniqueWithoutAccountInput | SalesforceContactUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SalesforceContactUpdateManyWithWhereWithoutAccountInput | SalesforceContactUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SalesforceContactScalarWhereInput | SalesforceContactScalarWhereInput[]
  }

  export type SalesforceOpportunityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutAccountInput, SalesforceOpportunityUncheckedCreateWithoutAccountInput> | SalesforceOpportunityCreateWithoutAccountInput[] | SalesforceOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutAccountInput | SalesforceOpportunityCreateOrConnectWithoutAccountInput[]
    upsert?: SalesforceOpportunityUpsertWithWhereUniqueWithoutAccountInput | SalesforceOpportunityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SalesforceOpportunityCreateManyAccountInputEnvelope
    set?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    disconnect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    delete?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    update?: SalesforceOpportunityUpdateWithWhereUniqueWithoutAccountInput | SalesforceOpportunityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SalesforceOpportunityUpdateManyWithWhereWithoutAccountInput | SalesforceOpportunityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
  }

  export type SalesforceContactUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SalesforceContactCreateWithoutAccountInput, SalesforceContactUncheckedCreateWithoutAccountInput> | SalesforceContactCreateWithoutAccountInput[] | SalesforceContactUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceContactCreateOrConnectWithoutAccountInput | SalesforceContactCreateOrConnectWithoutAccountInput[]
    upsert?: SalesforceContactUpsertWithWhereUniqueWithoutAccountInput | SalesforceContactUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SalesforceContactCreateManyAccountInputEnvelope
    set?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    disconnect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    delete?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    connect?: SalesforceContactWhereUniqueInput | SalesforceContactWhereUniqueInput[]
    update?: SalesforceContactUpdateWithWhereUniqueWithoutAccountInput | SalesforceContactUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SalesforceContactUpdateManyWithWhereWithoutAccountInput | SalesforceContactUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SalesforceContactScalarWhereInput | SalesforceContactScalarWhereInput[]
  }

  export type SalesforceOpportunityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SalesforceOpportunityCreateWithoutAccountInput, SalesforceOpportunityUncheckedCreateWithoutAccountInput> | SalesforceOpportunityCreateWithoutAccountInput[] | SalesforceOpportunityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SalesforceOpportunityCreateOrConnectWithoutAccountInput | SalesforceOpportunityCreateOrConnectWithoutAccountInput[]
    upsert?: SalesforceOpportunityUpsertWithWhereUniqueWithoutAccountInput | SalesforceOpportunityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SalesforceOpportunityCreateManyAccountInputEnvelope
    set?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    disconnect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    delete?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    connect?: SalesforceOpportunityWhereUniqueInput | SalesforceOpportunityWhereUniqueInput[]
    update?: SalesforceOpportunityUpdateWithWhereUniqueWithoutAccountInput | SalesforceOpportunityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SalesforceOpportunityUpdateManyWithWhereWithoutAccountInput | SalesforceOpportunityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSalesforceContactsInput = {
    create?: XOR<UserCreateWithoutSalesforceContactsInput, UserUncheckedCreateWithoutSalesforceContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesforceContactsInput
    connect?: UserWhereUniqueInput
  }

  export type SalesforceAccountCreateNestedOneWithoutContactsInput = {
    create?: XOR<SalesforceAccountCreateWithoutContactsInput, SalesforceAccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutContactsInput
    connect?: SalesforceAccountWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalesforceContactsNestedInput = {
    create?: XOR<UserCreateWithoutSalesforceContactsInput, UserUncheckedCreateWithoutSalesforceContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesforceContactsInput
    upsert?: UserUpsertWithoutSalesforceContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesforceContactsInput, UserUpdateWithoutSalesforceContactsInput>, UserUncheckedUpdateWithoutSalesforceContactsInput>
  }

  export type SalesforceAccountUpdateOneWithoutContactsNestedInput = {
    create?: XOR<SalesforceAccountCreateWithoutContactsInput, SalesforceAccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutContactsInput
    upsert?: SalesforceAccountUpsertWithoutContactsInput
    disconnect?: SalesforceAccountWhereInput | boolean
    delete?: SalesforceAccountWhereInput | boolean
    connect?: SalesforceAccountWhereUniqueInput
    update?: XOR<XOR<SalesforceAccountUpdateToOneWithWhereWithoutContactsInput, SalesforceAccountUpdateWithoutContactsInput>, SalesforceAccountUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutSalesforceOpportunitiesInput = {
    create?: XOR<UserCreateWithoutSalesforceOpportunitiesInput, UserUncheckedCreateWithoutSalesforceOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesforceOpportunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutSalesforceOpportunitiesInput = {
    create?: XOR<DealCreateWithoutSalesforceOpportunitiesInput, DealUncheckedCreateWithoutSalesforceOpportunitiesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSalesforceOpportunitiesInput
    connect?: DealWhereUniqueInput
  }

  export type SalesforceAccountCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<SalesforceAccountCreateWithoutOpportunitiesInput, SalesforceAccountUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutOpportunitiesInput
    connect?: SalesforceAccountWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalesforceOpportunitiesNestedInput = {
    create?: XOR<UserCreateWithoutSalesforceOpportunitiesInput, UserUncheckedCreateWithoutSalesforceOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesforceOpportunitiesInput
    upsert?: UserUpsertWithoutSalesforceOpportunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesforceOpportunitiesInput, UserUpdateWithoutSalesforceOpportunitiesInput>, UserUncheckedUpdateWithoutSalesforceOpportunitiesInput>
  }

  export type DealUpdateOneWithoutSalesforceOpportunitiesNestedInput = {
    create?: XOR<DealCreateWithoutSalesforceOpportunitiesInput, DealUncheckedCreateWithoutSalesforceOpportunitiesInput>
    connectOrCreate?: DealCreateOrConnectWithoutSalesforceOpportunitiesInput
    upsert?: DealUpsertWithoutSalesforceOpportunitiesInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutSalesforceOpportunitiesInput, DealUpdateWithoutSalesforceOpportunitiesInput>, DealUncheckedUpdateWithoutSalesforceOpportunitiesInput>
  }

  export type SalesforceAccountUpdateOneWithoutOpportunitiesNestedInput = {
    create?: XOR<SalesforceAccountCreateWithoutOpportunitiesInput, SalesforceAccountUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: SalesforceAccountCreateOrConnectWithoutOpportunitiesInput
    upsert?: SalesforceAccountUpsertWithoutOpportunitiesInput
    disconnect?: SalesforceAccountWhereInput | boolean
    delete?: SalesforceAccountWhereInput | boolean
    connect?: SalesforceAccountWhereUniqueInput
    update?: XOR<XOR<SalesforceAccountUpdateToOneWithWhereWithoutOpportunitiesInput, SalesforceAccountUpdateWithoutOpportunitiesInput>, SalesforceAccountUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type UserCreateNestedOneWithoutLpGroupsInput = {
    create?: XOR<UserCreateWithoutLpGroupsInput, UserUncheckedCreateWithoutLpGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLpGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type InvestorGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutGroupInput, InvestorGroupMemberUncheckedCreateWithoutGroupInput> | InvestorGroupMemberCreateWithoutGroupInput[] | InvestorGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutGroupInput | InvestorGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: InvestorGroupMemberCreateManyGroupInputEnvelope
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
  }

  export type InvestorGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutGroupInput, InvestorGroupMemberUncheckedCreateWithoutGroupInput> | InvestorGroupMemberCreateWithoutGroupInput[] | InvestorGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutGroupInput | InvestorGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: InvestorGroupMemberCreateManyGroupInputEnvelope
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLpGroupsNestedInput = {
    create?: XOR<UserCreateWithoutLpGroupsInput, UserUncheckedCreateWithoutLpGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLpGroupsInput
    upsert?: UserUpsertWithoutLpGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLpGroupsInput, UserUpdateWithoutLpGroupsInput>, UserUncheckedUpdateWithoutLpGroupsInput>
  }

  export type InvestorGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutGroupInput, InvestorGroupMemberUncheckedCreateWithoutGroupInput> | InvestorGroupMemberCreateWithoutGroupInput[] | InvestorGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutGroupInput | InvestorGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: InvestorGroupMemberUpsertWithWhereUniqueWithoutGroupInput | InvestorGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: InvestorGroupMemberCreateManyGroupInputEnvelope
    set?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    disconnect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    delete?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    update?: InvestorGroupMemberUpdateWithWhereUniqueWithoutGroupInput | InvestorGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: InvestorGroupMemberUpdateManyWithWhereWithoutGroupInput | InvestorGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: InvestorGroupMemberScalarWhereInput | InvestorGroupMemberScalarWhereInput[]
  }

  export type InvestorGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<InvestorGroupMemberCreateWithoutGroupInput, InvestorGroupMemberUncheckedCreateWithoutGroupInput> | InvestorGroupMemberCreateWithoutGroupInput[] | InvestorGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: InvestorGroupMemberCreateOrConnectWithoutGroupInput | InvestorGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: InvestorGroupMemberUpsertWithWhereUniqueWithoutGroupInput | InvestorGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: InvestorGroupMemberCreateManyGroupInputEnvelope
    set?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    disconnect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    delete?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    connect?: InvestorGroupMemberWhereUniqueInput | InvestorGroupMemberWhereUniqueInput[]
    update?: InvestorGroupMemberUpdateWithWhereUniqueWithoutGroupInput | InvestorGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: InvestorGroupMemberUpdateManyWithWhereWithoutGroupInput | InvestorGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: InvestorGroupMemberScalarWhereInput | InvestorGroupMemberScalarWhereInput[]
  }

  export type InvestorCreateNestedOneWithoutGroupMembershipsInput = {
    create?: XOR<InvestorCreateWithoutGroupMembershipsInput, InvestorUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutGroupMembershipsInput
    connect?: InvestorWhereUniqueInput
  }

  export type LPGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<LPGroupCreateWithoutMembersInput, LPGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: LPGroupCreateOrConnectWithoutMembersInput
    connect?: LPGroupWhereUniqueInput
  }

  export type InvestorUpdateOneRequiredWithoutGroupMembershipsNestedInput = {
    create?: XOR<InvestorCreateWithoutGroupMembershipsInput, InvestorUncheckedCreateWithoutGroupMembershipsInput>
    connectOrCreate?: InvestorCreateOrConnectWithoutGroupMembershipsInput
    upsert?: InvestorUpsertWithoutGroupMembershipsInput
    connect?: InvestorWhereUniqueInput
    update?: XOR<XOR<InvestorUpdateToOneWithWhereWithoutGroupMembershipsInput, InvestorUpdateWithoutGroupMembershipsInput>, InvestorUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type LPGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<LPGroupCreateWithoutMembersInput, LPGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: LPGroupCreateOrConnectWithoutMembersInput
    upsert?: LPGroupUpsertWithoutMembersInput
    connect?: LPGroupWhereUniqueInput
    update?: XOR<XOR<LPGroupUpdateToOneWithWhereWithoutMembersInput, LPGroupUpdateWithoutMembersInput>, LPGroupUncheckedUpdateWithoutMembersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    title?: string | null
    bio?: string | null
    joinDate?: Date | string
    timezone?: string
    language?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    title?: string | null
    bio?: string | null
    joinDate?: Date | string
    timezone?: string
    language?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCreateWithoutUserInput = {
    id?: string
    provider: string
    type: string
    isActive?: boolean
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: IntegrationCreatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    syncStatus?: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    type: string
    isActive?: boolean
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: IntegrationCreatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    syncStatus?: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCreateManyUserInputEnvelope = {
    data: IntegrationCreateManyUserInput | IntegrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutUserInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutUserInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutUserInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutUserInput, DealUncheckedCreateWithoutUserInput>
  }

  export type DealCreateManyUserInputEnvelope = {
    data: DealCreateManyUserInput | DealCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUserInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
    communications?: CommunicationCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutUserInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactCreateManyUserInputEnvelope = {
    data: ContactCreateManyUserInput | ContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutUserInput = {
    id?: string
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutCommunicationsInput
    contact?: ContactCreateNestedOneWithoutCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateOrConnectWithoutUserInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutUserInput, CommunicationUncheckedCreateWithoutUserInput>
  }

  export type CommunicationCreateManyUserInputEnvelope = {
    data: CommunicationCreateManyUserInput | CommunicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferenceCreateWithoutUserInput = {
    id?: string
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    emailNotify?: boolean
    pushNotify?: boolean
    smsNotify?: boolean
    calendarNotify?: boolean
    dealNotify?: boolean
    autoSave?: boolean
    darkMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceCreateOrConnectWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type TeamsMessageCreateWithoutUserInput = {
    id?: string
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
    deal?: DealCreateNestedOneWithoutTeamsMessagesInput
    contact?: ContactCreateNestedOneWithoutTeamsMessagesInput
  }

  export type TeamsMessageUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type TeamsMessageCreateOrConnectWithoutUserInput = {
    where: TeamsMessageWhereUniqueInput
    create: XOR<TeamsMessageCreateWithoutUserInput, TeamsMessageUncheckedCreateWithoutUserInput>
  }

  export type TeamsMessageCreateManyUserInputEnvelope = {
    data: TeamsMessageCreateManyUserInput | TeamsMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamsChannelCreateWithoutUserInput = {
    id?: string
    channelId: string
    teamId: string
    name: string
    description?: string | null
    type: string
    webUrl?: string | null
    memberCount?: number | null
    isArchived?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsChannelUncheckedCreateWithoutUserInput = {
    id?: string
    channelId: string
    teamId: string
    name: string
    description?: string | null
    type: string
    webUrl?: string | null
    memberCount?: number | null
    isArchived?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsChannelCreateOrConnectWithoutUserInput = {
    where: TeamsChannelWhereUniqueInput
    create: XOR<TeamsChannelCreateWithoutUserInput, TeamsChannelUncheckedCreateWithoutUserInput>
  }

  export type TeamsChannelCreateManyUserInputEnvelope = {
    data: TeamsChannelCreateManyUserInput | TeamsChannelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SlackMessageCreateWithoutUserInput = {
    id?: string
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutSlackMessagesInput
    contact?: ContactCreateNestedOneWithoutSlackMessagesInput
  }

  export type SlackMessageUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackMessageCreateOrConnectWithoutUserInput = {
    where: SlackMessageWhereUniqueInput
    create: XOR<SlackMessageCreateWithoutUserInput, SlackMessageUncheckedCreateWithoutUserInput>
  }

  export type SlackMessageCreateManyUserInputEnvelope = {
    data: SlackMessageCreateManyUserInput | SlackMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SlackChannelCreateWithoutUserInput = {
    id?: string
    channelId: string
    name: string
    purpose?: string | null
    topic?: string | null
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackChannelUncheckedCreateWithoutUserInput = {
    id?: string
    channelId: string
    name: string
    purpose?: string | null
    topic?: string | null
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackChannelCreateOrConnectWithoutUserInput = {
    where: SlackChannelWhereUniqueInput
    create: XOR<SlackChannelCreateWithoutUserInput, SlackChannelUncheckedCreateWithoutUserInput>
  }

  export type SlackChannelCreateManyUserInputEnvelope = {
    data: SlackChannelCreateManyUserInput | SlackChannelCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ZoomMeetingCreateWithoutUserInput = {
    id?: string
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutZoomMeetingsInput
    participants?: ZoomParticipantCreateNestedManyWithoutMeetingInput
  }

  export type ZoomMeetingUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ZoomParticipantUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type ZoomMeetingCreateOrConnectWithoutUserInput = {
    where: ZoomMeetingWhereUniqueInput
    create: XOR<ZoomMeetingCreateWithoutUserInput, ZoomMeetingUncheckedCreateWithoutUserInput>
  }

  export type ZoomMeetingCreateManyUserInputEnvelope = {
    data: ZoomMeetingCreateManyUserInput | ZoomMeetingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ZoomParticipantCreateWithoutUserInput = {
    id?: string
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: ZoomMeetingCreateNestedOneWithoutParticipantsInput
  }

  export type ZoomParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    meetingId: string
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomParticipantCreateOrConnectWithoutUserInput = {
    where: ZoomParticipantWhereUniqueInput
    create: XOR<ZoomParticipantCreateWithoutUserInput, ZoomParticipantUncheckedCreateWithoutUserInput>
  }

  export type ZoomParticipantCreateManyUserInputEnvelope = {
    data: ZoomParticipantCreateManyUserInput | ZoomParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalesforceAccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutSalesforceAccountsInput
    contacts?: SalesforceContactCreateNestedManyWithoutAccountInput
    opportunities?: SalesforceOpportunityCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: SalesforceContactUncheckedCreateNestedManyWithoutAccountInput
    opportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountCreateOrConnectWithoutUserInput = {
    where: SalesforceAccountWhereUniqueInput
    create: XOR<SalesforceAccountCreateWithoutUserInput, SalesforceAccountUncheckedCreateWithoutUserInput>
  }

  export type SalesforceAccountCreateManyUserInputEnvelope = {
    data: SalesforceAccountCreateManyUserInput | SalesforceAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalesforceContactCreateWithoutUserInput = {
    id?: string
    contactId: string
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: SalesforceAccountCreateNestedOneWithoutContactsInput
  }

  export type SalesforceContactUncheckedCreateWithoutUserInput = {
    id?: string
    contactId: string
    accountId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceContactCreateOrConnectWithoutUserInput = {
    where: SalesforceContactWhereUniqueInput
    create: XOR<SalesforceContactCreateWithoutUserInput, SalesforceContactUncheckedCreateWithoutUserInput>
  }

  export type SalesforceContactCreateManyUserInputEnvelope = {
    data: SalesforceContactCreateManyUserInput | SalesforceContactCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalesforceOpportunityCreateWithoutUserInput = {
    id?: string
    opportunityId: string
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deal?: DealCreateNestedOneWithoutSalesforceOpportunitiesInput
    account?: SalesforceAccountCreateNestedOneWithoutOpportunitiesInput
  }

  export type SalesforceOpportunityUncheckedCreateWithoutUserInput = {
    id?: string
    dealId?: string | null
    opportunityId: string
    accountId?: string | null
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityCreateOrConnectWithoutUserInput = {
    where: SalesforceOpportunityWhereUniqueInput
    create: XOR<SalesforceOpportunityCreateWithoutUserInput, SalesforceOpportunityUncheckedCreateWithoutUserInput>
  }

  export type SalesforceOpportunityCreateManyUserInputEnvelope = {
    data: SalesforceOpportunityCreateManyUserInput | SalesforceOpportunityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FundCreateWithoutUserInput = {
    id?: string
    name: string
    type: string
    strategy?: string | null
    targetSize: number
    minimumCommitment?: number | null
    managementFee?: number | null
    carriedInterest?: number | null
    currency?: string
    vintage?: number | null
    investmentPeriod?: number | null
    fundTerm?: number | null
    geoFocus?: string | null
    sectorFocus?: string | null
    description?: string | null
    status?: string
    raisedAmount?: number
    investorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    type: string
    strategy?: string | null
    targetSize: number
    minimumCommitment?: number | null
    managementFee?: number | null
    carriedInterest?: number | null
    currency?: string
    vintage?: number | null
    investmentPeriod?: number | null
    fundTerm?: number | null
    geoFocus?: string | null
    sectorFocus?: string | null
    description?: string | null
    status?: string
    raisedAmount?: number
    investorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundCreateOrConnectWithoutUserInput = {
    where: FundWhereUniqueInput
    create: XOR<FundCreateWithoutUserInput, FundUncheckedCreateWithoutUserInput>
  }

  export type FundCreateManyUserInputEnvelope = {
    data: FundCreateManyUserInput | FundCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvestorCreateWithoutUserInput = {
    id?: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: InvestorEntityCreateNestedManyWithoutInvestorInput
    groupMemberships?: InvestorGroupMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: InvestorEntityUncheckedCreateNestedManyWithoutInvestorInput
    groupMemberships?: InvestorGroupMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutUserInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
  }

  export type InvestorCreateManyUserInputEnvelope = {
    data: InvestorCreateManyUserInput | InvestorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LPGroupCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: InvestorGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type LPGroupUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: InvestorGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type LPGroupCreateOrConnectWithoutUserInput = {
    where: LPGroupWhereUniqueInput
    create: XOR<LPGroupCreateWithoutUserInput, LPGroupUncheckedCreateWithoutUserInput>
  }

  export type LPGroupCreateManyUserInputEnvelope = {
    data: LPGroupCreateManyUserInput | LPGroupCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutUserInput, IntegrationUncheckedUpdateWithoutUserInput>
    create: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutUserInput, IntegrationUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutUserInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutUserInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    userId?: StringFilter<"Integration"> | string
    provider?: StringFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    isActive?: BoolFilter<"Integration"> | boolean
    accessToken?: StringNullableFilter<"Integration"> | string | null
    refreshToken?: StringNullableFilter<"Integration"> | string | null
    expiresAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    scope?: StringNullableListFilter<"Integration">
    profile?: JsonNullableFilter<"Integration">
    settings?: JsonNullableFilter<"Integration">
    lastSync?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncStatus?: StringFilter<"Integration"> | string
    errorMessage?: StringNullableFilter<"Integration"> | string | null
    metadata?: JsonNullableFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutUserInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutUserInput, DealUncheckedUpdateWithoutUserInput>
    create: XOR<DealCreateWithoutUserInput, DealUncheckedCreateWithoutUserInput>
  }

  export type DealUpdateWithWhereUniqueWithoutUserInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutUserInput, DealUncheckedUpdateWithoutUserInput>
  }

  export type DealUpdateManyWithWhereWithoutUserInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutUserInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    userId?: StringFilter<"Deal"> | string
    company?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    sector?: StringNullableFilter<"Deal"> | string | null
    stage?: StringFilter<"Deal"> | string
    status?: StringFilter<"Deal"> | string
    value?: FloatNullableFilter<"Deal"> | number | null
    probability?: FloatNullableFilter<"Deal"> | number | null
    leadPartner?: StringNullableFilter<"Deal"> | string | null
    team?: StringNullableListFilter<"Deal">
    tags?: StringNullableListFilter<"Deal">
    priority?: StringFilter<"Deal"> | string
    targetClose?: DateTimeNullableFilter<"Deal"> | Date | string | null
    actualClose?: DateTimeNullableFilter<"Deal"> | Date | string | null
    nextStep?: StringNullableFilter<"Deal"> | string | null
    lastActivity?: DateTimeNullableFilter<"Deal"> | Date | string | null
    source?: StringNullableFilter<"Deal"> | string | null
    geography?: StringNullableFilter<"Deal"> | string | null
    dealSize?: StringNullableFilter<"Deal"> | string | null
    metrics?: JsonNullableFilter<"Deal">
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    dealId?: StringNullableFilter<"Activity"> | string | null
    contactId?: StringNullableFilter<"Activity"> | string | null
    type?: StringFilter<"Activity"> | string
    title?: StringFilter<"Activity"> | string
    description?: StringNullableFilter<"Activity"> | string | null
    content?: StringNullableFilter<"Activity"> | string | null
    date?: DateTimeFilter<"Activity"> | Date | string
    duration?: IntNullableFilter<"Activity"> | number | null
    location?: StringNullableFilter<"Activity"> | string | null
    attendees?: StringNullableListFilter<"Activity">
    status?: StringFilter<"Activity"> | string
    priority?: StringFilter<"Activity"> | string
    outcome?: StringNullableFilter<"Activity"> | string | null
    nextSteps?: StringNullableFilter<"Activity"> | string | null
    metadata?: JsonNullableFilter<"Activity">
    externalId?: StringNullableFilter<"Activity"> | string | null
    syncedFrom?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
    create: XOR<ContactCreateWithoutUserInput, ContactUncheckedCreateWithoutUserInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUserInput, ContactUncheckedUpdateWithoutUserInput>
  }

  export type ContactUpdateManyWithWhereWithoutUserInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    dealId?: StringNullableFilter<"Contact"> | string | null
    googleContactId?: StringNullableFilter<"Contact"> | string | null
    name?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    title?: StringNullableFilter<"Contact"> | string | null
    role?: StringNullableFilter<"Contact"> | string | null
    linkedinUrl?: StringNullableFilter<"Contact"> | string | null
    avatar?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    tags?: StringNullableListFilter<"Contact">
    relationshipScore?: FloatNullableFilter<"Contact"> | number | null
    lastContact?: DateTimeNullableFilter<"Contact"> | Date | string | null
    status?: StringFilter<"Contact"> | string
    isKeyContact?: BoolFilter<"Contact"> | boolean
    source?: StringNullableFilter<"Contact"> | string | null
    metadata?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type CommunicationUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutUserInput, CommunicationUncheckedUpdateWithoutUserInput>
    create: XOR<CommunicationCreateWithoutUserInput, CommunicationUncheckedCreateWithoutUserInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutUserInput, CommunicationUncheckedUpdateWithoutUserInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutUserInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutUserInput>
  }

  export type CommunicationScalarWhereInput = {
    AND?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    OR?: CommunicationScalarWhereInput[]
    NOT?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    id?: StringFilter<"Communication"> | string
    userId?: StringFilter<"Communication"> | string
    dealId?: StringNullableFilter<"Communication"> | string | null
    contactId?: StringNullableFilter<"Communication"> | string | null
    type?: StringFilter<"Communication"> | string
    subject?: StringNullableFilter<"Communication"> | string | null
    content?: StringNullableFilter<"Communication"> | string | null
    htmlContent?: StringNullableFilter<"Communication"> | string | null
    fromEmail?: StringNullableFilter<"Communication"> | string | null
    toEmails?: StringNullableListFilter<"Communication">
    ccEmails?: StringNullableListFilter<"Communication">
    bccEmails?: StringNullableListFilter<"Communication">
    threadId?: StringNullableFilter<"Communication"> | string | null
    messageId?: StringNullableFilter<"Communication"> | string | null
    status?: StringFilter<"Communication"> | string
    direction?: StringFilter<"Communication"> | string
    isRead?: BoolFilter<"Communication"> | boolean
    isImportant?: BoolFilter<"Communication"> | boolean
    labels?: StringNullableListFilter<"Communication">
    attachments?: JsonNullableFilter<"Communication">
    metadata?: JsonNullableFilter<"Communication">
    sentAt?: DateTimeNullableFilter<"Communication"> | Date | string | null
    receivedAt?: DateTimeNullableFilter<"Communication"> | Date | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    dealId?: StringNullableFilter<"Document"> | string | null
    name?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    type?: StringFilter<"Document"> | string
    category?: StringNullableFilter<"Document"> | string | null
    size?: IntNullableFilter<"Document"> | number | null
    url?: StringNullableFilter<"Document"> | string | null
    googleDriveId?: StringNullableFilter<"Document"> | string | null
    path?: StringNullableFilter<"Document"> | string | null
    version?: StringFilter<"Document"> | string
    isConfidential?: BoolFilter<"Document"> | boolean
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    tags?: StringNullableListFilter<"Document">
    metadata?: JsonNullableFilter<"Document">
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type UserPreferenceUpsertWithoutUserInput = {
    update: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    where?: UserPreferenceWhereInput
  }

  export type UserPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferenceWhereInput
    data: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    smsNotify?: BoolFieldUpdateOperationsInput | boolean
    calendarNotify?: BoolFieldUpdateOperationsInput | boolean
    dealNotify?: BoolFieldUpdateOperationsInput | boolean
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailNotify?: BoolFieldUpdateOperationsInput | boolean
    pushNotify?: BoolFieldUpdateOperationsInput | boolean
    smsNotify?: BoolFieldUpdateOperationsInput | boolean
    calendarNotify?: BoolFieldUpdateOperationsInput | boolean
    dealNotify?: BoolFieldUpdateOperationsInput | boolean
    autoSave?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamsMessageWhereUniqueInput
    update: XOR<TeamsMessageUpdateWithoutUserInput, TeamsMessageUncheckedUpdateWithoutUserInput>
    create: XOR<TeamsMessageCreateWithoutUserInput, TeamsMessageUncheckedCreateWithoutUserInput>
  }

  export type TeamsMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamsMessageWhereUniqueInput
    data: XOR<TeamsMessageUpdateWithoutUserInput, TeamsMessageUncheckedUpdateWithoutUserInput>
  }

  export type TeamsMessageUpdateManyWithWhereWithoutUserInput = {
    where: TeamsMessageScalarWhereInput
    data: XOR<TeamsMessageUpdateManyMutationInput, TeamsMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamsMessageScalarWhereInput = {
    AND?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
    OR?: TeamsMessageScalarWhereInput[]
    NOT?: TeamsMessageScalarWhereInput | TeamsMessageScalarWhereInput[]
    id?: StringFilter<"TeamsMessage"> | string
    userId?: StringFilter<"TeamsMessage"> | string
    dealId?: StringNullableFilter<"TeamsMessage"> | string | null
    contactId?: StringNullableFilter<"TeamsMessage"> | string | null
    messageId?: StringFilter<"TeamsMessage"> | string
    chatId?: StringNullableFilter<"TeamsMessage"> | string | null
    channelId?: StringNullableFilter<"TeamsMessage"> | string | null
    teamId?: StringNullableFilter<"TeamsMessage"> | string | null
    fromEmail?: StringFilter<"TeamsMessage"> | string
    fromName?: StringFilter<"TeamsMessage"> | string
    content?: StringFilter<"TeamsMessage"> | string
    contentType?: StringFilter<"TeamsMessage"> | string
    importance?: StringFilter<"TeamsMessage"> | string
    messageType?: StringFilter<"TeamsMessage"> | string
    attachments?: JsonNullableFilter<"TeamsMessage">
    mentions?: StringNullableListFilter<"TeamsMessage">
    createdAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    updatedAt?: DateTimeFilter<"TeamsMessage"> | Date | string
    sentAt?: DateTimeFilter<"TeamsMessage"> | Date | string
  }

  export type TeamsChannelUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamsChannelWhereUniqueInput
    update: XOR<TeamsChannelUpdateWithoutUserInput, TeamsChannelUncheckedUpdateWithoutUserInput>
    create: XOR<TeamsChannelCreateWithoutUserInput, TeamsChannelUncheckedCreateWithoutUserInput>
  }

  export type TeamsChannelUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamsChannelWhereUniqueInput
    data: XOR<TeamsChannelUpdateWithoutUserInput, TeamsChannelUncheckedUpdateWithoutUserInput>
  }

  export type TeamsChannelUpdateManyWithWhereWithoutUserInput = {
    where: TeamsChannelScalarWhereInput
    data: XOR<TeamsChannelUpdateManyMutationInput, TeamsChannelUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamsChannelScalarWhereInput = {
    AND?: TeamsChannelScalarWhereInput | TeamsChannelScalarWhereInput[]
    OR?: TeamsChannelScalarWhereInput[]
    NOT?: TeamsChannelScalarWhereInput | TeamsChannelScalarWhereInput[]
    id?: StringFilter<"TeamsChannel"> | string
    userId?: StringFilter<"TeamsChannel"> | string
    channelId?: StringFilter<"TeamsChannel"> | string
    teamId?: StringFilter<"TeamsChannel"> | string
    name?: StringFilter<"TeamsChannel"> | string
    description?: StringNullableFilter<"TeamsChannel"> | string | null
    type?: StringFilter<"TeamsChannel"> | string
    webUrl?: StringNullableFilter<"TeamsChannel"> | string | null
    memberCount?: IntNullableFilter<"TeamsChannel"> | number | null
    isArchived?: BoolFilter<"TeamsChannel"> | boolean
    metadata?: JsonNullableFilter<"TeamsChannel">
    createdAt?: DateTimeFilter<"TeamsChannel"> | Date | string
    updatedAt?: DateTimeFilter<"TeamsChannel"> | Date | string
  }

  export type SlackMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: SlackMessageWhereUniqueInput
    update: XOR<SlackMessageUpdateWithoutUserInput, SlackMessageUncheckedUpdateWithoutUserInput>
    create: XOR<SlackMessageCreateWithoutUserInput, SlackMessageUncheckedCreateWithoutUserInput>
  }

  export type SlackMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: SlackMessageWhereUniqueInput
    data: XOR<SlackMessageUpdateWithoutUserInput, SlackMessageUncheckedUpdateWithoutUserInput>
  }

  export type SlackMessageUpdateManyWithWhereWithoutUserInput = {
    where: SlackMessageScalarWhereInput
    data: XOR<SlackMessageUpdateManyMutationInput, SlackMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type SlackMessageScalarWhereInput = {
    AND?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
    OR?: SlackMessageScalarWhereInput[]
    NOT?: SlackMessageScalarWhereInput | SlackMessageScalarWhereInput[]
    id?: StringFilter<"SlackMessage"> | string
    userId?: StringFilter<"SlackMessage"> | string
    dealId?: StringNullableFilter<"SlackMessage"> | string | null
    contactId?: StringNullableFilter<"SlackMessage"> | string | null
    messageId?: StringFilter<"SlackMessage"> | string
    channelId?: StringFilter<"SlackMessage"> | string
    channelName?: StringNullableFilter<"SlackMessage"> | string | null
    fromUserId?: StringFilter<"SlackMessage"> | string
    fromName?: StringFilter<"SlackMessage"> | string
    text?: StringFilter<"SlackMessage"> | string
    messageType?: StringFilter<"SlackMessage"> | string
    threadTs?: StringNullableFilter<"SlackMessage"> | string | null
    attachments?: JsonNullableFilter<"SlackMessage">
    reactions?: JsonNullableFilter<"SlackMessage">
    mentions?: StringNullableListFilter<"SlackMessage">
    sentAt?: DateTimeFilter<"SlackMessage"> | Date | string
    createdAt?: DateTimeFilter<"SlackMessage"> | Date | string
    updatedAt?: DateTimeFilter<"SlackMessage"> | Date | string
  }

  export type SlackChannelUpsertWithWhereUniqueWithoutUserInput = {
    where: SlackChannelWhereUniqueInput
    update: XOR<SlackChannelUpdateWithoutUserInput, SlackChannelUncheckedUpdateWithoutUserInput>
    create: XOR<SlackChannelCreateWithoutUserInput, SlackChannelUncheckedCreateWithoutUserInput>
  }

  export type SlackChannelUpdateWithWhereUniqueWithoutUserInput = {
    where: SlackChannelWhereUniqueInput
    data: XOR<SlackChannelUpdateWithoutUserInput, SlackChannelUncheckedUpdateWithoutUserInput>
  }

  export type SlackChannelUpdateManyWithWhereWithoutUserInput = {
    where: SlackChannelScalarWhereInput
    data: XOR<SlackChannelUpdateManyMutationInput, SlackChannelUncheckedUpdateManyWithoutUserInput>
  }

  export type SlackChannelScalarWhereInput = {
    AND?: SlackChannelScalarWhereInput | SlackChannelScalarWhereInput[]
    OR?: SlackChannelScalarWhereInput[]
    NOT?: SlackChannelScalarWhereInput | SlackChannelScalarWhereInput[]
    id?: StringFilter<"SlackChannel"> | string
    userId?: StringFilter<"SlackChannel"> | string
    channelId?: StringFilter<"SlackChannel"> | string
    name?: StringFilter<"SlackChannel"> | string
    purpose?: StringNullableFilter<"SlackChannel"> | string | null
    topic?: StringNullableFilter<"SlackChannel"> | string | null
    isPrivate?: BoolFilter<"SlackChannel"> | boolean
    isArchived?: BoolFilter<"SlackChannel"> | boolean
    memberCount?: IntNullableFilter<"SlackChannel"> | number | null
    metadata?: JsonNullableFilter<"SlackChannel">
    createdAt?: DateTimeFilter<"SlackChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SlackChannel"> | Date | string
  }

  export type ZoomMeetingUpsertWithWhereUniqueWithoutUserInput = {
    where: ZoomMeetingWhereUniqueInput
    update: XOR<ZoomMeetingUpdateWithoutUserInput, ZoomMeetingUncheckedUpdateWithoutUserInput>
    create: XOR<ZoomMeetingCreateWithoutUserInput, ZoomMeetingUncheckedCreateWithoutUserInput>
  }

  export type ZoomMeetingUpdateWithWhereUniqueWithoutUserInput = {
    where: ZoomMeetingWhereUniqueInput
    data: XOR<ZoomMeetingUpdateWithoutUserInput, ZoomMeetingUncheckedUpdateWithoutUserInput>
  }

  export type ZoomMeetingUpdateManyWithWhereWithoutUserInput = {
    where: ZoomMeetingScalarWhereInput
    data: XOR<ZoomMeetingUpdateManyMutationInput, ZoomMeetingUncheckedUpdateManyWithoutUserInput>
  }

  export type ZoomMeetingScalarWhereInput = {
    AND?: ZoomMeetingScalarWhereInput | ZoomMeetingScalarWhereInput[]
    OR?: ZoomMeetingScalarWhereInput[]
    NOT?: ZoomMeetingScalarWhereInput | ZoomMeetingScalarWhereInput[]
    id?: StringFilter<"ZoomMeeting"> | string
    userId?: StringFilter<"ZoomMeeting"> | string
    dealId?: StringNullableFilter<"ZoomMeeting"> | string | null
    meetingId?: StringFilter<"ZoomMeeting"> | string
    uuid?: StringNullableFilter<"ZoomMeeting"> | string | null
    topic?: StringFilter<"ZoomMeeting"> | string
    agenda?: StringNullableFilter<"ZoomMeeting"> | string | null
    startTime?: DateTimeFilter<"ZoomMeeting"> | Date | string
    duration?: IntFilter<"ZoomMeeting"> | number
    timezone?: StringFilter<"ZoomMeeting"> | string
    status?: StringFilter<"ZoomMeeting"> | string
    meetingType?: StringFilter<"ZoomMeeting"> | string
    joinUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    startUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    password?: StringNullableFilter<"ZoomMeeting"> | string | null
    hostEmail?: StringNullableFilter<"ZoomMeeting"> | string | null
    participantCount?: IntNullableFilter<"ZoomMeeting"> | number | null
    hasRecording?: BoolFilter<"ZoomMeeting"> | boolean
    recordingUrl?: StringNullableFilter<"ZoomMeeting"> | string | null
    metadata?: JsonNullableFilter<"ZoomMeeting">
    createdAt?: DateTimeFilter<"ZoomMeeting"> | Date | string
    updatedAt?: DateTimeFilter<"ZoomMeeting"> | Date | string
  }

  export type ZoomParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ZoomParticipantWhereUniqueInput
    update: XOR<ZoomParticipantUpdateWithoutUserInput, ZoomParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ZoomParticipantCreateWithoutUserInput, ZoomParticipantUncheckedCreateWithoutUserInput>
  }

  export type ZoomParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ZoomParticipantWhereUniqueInput
    data: XOR<ZoomParticipantUpdateWithoutUserInput, ZoomParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ZoomParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ZoomParticipantScalarWhereInput
    data: XOR<ZoomParticipantUpdateManyMutationInput, ZoomParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ZoomParticipantScalarWhereInput = {
    AND?: ZoomParticipantScalarWhereInput | ZoomParticipantScalarWhereInput[]
    OR?: ZoomParticipantScalarWhereInput[]
    NOT?: ZoomParticipantScalarWhereInput | ZoomParticipantScalarWhereInput[]
    id?: StringFilter<"ZoomParticipant"> | string
    meetingId?: StringFilter<"ZoomParticipant"> | string
    userId?: StringNullableFilter<"ZoomParticipant"> | string | null
    zoomUserId?: StringNullableFilter<"ZoomParticipant"> | string | null
    name?: StringFilter<"ZoomParticipant"> | string
    email?: StringNullableFilter<"ZoomParticipant"> | string | null
    joinTime?: DateTimeFilter<"ZoomParticipant"> | Date | string
    leaveTime?: DateTimeNullableFilter<"ZoomParticipant"> | Date | string | null
    duration?: IntNullableFilter<"ZoomParticipant"> | number | null
    status?: StringFilter<"ZoomParticipant"> | string
    metadata?: JsonNullableFilter<"ZoomParticipant">
    createdAt?: DateTimeFilter<"ZoomParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"ZoomParticipant"> | Date | string
  }

  export type SalesforceAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: SalesforceAccountWhereUniqueInput
    update: XOR<SalesforceAccountUpdateWithoutUserInput, SalesforceAccountUncheckedUpdateWithoutUserInput>
    create: XOR<SalesforceAccountCreateWithoutUserInput, SalesforceAccountUncheckedCreateWithoutUserInput>
  }

  export type SalesforceAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: SalesforceAccountWhereUniqueInput
    data: XOR<SalesforceAccountUpdateWithoutUserInput, SalesforceAccountUncheckedUpdateWithoutUserInput>
  }

  export type SalesforceAccountUpdateManyWithWhereWithoutUserInput = {
    where: SalesforceAccountScalarWhereInput
    data: XOR<SalesforceAccountUpdateManyMutationInput, SalesforceAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type SalesforceAccountScalarWhereInput = {
    AND?: SalesforceAccountScalarWhereInput | SalesforceAccountScalarWhereInput[]
    OR?: SalesforceAccountScalarWhereInput[]
    NOT?: SalesforceAccountScalarWhereInput | SalesforceAccountScalarWhereInput[]
    id?: StringFilter<"SalesforceAccount"> | string
    userId?: StringFilter<"SalesforceAccount"> | string
    dealId?: StringNullableFilter<"SalesforceAccount"> | string | null
    accountId?: StringFilter<"SalesforceAccount"> | string
    name?: StringFilter<"SalesforceAccount"> | string
    type?: StringNullableFilter<"SalesforceAccount"> | string | null
    industry?: StringNullableFilter<"SalesforceAccount"> | string | null
    website?: StringNullableFilter<"SalesforceAccount"> | string | null
    phone?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingCity?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingState?: StringNullableFilter<"SalesforceAccount"> | string | null
    billingCountry?: StringNullableFilter<"SalesforceAccount"> | string | null
    description?: StringNullableFilter<"SalesforceAccount"> | string | null
    revenue?: FloatNullableFilter<"SalesforceAccount"> | number | null
    employees?: IntNullableFilter<"SalesforceAccount"> | number | null
    ownerId?: StringNullableFilter<"SalesforceAccount"> | string | null
    metadata?: JsonNullableFilter<"SalesforceAccount">
    lastSync?: DateTimeFilter<"SalesforceAccount"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceAccount"> | Date | string
  }

  export type SalesforceContactUpsertWithWhereUniqueWithoutUserInput = {
    where: SalesforceContactWhereUniqueInput
    update: XOR<SalesforceContactUpdateWithoutUserInput, SalesforceContactUncheckedUpdateWithoutUserInput>
    create: XOR<SalesforceContactCreateWithoutUserInput, SalesforceContactUncheckedCreateWithoutUserInput>
  }

  export type SalesforceContactUpdateWithWhereUniqueWithoutUserInput = {
    where: SalesforceContactWhereUniqueInput
    data: XOR<SalesforceContactUpdateWithoutUserInput, SalesforceContactUncheckedUpdateWithoutUserInput>
  }

  export type SalesforceContactUpdateManyWithWhereWithoutUserInput = {
    where: SalesforceContactScalarWhereInput
    data: XOR<SalesforceContactUpdateManyMutationInput, SalesforceContactUncheckedUpdateManyWithoutUserInput>
  }

  export type SalesforceContactScalarWhereInput = {
    AND?: SalesforceContactScalarWhereInput | SalesforceContactScalarWhereInput[]
    OR?: SalesforceContactScalarWhereInput[]
    NOT?: SalesforceContactScalarWhereInput | SalesforceContactScalarWhereInput[]
    id?: StringFilter<"SalesforceContact"> | string
    userId?: StringFilter<"SalesforceContact"> | string
    contactId?: StringFilter<"SalesforceContact"> | string
    accountId?: StringNullableFilter<"SalesforceContact"> | string | null
    name?: StringFilter<"SalesforceContact"> | string
    email?: StringNullableFilter<"SalesforceContact"> | string | null
    phone?: StringNullableFilter<"SalesforceContact"> | string | null
    title?: StringNullableFilter<"SalesforceContact"> | string | null
    department?: StringNullableFilter<"SalesforceContact"> | string | null
    leadSource?: StringNullableFilter<"SalesforceContact"> | string | null
    description?: StringNullableFilter<"SalesforceContact"> | string | null
    ownerId?: StringNullableFilter<"SalesforceContact"> | string | null
    metadata?: JsonNullableFilter<"SalesforceContact">
    lastSync?: DateTimeFilter<"SalesforceContact"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceContact"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceContact"> | Date | string
  }

  export type SalesforceOpportunityUpsertWithWhereUniqueWithoutUserInput = {
    where: SalesforceOpportunityWhereUniqueInput
    update: XOR<SalesforceOpportunityUpdateWithoutUserInput, SalesforceOpportunityUncheckedUpdateWithoutUserInput>
    create: XOR<SalesforceOpportunityCreateWithoutUserInput, SalesforceOpportunityUncheckedCreateWithoutUserInput>
  }

  export type SalesforceOpportunityUpdateWithWhereUniqueWithoutUserInput = {
    where: SalesforceOpportunityWhereUniqueInput
    data: XOR<SalesforceOpportunityUpdateWithoutUserInput, SalesforceOpportunityUncheckedUpdateWithoutUserInput>
  }

  export type SalesforceOpportunityUpdateManyWithWhereWithoutUserInput = {
    where: SalesforceOpportunityScalarWhereInput
    data: XOR<SalesforceOpportunityUpdateManyMutationInput, SalesforceOpportunityUncheckedUpdateManyWithoutUserInput>
  }

  export type SalesforceOpportunityScalarWhereInput = {
    AND?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
    OR?: SalesforceOpportunityScalarWhereInput[]
    NOT?: SalesforceOpportunityScalarWhereInput | SalesforceOpportunityScalarWhereInput[]
    id?: StringFilter<"SalesforceOpportunity"> | string
    userId?: StringFilter<"SalesforceOpportunity"> | string
    dealId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    opportunityId?: StringFilter<"SalesforceOpportunity"> | string
    accountId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    name?: StringFilter<"SalesforceOpportunity"> | string
    amount?: FloatNullableFilter<"SalesforceOpportunity"> | number | null
    stage?: StringFilter<"SalesforceOpportunity"> | string
    probability?: FloatNullableFilter<"SalesforceOpportunity"> | number | null
    closeDate?: DateTimeNullableFilter<"SalesforceOpportunity"> | Date | string | null
    type?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    leadSource?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    description?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    ownerId?: StringNullableFilter<"SalesforceOpportunity"> | string | null
    metadata?: JsonNullableFilter<"SalesforceOpportunity">
    lastSync?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    createdAt?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
    updatedAt?: DateTimeFilter<"SalesforceOpportunity"> | Date | string
  }

  export type FundUpsertWithWhereUniqueWithoutUserInput = {
    where: FundWhereUniqueInput
    update: XOR<FundUpdateWithoutUserInput, FundUncheckedUpdateWithoutUserInput>
    create: XOR<FundCreateWithoutUserInput, FundUncheckedCreateWithoutUserInput>
  }

  export type FundUpdateWithWhereUniqueWithoutUserInput = {
    where: FundWhereUniqueInput
    data: XOR<FundUpdateWithoutUserInput, FundUncheckedUpdateWithoutUserInput>
  }

  export type FundUpdateManyWithWhereWithoutUserInput = {
    where: FundScalarWhereInput
    data: XOR<FundUpdateManyMutationInput, FundUncheckedUpdateManyWithoutUserInput>
  }

  export type FundScalarWhereInput = {
    AND?: FundScalarWhereInput | FundScalarWhereInput[]
    OR?: FundScalarWhereInput[]
    NOT?: FundScalarWhereInput | FundScalarWhereInput[]
    id?: StringFilter<"Fund"> | string
    userId?: StringFilter<"Fund"> | string
    name?: StringFilter<"Fund"> | string
    type?: StringFilter<"Fund"> | string
    strategy?: StringNullableFilter<"Fund"> | string | null
    targetSize?: FloatFilter<"Fund"> | number
    minimumCommitment?: FloatNullableFilter<"Fund"> | number | null
    managementFee?: FloatNullableFilter<"Fund"> | number | null
    carriedInterest?: FloatNullableFilter<"Fund"> | number | null
    currency?: StringFilter<"Fund"> | string
    vintage?: IntNullableFilter<"Fund"> | number | null
    investmentPeriod?: IntNullableFilter<"Fund"> | number | null
    fundTerm?: IntNullableFilter<"Fund"> | number | null
    geoFocus?: StringNullableFilter<"Fund"> | string | null
    sectorFocus?: StringNullableFilter<"Fund"> | string | null
    description?: StringNullableFilter<"Fund"> | string | null
    status?: StringFilter<"Fund"> | string
    raisedAmount?: FloatFilter<"Fund"> | number
    investorCount?: IntFilter<"Fund"> | number
    metadata?: JsonNullableFilter<"Fund">
    createdAt?: DateTimeFilter<"Fund"> | Date | string
    updatedAt?: DateTimeFilter<"Fund"> | Date | string
  }

  export type InvestorUpsertWithWhereUniqueWithoutUserInput = {
    where: InvestorWhereUniqueInput
    update: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
    create: XOR<InvestorCreateWithoutUserInput, InvestorUncheckedCreateWithoutUserInput>
  }

  export type InvestorUpdateWithWhereUniqueWithoutUserInput = {
    where: InvestorWhereUniqueInput
    data: XOR<InvestorUpdateWithoutUserInput, InvestorUncheckedUpdateWithoutUserInput>
  }

  export type InvestorUpdateManyWithWhereWithoutUserInput = {
    where: InvestorScalarWhereInput
    data: XOR<InvestorUpdateManyMutationInput, InvestorUncheckedUpdateManyWithoutUserInput>
  }

  export type InvestorScalarWhereInput = {
    AND?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    OR?: InvestorScalarWhereInput[]
    NOT?: InvestorScalarWhereInput | InvestorScalarWhereInput[]
    id?: StringFilter<"Investor"> | string
    userId?: StringFilter<"Investor"> | string
    name?: StringFilter<"Investor"> | string
    type?: StringFilter<"Investor"> | string
    status?: StringFilter<"Investor"> | string
    totalCommitment?: FloatNullableFilter<"Investor"> | number | null
    totalCalled?: FloatNullableFilter<"Investor"> | number | null
    description?: StringNullableFilter<"Investor"> | string | null
    website?: StringNullableFilter<"Investor"> | string | null
    location?: StringNullableFilter<"Investor"> | string | null
    founded?: DateTimeNullableFilter<"Investor"> | Date | string | null
    aum?: FloatNullableFilter<"Investor"> | number | null
    tags?: StringNullableListFilter<"Investor">
    metadata?: JsonNullableFilter<"Investor">
    createdAt?: DateTimeFilter<"Investor"> | Date | string
    updatedAt?: DateTimeFilter<"Investor"> | Date | string
  }

  export type LPGroupUpsertWithWhereUniqueWithoutUserInput = {
    where: LPGroupWhereUniqueInput
    update: XOR<LPGroupUpdateWithoutUserInput, LPGroupUncheckedUpdateWithoutUserInput>
    create: XOR<LPGroupCreateWithoutUserInput, LPGroupUncheckedCreateWithoutUserInput>
  }

  export type LPGroupUpdateWithWhereUniqueWithoutUserInput = {
    where: LPGroupWhereUniqueInput
    data: XOR<LPGroupUpdateWithoutUserInput, LPGroupUncheckedUpdateWithoutUserInput>
  }

  export type LPGroupUpdateManyWithWhereWithoutUserInput = {
    where: LPGroupScalarWhereInput
    data: XOR<LPGroupUpdateManyMutationInput, LPGroupUncheckedUpdateManyWithoutUserInput>
  }

  export type LPGroupScalarWhereInput = {
    AND?: LPGroupScalarWhereInput | LPGroupScalarWhereInput[]
    OR?: LPGroupScalarWhereInput[]
    NOT?: LPGroupScalarWhereInput | LPGroupScalarWhereInput[]
    id?: StringFilter<"LPGroup"> | string
    userId?: StringFilter<"LPGroup"> | string
    name?: StringFilter<"LPGroup"> | string
    description?: StringNullableFilter<"LPGroup"> | string | null
    type?: StringFilter<"LPGroup"> | string
    criteria?: JsonNullableFilter<"LPGroup">
    autoAssign?: BoolFilter<"LPGroup"> | boolean
    emailPreferences?: JsonNullableFilter<"LPGroup">
    createdAt?: DateTimeFilter<"LPGroup"> | Date | string
    updatedAt?: DateTimeFilter<"LPGroup"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIntegrationsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
  }

  export type UserUpsertWithoutIntegrationsInput = {
    update: XOR<UserUpdateWithoutIntegrationsInput, UserUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<UserCreateWithoutIntegrationsInput, UserUncheckedCreateWithoutIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIntegrationsInput, UserUncheckedUpdateWithoutIntegrationsInput>
  }

  export type UserUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDealsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDealsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDealsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDealsInput, UserUncheckedCreateWithoutDealsInput>
  }

  export type ContactCreateWithoutDealInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOwnedContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
    communications?: CommunicationCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutDealInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput>
  }

  export type ContactCreateManyDealInputEnvelope = {
    data: ContactCreateManyDealInput | ContactCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDealInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutDealInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentCreateManyDealInputEnvelope = {
    data: DocumentCreateManyDealInput | DocumentCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutDealInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    contact?: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutDealInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput>
  }

  export type ActivityCreateManyDealInputEnvelope = {
    data: ActivityCreateManyDealInput | ActivityCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutDealInput = {
    id?: string
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommunicationsInput
    contact?: ContactCreateNestedOneWithoutCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateOrConnectWithoutDealInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutDealInput, CommunicationUncheckedCreateWithoutDealInput>
  }

  export type CommunicationCreateManyDealInputEnvelope = {
    data: CommunicationCreateManyDealInput | CommunicationCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TeamsMessageCreateWithoutDealInput = {
    id?: string
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
    user: UserCreateNestedOneWithoutTeamsMessagesInput
    contact?: ContactCreateNestedOneWithoutTeamsMessagesInput
  }

  export type TeamsMessageUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type TeamsMessageCreateOrConnectWithoutDealInput = {
    where: TeamsMessageWhereUniqueInput
    create: XOR<TeamsMessageCreateWithoutDealInput, TeamsMessageUncheckedCreateWithoutDealInput>
  }

  export type TeamsMessageCreateManyDealInputEnvelope = {
    data: TeamsMessageCreateManyDealInput | TeamsMessageCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type SlackMessageCreateWithoutDealInput = {
    id?: string
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSlackMessagesInput
    contact?: ContactCreateNestedOneWithoutSlackMessagesInput
  }

  export type SlackMessageUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackMessageCreateOrConnectWithoutDealInput = {
    where: SlackMessageWhereUniqueInput
    create: XOR<SlackMessageCreateWithoutDealInput, SlackMessageUncheckedCreateWithoutDealInput>
  }

  export type SlackMessageCreateManyDealInputEnvelope = {
    data: SlackMessageCreateManyDealInput | SlackMessageCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type ZoomMeetingCreateWithoutDealInput = {
    id?: string
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZoomMeetingsInput
    participants?: ZoomParticipantCreateNestedManyWithoutMeetingInput
  }

  export type ZoomMeetingUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ZoomParticipantUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type ZoomMeetingCreateOrConnectWithoutDealInput = {
    where: ZoomMeetingWhereUniqueInput
    create: XOR<ZoomMeetingCreateWithoutDealInput, ZoomMeetingUncheckedCreateWithoutDealInput>
  }

  export type ZoomMeetingCreateManyDealInputEnvelope = {
    data: ZoomMeetingCreateManyDealInput | ZoomMeetingCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type SalesforceAccountCreateWithoutDealInput = {
    id?: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceAccountsInput
    contacts?: SalesforceContactCreateNestedManyWithoutAccountInput
    opportunities?: SalesforceOpportunityCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: SalesforceContactUncheckedCreateNestedManyWithoutAccountInput
    opportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountCreateOrConnectWithoutDealInput = {
    where: SalesforceAccountWhereUniqueInput
    create: XOR<SalesforceAccountCreateWithoutDealInput, SalesforceAccountUncheckedCreateWithoutDealInput>
  }

  export type SalesforceAccountCreateManyDealInputEnvelope = {
    data: SalesforceAccountCreateManyDealInput | SalesforceAccountCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type SalesforceOpportunityCreateWithoutDealInput = {
    id?: string
    opportunityId: string
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceOpportunitiesInput
    account?: SalesforceAccountCreateNestedOneWithoutOpportunitiesInput
  }

  export type SalesforceOpportunityUncheckedCreateWithoutDealInput = {
    id?: string
    userId: string
    opportunityId: string
    accountId?: string | null
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityCreateOrConnectWithoutDealInput = {
    where: SalesforceOpportunityWhereUniqueInput
    create: XOR<SalesforceOpportunityCreateWithoutDealInput, SalesforceOpportunityUncheckedCreateWithoutDealInput>
  }

  export type SalesforceOpportunityCreateManyDealInputEnvelope = {
    data: SalesforceOpportunityCreateManyDealInput | SalesforceOpportunityCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDealsInput = {
    update: XOR<UserUpdateWithoutDealsInput, UserUncheckedUpdateWithoutDealsInput>
    create: XOR<UserCreateWithoutDealsInput, UserUncheckedCreateWithoutDealsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDealsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDealsInput, UserUncheckedUpdateWithoutDealsInput>
  }

  export type UserUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactUpsertWithWhereUniqueWithoutDealInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutDealInput, ContactUncheckedUpdateWithoutDealInput>
    create: XOR<ContactCreateWithoutDealInput, ContactUncheckedCreateWithoutDealInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutDealInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutDealInput, ContactUncheckedUpdateWithoutDealInput>
  }

  export type ContactUpdateManyWithWhereWithoutDealInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutDealInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
    create: XOR<DocumentCreateWithoutDealInput, DocumentUncheckedCreateWithoutDealInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDealInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDealInput, DocumentUncheckedUpdateWithoutDealInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDealInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDealInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutDealInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutDealInput, ActivityUncheckedUpdateWithoutDealInput>
    create: XOR<ActivityCreateWithoutDealInput, ActivityUncheckedCreateWithoutDealInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutDealInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutDealInput, ActivityUncheckedUpdateWithoutDealInput>
  }

  export type ActivityUpdateManyWithWhereWithoutDealInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutDealInput>
  }

  export type CommunicationUpsertWithWhereUniqueWithoutDealInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutDealInput, CommunicationUncheckedUpdateWithoutDealInput>
    create: XOR<CommunicationCreateWithoutDealInput, CommunicationUncheckedCreateWithoutDealInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutDealInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutDealInput, CommunicationUncheckedUpdateWithoutDealInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutDealInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutDealInput>
  }

  export type TeamsMessageUpsertWithWhereUniqueWithoutDealInput = {
    where: TeamsMessageWhereUniqueInput
    update: XOR<TeamsMessageUpdateWithoutDealInput, TeamsMessageUncheckedUpdateWithoutDealInput>
    create: XOR<TeamsMessageCreateWithoutDealInput, TeamsMessageUncheckedCreateWithoutDealInput>
  }

  export type TeamsMessageUpdateWithWhereUniqueWithoutDealInput = {
    where: TeamsMessageWhereUniqueInput
    data: XOR<TeamsMessageUpdateWithoutDealInput, TeamsMessageUncheckedUpdateWithoutDealInput>
  }

  export type TeamsMessageUpdateManyWithWhereWithoutDealInput = {
    where: TeamsMessageScalarWhereInput
    data: XOR<TeamsMessageUpdateManyMutationInput, TeamsMessageUncheckedUpdateManyWithoutDealInput>
  }

  export type SlackMessageUpsertWithWhereUniqueWithoutDealInput = {
    where: SlackMessageWhereUniqueInput
    update: XOR<SlackMessageUpdateWithoutDealInput, SlackMessageUncheckedUpdateWithoutDealInput>
    create: XOR<SlackMessageCreateWithoutDealInput, SlackMessageUncheckedCreateWithoutDealInput>
  }

  export type SlackMessageUpdateWithWhereUniqueWithoutDealInput = {
    where: SlackMessageWhereUniqueInput
    data: XOR<SlackMessageUpdateWithoutDealInput, SlackMessageUncheckedUpdateWithoutDealInput>
  }

  export type SlackMessageUpdateManyWithWhereWithoutDealInput = {
    where: SlackMessageScalarWhereInput
    data: XOR<SlackMessageUpdateManyMutationInput, SlackMessageUncheckedUpdateManyWithoutDealInput>
  }

  export type ZoomMeetingUpsertWithWhereUniqueWithoutDealInput = {
    where: ZoomMeetingWhereUniqueInput
    update: XOR<ZoomMeetingUpdateWithoutDealInput, ZoomMeetingUncheckedUpdateWithoutDealInput>
    create: XOR<ZoomMeetingCreateWithoutDealInput, ZoomMeetingUncheckedCreateWithoutDealInput>
  }

  export type ZoomMeetingUpdateWithWhereUniqueWithoutDealInput = {
    where: ZoomMeetingWhereUniqueInput
    data: XOR<ZoomMeetingUpdateWithoutDealInput, ZoomMeetingUncheckedUpdateWithoutDealInput>
  }

  export type ZoomMeetingUpdateManyWithWhereWithoutDealInput = {
    where: ZoomMeetingScalarWhereInput
    data: XOR<ZoomMeetingUpdateManyMutationInput, ZoomMeetingUncheckedUpdateManyWithoutDealInput>
  }

  export type SalesforceAccountUpsertWithWhereUniqueWithoutDealInput = {
    where: SalesforceAccountWhereUniqueInput
    update: XOR<SalesforceAccountUpdateWithoutDealInput, SalesforceAccountUncheckedUpdateWithoutDealInput>
    create: XOR<SalesforceAccountCreateWithoutDealInput, SalesforceAccountUncheckedCreateWithoutDealInput>
  }

  export type SalesforceAccountUpdateWithWhereUniqueWithoutDealInput = {
    where: SalesforceAccountWhereUniqueInput
    data: XOR<SalesforceAccountUpdateWithoutDealInput, SalesforceAccountUncheckedUpdateWithoutDealInput>
  }

  export type SalesforceAccountUpdateManyWithWhereWithoutDealInput = {
    where: SalesforceAccountScalarWhereInput
    data: XOR<SalesforceAccountUpdateManyMutationInput, SalesforceAccountUncheckedUpdateManyWithoutDealInput>
  }

  export type SalesforceOpportunityUpsertWithWhereUniqueWithoutDealInput = {
    where: SalesforceOpportunityWhereUniqueInput
    update: XOR<SalesforceOpportunityUpdateWithoutDealInput, SalesforceOpportunityUncheckedUpdateWithoutDealInput>
    create: XOR<SalesforceOpportunityCreateWithoutDealInput, SalesforceOpportunityUncheckedCreateWithoutDealInput>
  }

  export type SalesforceOpportunityUpdateWithWhereUniqueWithoutDealInput = {
    where: SalesforceOpportunityWhereUniqueInput
    data: XOR<SalesforceOpportunityUpdateWithoutDealInput, SalesforceOpportunityUncheckedUpdateWithoutDealInput>
  }

  export type SalesforceOpportunityUpdateManyWithWhereWithoutDealInput = {
    where: SalesforceOpportunityScalarWhereInput
    data: XOR<SalesforceOpportunityUpdateManyMutationInput, SalesforceOpportunityUncheckedUpdateManyWithoutDealInput>
  }

  export type UserCreateWithoutOwnedContactsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedContactsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
  }

  export type DealCreateWithoutContactsInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutContactsInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutContactsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutContactsInput, DealUncheckedCreateWithoutContactsInput>
  }

  export type ActivityCreateWithoutContactInput = {
    id?: string
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
    deal?: DealCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutContactInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityCreateManyContactInputEnvelope = {
    data: ActivityCreateManyContactInput | ActivityCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutContactInput = {
    id?: string
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommunicationsInput
    deal?: DealCreateNestedOneWithoutCommunicationsInput
  }

  export type CommunicationUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateOrConnectWithoutContactInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutContactInput, CommunicationUncheckedCreateWithoutContactInput>
  }

  export type CommunicationCreateManyContactInputEnvelope = {
    data: CommunicationCreateManyContactInput | CommunicationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type TeamsMessageCreateWithoutContactInput = {
    id?: string
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
    user: UserCreateNestedOneWithoutTeamsMessagesInput
    deal?: DealCreateNestedOneWithoutTeamsMessagesInput
  }

  export type TeamsMessageUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type TeamsMessageCreateOrConnectWithoutContactInput = {
    where: TeamsMessageWhereUniqueInput
    create: XOR<TeamsMessageCreateWithoutContactInput, TeamsMessageUncheckedCreateWithoutContactInput>
  }

  export type TeamsMessageCreateManyContactInputEnvelope = {
    data: TeamsMessageCreateManyContactInput | TeamsMessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type SlackMessageCreateWithoutContactInput = {
    id?: string
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSlackMessagesInput
    deal?: DealCreateNestedOneWithoutSlackMessagesInput
  }

  export type SlackMessageUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackMessageCreateOrConnectWithoutContactInput = {
    where: SlackMessageWhereUniqueInput
    create: XOR<SlackMessageCreateWithoutContactInput, SlackMessageUncheckedCreateWithoutContactInput>
  }

  export type SlackMessageCreateManyContactInputEnvelope = {
    data: SlackMessageCreateManyContactInput | SlackMessageCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedContactsInput = {
    update: XOR<UserUpdateWithoutOwnedContactsInput, UserUncheckedUpdateWithoutOwnedContactsInput>
    create: XOR<UserCreateWithoutOwnedContactsInput, UserUncheckedCreateWithoutOwnedContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedContactsInput, UserUncheckedUpdateWithoutOwnedContactsInput>
  }

  export type UserUpdateWithoutOwnedContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutContactsInput = {
    update: XOR<DealUpdateWithoutContactsInput, DealUncheckedUpdateWithoutContactsInput>
    create: XOR<DealCreateWithoutContactsInput, DealUncheckedCreateWithoutContactsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutContactsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutContactsInput, DealUncheckedUpdateWithoutContactsInput>
  }

  export type DealUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
    create: XOR<ActivityCreateWithoutContactInput, ActivityUncheckedCreateWithoutContactInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutContactInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutContactInput, ActivityUncheckedUpdateWithoutContactInput>
  }

  export type ActivityUpdateManyWithWhereWithoutContactInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutContactInput>
  }

  export type CommunicationUpsertWithWhereUniqueWithoutContactInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutContactInput, CommunicationUncheckedUpdateWithoutContactInput>
    create: XOR<CommunicationCreateWithoutContactInput, CommunicationUncheckedCreateWithoutContactInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutContactInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutContactInput, CommunicationUncheckedUpdateWithoutContactInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutContactInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutContactInput>
  }

  export type TeamsMessageUpsertWithWhereUniqueWithoutContactInput = {
    where: TeamsMessageWhereUniqueInput
    update: XOR<TeamsMessageUpdateWithoutContactInput, TeamsMessageUncheckedUpdateWithoutContactInput>
    create: XOR<TeamsMessageCreateWithoutContactInput, TeamsMessageUncheckedCreateWithoutContactInput>
  }

  export type TeamsMessageUpdateWithWhereUniqueWithoutContactInput = {
    where: TeamsMessageWhereUniqueInput
    data: XOR<TeamsMessageUpdateWithoutContactInput, TeamsMessageUncheckedUpdateWithoutContactInput>
  }

  export type TeamsMessageUpdateManyWithWhereWithoutContactInput = {
    where: TeamsMessageScalarWhereInput
    data: XOR<TeamsMessageUpdateManyMutationInput, TeamsMessageUncheckedUpdateManyWithoutContactInput>
  }

  export type SlackMessageUpsertWithWhereUniqueWithoutContactInput = {
    where: SlackMessageWhereUniqueInput
    update: XOR<SlackMessageUpdateWithoutContactInput, SlackMessageUncheckedUpdateWithoutContactInput>
    create: XOR<SlackMessageCreateWithoutContactInput, SlackMessageUncheckedCreateWithoutContactInput>
  }

  export type SlackMessageUpdateWithWhereUniqueWithoutContactInput = {
    where: SlackMessageWhereUniqueInput
    data: XOR<SlackMessageUpdateWithoutContactInput, SlackMessageUncheckedUpdateWithoutContactInput>
  }

  export type SlackMessageUpdateManyWithWhereWithoutContactInput = {
    where: SlackMessageScalarWhereInput
    data: XOR<SlackMessageUpdateManyMutationInput, SlackMessageUncheckedUpdateManyWithoutContactInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type DealCreateWithoutActivitiesInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutActivitiesInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutActivitiesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
  }

  export type ContactCreateWithoutActivitiesInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOwnedContactsInput
    deal?: DealCreateNestedOneWithoutContactsInput
    communications?: CommunicationCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutActivitiesInput = {
    id?: string
    userId: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    communications?: CommunicationUncheckedCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutActivitiesInput = {
    update: XOR<DealUpdateWithoutActivitiesInput, DealUncheckedUpdateWithoutActivitiesInput>
    create: XOR<DealCreateWithoutActivitiesInput, DealUncheckedCreateWithoutActivitiesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutActivitiesInput, DealUncheckedUpdateWithoutActivitiesInput>
  }

  export type DealUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ContactUpsertWithoutActivitiesInput = {
    update: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    deal?: DealUpdateOneWithoutContactsNestedInput
    communications?: CommunicationUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communications?: CommunicationUncheckedUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type DealCreateWithoutDocumentsInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutDocumentsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutDocumentsInput = {
    update: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DealCreateWithoutDocumentsInput, DealUncheckedCreateWithoutDocumentsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutDocumentsInput, DealUncheckedUpdateWithoutDocumentsInput>
  }

  export type DealUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type UserCreateWithoutCommunicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
  }

  export type DealCreateWithoutCommunicationsInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutCommunicationsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutCommunicationsInput, DealUncheckedCreateWithoutCommunicationsInput>
  }

  export type ContactCreateWithoutCommunicationsInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOwnedContactsInput
    deal?: DealCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    userId: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCommunicationsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCommunicationsInput, ContactUncheckedCreateWithoutCommunicationsInput>
  }

  export type UserUpsertWithoutCommunicationsInput = {
    update: XOR<UserUpdateWithoutCommunicationsInput, UserUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunicationsInput, UserUncheckedUpdateWithoutCommunicationsInput>
  }

  export type UserUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutCommunicationsInput = {
    update: XOR<DealUpdateWithoutCommunicationsInput, DealUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<DealCreateWithoutCommunicationsInput, DealUncheckedCreateWithoutCommunicationsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutCommunicationsInput, DealUncheckedUpdateWithoutCommunicationsInput>
  }

  export type DealUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ContactUpsertWithoutCommunicationsInput = {
    update: XOR<ContactUpdateWithoutCommunicationsInput, ContactUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<ContactCreateWithoutCommunicationsInput, ContactUncheckedCreateWithoutCommunicationsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCommunicationsInput, ContactUncheckedUpdateWithoutCommunicationsInput>
  }

  export type ContactUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    deal?: DealUpdateOneWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutInvestorsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvestorsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvestorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvestorsInput, UserUncheckedCreateWithoutInvestorsInput>
  }

  export type InvestorEntityCreateWithoutInvestorInput = {
    id?: string
    name: string
    type: string
    investmentType: string
    commitment?: number | null
    called?: number | null
    status?: string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorEntityUncheckedCreateWithoutInvestorInput = {
    id?: string
    name: string
    type: string
    investmentType: string
    commitment?: number | null
    called?: number | null
    status?: string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorEntityCreateOrConnectWithoutInvestorInput = {
    where: InvestorEntityWhereUniqueInput
    create: XOR<InvestorEntityCreateWithoutInvestorInput, InvestorEntityUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorEntityCreateManyInvestorInputEnvelope = {
    data: InvestorEntityCreateManyInvestorInput | InvestorEntityCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type InvestorGroupMemberCreateWithoutInvestorInput = {
    id?: string
    assignedAt?: Date | string
    autoAssigned?: boolean
    group: LPGroupCreateNestedOneWithoutMembersInput
  }

  export type InvestorGroupMemberUncheckedCreateWithoutInvestorInput = {
    id?: string
    groupId: string
    assignedAt?: Date | string
    autoAssigned?: boolean
  }

  export type InvestorGroupMemberCreateOrConnectWithoutInvestorInput = {
    where: InvestorGroupMemberWhereUniqueInput
    create: XOR<InvestorGroupMemberCreateWithoutInvestorInput, InvestorGroupMemberUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorGroupMemberCreateManyInvestorInputEnvelope = {
    data: InvestorGroupMemberCreateManyInvestorInput | InvestorGroupMemberCreateManyInvestorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvestorsInput = {
    update: XOR<UserUpdateWithoutInvestorsInput, UserUncheckedUpdateWithoutInvestorsInput>
    create: XOR<UserCreateWithoutInvestorsInput, UserUncheckedCreateWithoutInvestorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvestorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvestorsInput, UserUncheckedUpdateWithoutInvestorsInput>
  }

  export type UserUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvestorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvestorEntityUpsertWithWhereUniqueWithoutInvestorInput = {
    where: InvestorEntityWhereUniqueInput
    update: XOR<InvestorEntityUpdateWithoutInvestorInput, InvestorEntityUncheckedUpdateWithoutInvestorInput>
    create: XOR<InvestorEntityCreateWithoutInvestorInput, InvestorEntityUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorEntityUpdateWithWhereUniqueWithoutInvestorInput = {
    where: InvestorEntityWhereUniqueInput
    data: XOR<InvestorEntityUpdateWithoutInvestorInput, InvestorEntityUncheckedUpdateWithoutInvestorInput>
  }

  export type InvestorEntityUpdateManyWithWhereWithoutInvestorInput = {
    where: InvestorEntityScalarWhereInput
    data: XOR<InvestorEntityUpdateManyMutationInput, InvestorEntityUncheckedUpdateManyWithoutInvestorInput>
  }

  export type InvestorEntityScalarWhereInput = {
    AND?: InvestorEntityScalarWhereInput | InvestorEntityScalarWhereInput[]
    OR?: InvestorEntityScalarWhereInput[]
    NOT?: InvestorEntityScalarWhereInput | InvestorEntityScalarWhereInput[]
    id?: StringFilter<"InvestorEntity"> | string
    investorId?: StringFilter<"InvestorEntity"> | string
    name?: StringFilter<"InvestorEntity"> | string
    type?: StringFilter<"InvestorEntity"> | string
    investmentType?: StringFilter<"InvestorEntity"> | string
    commitment?: FloatNullableFilter<"InvestorEntity"> | number | null
    called?: FloatNullableFilter<"InvestorEntity"> | number | null
    status?: StringFilter<"InvestorEntity"> | string
    documents?: JsonNullableFilter<"InvestorEntity">
    fundInvestments?: JsonNullableFilter<"InvestorEntity">
    createdAt?: DateTimeFilter<"InvestorEntity"> | Date | string
    updatedAt?: DateTimeFilter<"InvestorEntity"> | Date | string
  }

  export type InvestorGroupMemberUpsertWithWhereUniqueWithoutInvestorInput = {
    where: InvestorGroupMemberWhereUniqueInput
    update: XOR<InvestorGroupMemberUpdateWithoutInvestorInput, InvestorGroupMemberUncheckedUpdateWithoutInvestorInput>
    create: XOR<InvestorGroupMemberCreateWithoutInvestorInput, InvestorGroupMemberUncheckedCreateWithoutInvestorInput>
  }

  export type InvestorGroupMemberUpdateWithWhereUniqueWithoutInvestorInput = {
    where: InvestorGroupMemberWhereUniqueInput
    data: XOR<InvestorGroupMemberUpdateWithoutInvestorInput, InvestorGroupMemberUncheckedUpdateWithoutInvestorInput>
  }

  export type InvestorGroupMemberUpdateManyWithWhereWithoutInvestorInput = {
    where: InvestorGroupMemberScalarWhereInput
    data: XOR<InvestorGroupMemberUpdateManyMutationInput, InvestorGroupMemberUncheckedUpdateManyWithoutInvestorInput>
  }

  export type InvestorGroupMemberScalarWhereInput = {
    AND?: InvestorGroupMemberScalarWhereInput | InvestorGroupMemberScalarWhereInput[]
    OR?: InvestorGroupMemberScalarWhereInput[]
    NOT?: InvestorGroupMemberScalarWhereInput | InvestorGroupMemberScalarWhereInput[]
    id?: StringFilter<"InvestorGroupMember"> | string
    investorId?: StringFilter<"InvestorGroupMember"> | string
    groupId?: StringFilter<"InvestorGroupMember"> | string
    assignedAt?: DateTimeFilter<"InvestorGroupMember"> | Date | string
    autoAssigned?: BoolFilter<"InvestorGroupMember"> | boolean
  }

  export type UserCreateWithoutFundsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFundsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFundsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFundsInput, UserUncheckedCreateWithoutFundsInput>
  }

  export type UserUpsertWithoutFundsInput = {
    update: XOR<UserUpdateWithoutFundsInput, UserUncheckedUpdateWithoutFundsInput>
    create: XOR<UserCreateWithoutFundsInput, UserUncheckedCreateWithoutFundsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFundsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFundsInput, UserUncheckedUpdateWithoutFundsInput>
  }

  export type UserUpdateWithoutFundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvestorCreateWithoutEntitiesInput = {
    id?: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorsInput
    groupMemberships?: InvestorGroupMemberCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutEntitiesInput = {
    id?: string
    userId: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMemberships?: InvestorGroupMemberUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutEntitiesInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutEntitiesInput, InvestorUncheckedCreateWithoutEntitiesInput>
  }

  export type InvestorUpsertWithoutEntitiesInput = {
    update: XOR<InvestorUpdateWithoutEntitiesInput, InvestorUncheckedUpdateWithoutEntitiesInput>
    create: XOR<InvestorCreateWithoutEntitiesInput, InvestorUncheckedCreateWithoutEntitiesInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutEntitiesInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutEntitiesInput, InvestorUncheckedUpdateWithoutEntitiesInput>
  }

  export type InvestorUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorsNestedInput
    groupMemberships?: InvestorGroupMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMemberships?: InvestorGroupMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type UserCreateWithoutTeamsMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsMessagesInput, UserUncheckedCreateWithoutTeamsMessagesInput>
  }

  export type DealCreateWithoutTeamsMessagesInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTeamsMessagesInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTeamsMessagesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTeamsMessagesInput, DealUncheckedCreateWithoutTeamsMessagesInput>
  }

  export type ContactCreateWithoutTeamsMessagesInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOwnedContactsInput
    deal?: DealCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
    communications?: CommunicationCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTeamsMessagesInput = {
    id?: string
    userId: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutContactInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTeamsMessagesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTeamsMessagesInput, ContactUncheckedCreateWithoutTeamsMessagesInput>
  }

  export type UserUpsertWithoutTeamsMessagesInput = {
    update: XOR<UserUpdateWithoutTeamsMessagesInput, UserUncheckedUpdateWithoutTeamsMessagesInput>
    create: XOR<UserCreateWithoutTeamsMessagesInput, UserUncheckedCreateWithoutTeamsMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsMessagesInput, UserUncheckedUpdateWithoutTeamsMessagesInput>
  }

  export type UserUpdateWithoutTeamsMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutTeamsMessagesInput = {
    update: XOR<DealUpdateWithoutTeamsMessagesInput, DealUncheckedUpdateWithoutTeamsMessagesInput>
    create: XOR<DealCreateWithoutTeamsMessagesInput, DealUncheckedCreateWithoutTeamsMessagesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutTeamsMessagesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutTeamsMessagesInput, DealUncheckedUpdateWithoutTeamsMessagesInput>
  }

  export type DealUpdateWithoutTeamsMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTeamsMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ContactUpsertWithoutTeamsMessagesInput = {
    update: XOR<ContactUpdateWithoutTeamsMessagesInput, ContactUncheckedUpdateWithoutTeamsMessagesInput>
    create: XOR<ContactCreateWithoutTeamsMessagesInput, ContactUncheckedCreateWithoutTeamsMessagesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTeamsMessagesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTeamsMessagesInput, ContactUncheckedUpdateWithoutTeamsMessagesInput>
  }

  export type ContactUpdateWithoutTeamsMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    deal?: DealUpdateOneWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
    communications?: CommunicationUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTeamsMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutTeamsChannelsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsChannelsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsChannelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsChannelsInput, UserUncheckedCreateWithoutTeamsChannelsInput>
  }

  export type UserUpsertWithoutTeamsChannelsInput = {
    update: XOR<UserUpdateWithoutTeamsChannelsInput, UserUncheckedUpdateWithoutTeamsChannelsInput>
    create: XOR<UserCreateWithoutTeamsChannelsInput, UserUncheckedCreateWithoutTeamsChannelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsChannelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsChannelsInput, UserUncheckedUpdateWithoutTeamsChannelsInput>
  }

  export type UserUpdateWithoutTeamsChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSlackMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSlackMessagesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSlackMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSlackMessagesInput, UserUncheckedCreateWithoutSlackMessagesInput>
  }

  export type DealCreateWithoutSlackMessagesInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSlackMessagesInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSlackMessagesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSlackMessagesInput, DealUncheckedCreateWithoutSlackMessagesInput>
  }

  export type ContactCreateWithoutSlackMessagesInput = {
    id?: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOwnedContactsInput
    deal?: DealCreateNestedOneWithoutContactsInput
    activities?: ActivityCreateNestedManyWithoutContactInput
    communications?: CommunicationCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutSlackMessagesInput = {
    id?: string
    userId: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityUncheckedCreateNestedManyWithoutContactInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutContactInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutSlackMessagesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutSlackMessagesInput, ContactUncheckedCreateWithoutSlackMessagesInput>
  }

  export type UserUpsertWithoutSlackMessagesInput = {
    update: XOR<UserUpdateWithoutSlackMessagesInput, UserUncheckedUpdateWithoutSlackMessagesInput>
    create: XOR<UserCreateWithoutSlackMessagesInput, UserUncheckedCreateWithoutSlackMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSlackMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSlackMessagesInput, UserUncheckedUpdateWithoutSlackMessagesInput>
  }

  export type UserUpdateWithoutSlackMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSlackMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutSlackMessagesInput = {
    update: XOR<DealUpdateWithoutSlackMessagesInput, DealUncheckedUpdateWithoutSlackMessagesInput>
    create: XOR<DealCreateWithoutSlackMessagesInput, DealUncheckedCreateWithoutSlackMessagesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutSlackMessagesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutSlackMessagesInput, DealUncheckedUpdateWithoutSlackMessagesInput>
  }

  export type DealUpdateWithoutSlackMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSlackMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ContactUpsertWithoutSlackMessagesInput = {
    update: XOR<ContactUpdateWithoutSlackMessagesInput, ContactUncheckedUpdateWithoutSlackMessagesInput>
    create: XOR<ContactCreateWithoutSlackMessagesInput, ContactUncheckedCreateWithoutSlackMessagesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutSlackMessagesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutSlackMessagesInput, ContactUncheckedUpdateWithoutSlackMessagesInput>
  }

  export type ContactUpdateWithoutSlackMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    deal?: DealUpdateOneWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
    communications?: CommunicationUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutSlackMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type UserCreateWithoutSlackChannelsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSlackChannelsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSlackChannelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSlackChannelsInput, UserUncheckedCreateWithoutSlackChannelsInput>
  }

  export type UserUpsertWithoutSlackChannelsInput = {
    update: XOR<UserUpdateWithoutSlackChannelsInput, UserUncheckedUpdateWithoutSlackChannelsInput>
    create: XOR<UserCreateWithoutSlackChannelsInput, UserUncheckedCreateWithoutSlackChannelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSlackChannelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSlackChannelsInput, UserUncheckedUpdateWithoutSlackChannelsInput>
  }

  export type UserUpdateWithoutSlackChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSlackChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutZoomMeetingsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZoomMeetingsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZoomMeetingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZoomMeetingsInput, UserUncheckedCreateWithoutZoomMeetingsInput>
  }

  export type DealCreateWithoutZoomMeetingsInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutZoomMeetingsInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutZoomMeetingsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutZoomMeetingsInput, DealUncheckedCreateWithoutZoomMeetingsInput>
  }

  export type ZoomParticipantCreateWithoutMeetingInput = {
    id?: string
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutZoomParticipantsInput
  }

  export type ZoomParticipantUncheckedCreateWithoutMeetingInput = {
    id?: string
    userId?: string | null
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomParticipantCreateOrConnectWithoutMeetingInput = {
    where: ZoomParticipantWhereUniqueInput
    create: XOR<ZoomParticipantCreateWithoutMeetingInput, ZoomParticipantUncheckedCreateWithoutMeetingInput>
  }

  export type ZoomParticipantCreateManyMeetingInputEnvelope = {
    data: ZoomParticipantCreateManyMeetingInput | ZoomParticipantCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutZoomMeetingsInput = {
    update: XOR<UserUpdateWithoutZoomMeetingsInput, UserUncheckedUpdateWithoutZoomMeetingsInput>
    create: XOR<UserCreateWithoutZoomMeetingsInput, UserUncheckedCreateWithoutZoomMeetingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZoomMeetingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZoomMeetingsInput, UserUncheckedUpdateWithoutZoomMeetingsInput>
  }

  export type UserUpdateWithoutZoomMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZoomMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutZoomMeetingsInput = {
    update: XOR<DealUpdateWithoutZoomMeetingsInput, DealUncheckedUpdateWithoutZoomMeetingsInput>
    create: XOR<DealCreateWithoutZoomMeetingsInput, DealUncheckedCreateWithoutZoomMeetingsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutZoomMeetingsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutZoomMeetingsInput, DealUncheckedUpdateWithoutZoomMeetingsInput>
  }

  export type DealUpdateWithoutZoomMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutZoomMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type ZoomParticipantUpsertWithWhereUniqueWithoutMeetingInput = {
    where: ZoomParticipantWhereUniqueInput
    update: XOR<ZoomParticipantUpdateWithoutMeetingInput, ZoomParticipantUncheckedUpdateWithoutMeetingInput>
    create: XOR<ZoomParticipantCreateWithoutMeetingInput, ZoomParticipantUncheckedCreateWithoutMeetingInput>
  }

  export type ZoomParticipantUpdateWithWhereUniqueWithoutMeetingInput = {
    where: ZoomParticipantWhereUniqueInput
    data: XOR<ZoomParticipantUpdateWithoutMeetingInput, ZoomParticipantUncheckedUpdateWithoutMeetingInput>
  }

  export type ZoomParticipantUpdateManyWithWhereWithoutMeetingInput = {
    where: ZoomParticipantScalarWhereInput
    data: XOR<ZoomParticipantUpdateManyMutationInput, ZoomParticipantUncheckedUpdateManyWithoutMeetingInput>
  }

  export type ZoomMeetingCreateWithoutParticipantsInput = {
    id?: string
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutZoomMeetingsInput
    deal?: DealCreateNestedOneWithoutZoomMeetingsInput
  }

  export type ZoomMeetingUncheckedCreateWithoutParticipantsInput = {
    id?: string
    userId: string
    dealId?: string | null
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomMeetingCreateOrConnectWithoutParticipantsInput = {
    where: ZoomMeetingWhereUniqueInput
    create: XOR<ZoomMeetingCreateWithoutParticipantsInput, ZoomMeetingUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutZoomParticipantsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutZoomParticipantsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutZoomParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutZoomParticipantsInput, UserUncheckedCreateWithoutZoomParticipantsInput>
  }

  export type ZoomMeetingUpsertWithoutParticipantsInput = {
    update: XOR<ZoomMeetingUpdateWithoutParticipantsInput, ZoomMeetingUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ZoomMeetingCreateWithoutParticipantsInput, ZoomMeetingUncheckedCreateWithoutParticipantsInput>
    where?: ZoomMeetingWhereInput
  }

  export type ZoomMeetingUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ZoomMeetingWhereInput
    data: XOR<ZoomMeetingUpdateWithoutParticipantsInput, ZoomMeetingUncheckedUpdateWithoutParticipantsInput>
  }

  export type ZoomMeetingUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZoomMeetingsNestedInput
    deal?: DealUpdateOneWithoutZoomMeetingsNestedInput
  }

  export type ZoomMeetingUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutZoomParticipantsInput = {
    update: XOR<UserUpdateWithoutZoomParticipantsInput, UserUncheckedUpdateWithoutZoomParticipantsInput>
    create: XOR<UserCreateWithoutZoomParticipantsInput, UserUncheckedCreateWithoutZoomParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutZoomParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutZoomParticipantsInput, UserUncheckedUpdateWithoutZoomParticipantsInput>
  }

  export type UserUpdateWithoutZoomParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutZoomParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSalesforceAccountsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesforceAccountsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesforceAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesforceAccountsInput, UserUncheckedCreateWithoutSalesforceAccountsInput>
  }

  export type DealCreateWithoutSalesforceAccountsInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSalesforceAccountsInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSalesforceAccountsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSalesforceAccountsInput, DealUncheckedCreateWithoutSalesforceAccountsInput>
  }

  export type SalesforceContactCreateWithoutAccountInput = {
    id?: string
    contactId: string
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceContactsInput
  }

  export type SalesforceContactUncheckedCreateWithoutAccountInput = {
    id?: string
    userId: string
    contactId: string
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceContactCreateOrConnectWithoutAccountInput = {
    where: SalesforceContactWhereUniqueInput
    create: XOR<SalesforceContactCreateWithoutAccountInput, SalesforceContactUncheckedCreateWithoutAccountInput>
  }

  export type SalesforceContactCreateManyAccountInputEnvelope = {
    data: SalesforceContactCreateManyAccountInput | SalesforceContactCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type SalesforceOpportunityCreateWithoutAccountInput = {
    id?: string
    opportunityId: string
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceOpportunitiesInput
    deal?: DealCreateNestedOneWithoutSalesforceOpportunitiesInput
  }

  export type SalesforceOpportunityUncheckedCreateWithoutAccountInput = {
    id?: string
    userId: string
    dealId?: string | null
    opportunityId: string
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityCreateOrConnectWithoutAccountInput = {
    where: SalesforceOpportunityWhereUniqueInput
    create: XOR<SalesforceOpportunityCreateWithoutAccountInput, SalesforceOpportunityUncheckedCreateWithoutAccountInput>
  }

  export type SalesforceOpportunityCreateManyAccountInputEnvelope = {
    data: SalesforceOpportunityCreateManyAccountInput | SalesforceOpportunityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSalesforceAccountsInput = {
    update: XOR<UserUpdateWithoutSalesforceAccountsInput, UserUncheckedUpdateWithoutSalesforceAccountsInput>
    create: XOR<UserCreateWithoutSalesforceAccountsInput, UserUncheckedCreateWithoutSalesforceAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesforceAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesforceAccountsInput, UserUncheckedUpdateWithoutSalesforceAccountsInput>
  }

  export type UserUpdateWithoutSalesforceAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesforceAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutSalesforceAccountsInput = {
    update: XOR<DealUpdateWithoutSalesforceAccountsInput, DealUncheckedUpdateWithoutSalesforceAccountsInput>
    create: XOR<DealCreateWithoutSalesforceAccountsInput, DealUncheckedCreateWithoutSalesforceAccountsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutSalesforceAccountsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutSalesforceAccountsInput, DealUncheckedUpdateWithoutSalesforceAccountsInput>
  }

  export type DealUpdateWithoutSalesforceAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSalesforceAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SalesforceContactUpsertWithWhereUniqueWithoutAccountInput = {
    where: SalesforceContactWhereUniqueInput
    update: XOR<SalesforceContactUpdateWithoutAccountInput, SalesforceContactUncheckedUpdateWithoutAccountInput>
    create: XOR<SalesforceContactCreateWithoutAccountInput, SalesforceContactUncheckedCreateWithoutAccountInput>
  }

  export type SalesforceContactUpdateWithWhereUniqueWithoutAccountInput = {
    where: SalesforceContactWhereUniqueInput
    data: XOR<SalesforceContactUpdateWithoutAccountInput, SalesforceContactUncheckedUpdateWithoutAccountInput>
  }

  export type SalesforceContactUpdateManyWithWhereWithoutAccountInput = {
    where: SalesforceContactScalarWhereInput
    data: XOR<SalesforceContactUpdateManyMutationInput, SalesforceContactUncheckedUpdateManyWithoutAccountInput>
  }

  export type SalesforceOpportunityUpsertWithWhereUniqueWithoutAccountInput = {
    where: SalesforceOpportunityWhereUniqueInput
    update: XOR<SalesforceOpportunityUpdateWithoutAccountInput, SalesforceOpportunityUncheckedUpdateWithoutAccountInput>
    create: XOR<SalesforceOpportunityCreateWithoutAccountInput, SalesforceOpportunityUncheckedCreateWithoutAccountInput>
  }

  export type SalesforceOpportunityUpdateWithWhereUniqueWithoutAccountInput = {
    where: SalesforceOpportunityWhereUniqueInput
    data: XOR<SalesforceOpportunityUpdateWithoutAccountInput, SalesforceOpportunityUncheckedUpdateWithoutAccountInput>
  }

  export type SalesforceOpportunityUpdateManyWithWhereWithoutAccountInput = {
    where: SalesforceOpportunityScalarWhereInput
    data: XOR<SalesforceOpportunityUpdateManyMutationInput, SalesforceOpportunityUncheckedUpdateManyWithoutAccountInput>
  }

  export type UserCreateWithoutSalesforceContactsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesforceContactsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesforceContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesforceContactsInput, UserUncheckedCreateWithoutSalesforceContactsInput>
  }

  export type SalesforceAccountCreateWithoutContactsInput = {
    id?: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceAccountsInput
    deal?: DealCreateNestedOneWithoutSalesforceAccountsInput
    opportunities?: SalesforceOpportunityCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountUncheckedCreateWithoutContactsInput = {
    id?: string
    userId: string
    dealId?: string | null
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountCreateOrConnectWithoutContactsInput = {
    where: SalesforceAccountWhereUniqueInput
    create: XOR<SalesforceAccountCreateWithoutContactsInput, SalesforceAccountUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutSalesforceContactsInput = {
    update: XOR<UserUpdateWithoutSalesforceContactsInput, UserUncheckedUpdateWithoutSalesforceContactsInput>
    create: XOR<UserCreateWithoutSalesforceContactsInput, UserUncheckedCreateWithoutSalesforceContactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesforceContactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesforceContactsInput, UserUncheckedUpdateWithoutSalesforceContactsInput>
  }

  export type UserUpdateWithoutSalesforceContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesforceContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SalesforceAccountUpsertWithoutContactsInput = {
    update: XOR<SalesforceAccountUpdateWithoutContactsInput, SalesforceAccountUncheckedUpdateWithoutContactsInput>
    create: XOR<SalesforceAccountCreateWithoutContactsInput, SalesforceAccountUncheckedCreateWithoutContactsInput>
    where?: SalesforceAccountWhereInput
  }

  export type SalesforceAccountUpdateToOneWithWhereWithoutContactsInput = {
    where?: SalesforceAccountWhereInput
    data: XOR<SalesforceAccountUpdateWithoutContactsInput, SalesforceAccountUncheckedUpdateWithoutContactsInput>
  }

  export type SalesforceAccountUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceAccountsNestedInput
    deal?: DealUpdateOneWithoutSalesforceAccountsNestedInput
    opportunities?: SalesforceOpportunityUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserCreateWithoutSalesforceOpportunitiesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSalesforceOpportunitiesInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
    lpGroups?: LPGroupUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSalesforceOpportunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesforceOpportunitiesInput, UserUncheckedCreateWithoutSalesforceOpportunitiesInput>
  }

  export type DealCreateWithoutSalesforceOpportunitiesInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDealsInput
    contacts?: ContactCreateNestedManyWithoutDealInput
    documents?: DocumentCreateNestedManyWithoutDealInput
    activities?: ActivityCreateNestedManyWithoutDealInput
    communications?: CommunicationCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutSalesforceOpportunitiesInput = {
    id?: string
    userId: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutDealInput
    documents?: DocumentUncheckedCreateNestedManyWithoutDealInput
    activities?: ActivityUncheckedCreateNestedManyWithoutDealInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutDealInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutDealInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutDealInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutDealInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutSalesforceOpportunitiesInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutSalesforceOpportunitiesInput, DealUncheckedCreateWithoutSalesforceOpportunitiesInput>
  }

  export type SalesforceAccountCreateWithoutOpportunitiesInput = {
    id?: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSalesforceAccountsInput
    deal?: DealCreateNestedOneWithoutSalesforceAccountsInput
    contacts?: SalesforceContactCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountUncheckedCreateWithoutOpportunitiesInput = {
    id?: string
    userId: string
    dealId?: string | null
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: SalesforceContactUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SalesforceAccountCreateOrConnectWithoutOpportunitiesInput = {
    where: SalesforceAccountWhereUniqueInput
    create: XOR<SalesforceAccountCreateWithoutOpportunitiesInput, SalesforceAccountUncheckedCreateWithoutOpportunitiesInput>
  }

  export type UserUpsertWithoutSalesforceOpportunitiesInput = {
    update: XOR<UserUpdateWithoutSalesforceOpportunitiesInput, UserUncheckedUpdateWithoutSalesforceOpportunitiesInput>
    create: XOR<UserCreateWithoutSalesforceOpportunitiesInput, UserUncheckedCreateWithoutSalesforceOpportunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesforceOpportunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesforceOpportunitiesInput, UserUncheckedUpdateWithoutSalesforceOpportunitiesInput>
  }

  export type UserUpdateWithoutSalesforceOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesforceOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
    lpGroups?: LPGroupUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DealUpsertWithoutSalesforceOpportunitiesInput = {
    update: XOR<DealUpdateWithoutSalesforceOpportunitiesInput, DealUncheckedUpdateWithoutSalesforceOpportunitiesInput>
    create: XOR<DealCreateWithoutSalesforceOpportunitiesInput, DealUncheckedCreateWithoutSalesforceOpportunitiesInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutSalesforceOpportunitiesInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutSalesforceOpportunitiesInput, DealUncheckedUpdateWithoutSalesforceOpportunitiesInput>
  }

  export type DealUpdateWithoutSalesforceOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDealsNestedInput
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutSalesforceOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
  }

  export type SalesforceAccountUpsertWithoutOpportunitiesInput = {
    update: XOR<SalesforceAccountUpdateWithoutOpportunitiesInput, SalesforceAccountUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<SalesforceAccountCreateWithoutOpportunitiesInput, SalesforceAccountUncheckedCreateWithoutOpportunitiesInput>
    where?: SalesforceAccountWhereInput
  }

  export type SalesforceAccountUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: SalesforceAccountWhereInput
    data: XOR<SalesforceAccountUpdateWithoutOpportunitiesInput, SalesforceAccountUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type SalesforceAccountUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceAccountsNestedInput
    deal?: DealUpdateOneWithoutSalesforceAccountsNestedInput
    contacts?: SalesforceContactUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateWithoutOpportunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: SalesforceContactUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserCreateWithoutLpGroupsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    deals?: DealCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
    ownedContacts?: ContactCreateNestedManyWithoutUserInput
    communications?: CommunicationCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityCreateNestedManyWithoutUserInput
    funds?: FundCreateNestedManyWithoutUserInput
    investors?: InvestorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLpGroupsInput = {
    id?: string
    email: string
    password: string
    name: string
    firm?: string | null
    role?: string | null
    phone?: string | null
    location?: string | null
    avatar?: string | null
    emailVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    deals?: DealUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
    ownedContacts?: ContactUncheckedCreateNestedManyWithoutUserInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    teamsMessages?: TeamsMessageUncheckedCreateNestedManyWithoutUserInput
    teamsChannels?: TeamsChannelUncheckedCreateNestedManyWithoutUserInput
    slackMessages?: SlackMessageUncheckedCreateNestedManyWithoutUserInput
    slackChannels?: SlackChannelUncheckedCreateNestedManyWithoutUserInput
    zoomMeetings?: ZoomMeetingUncheckedCreateNestedManyWithoutUserInput
    zoomParticipants?: ZoomParticipantUncheckedCreateNestedManyWithoutUserInput
    salesforceAccounts?: SalesforceAccountUncheckedCreateNestedManyWithoutUserInput
    salesforceContacts?: SalesforceContactUncheckedCreateNestedManyWithoutUserInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedCreateNestedManyWithoutUserInput
    funds?: FundUncheckedCreateNestedManyWithoutUserInput
    investors?: InvestorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLpGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLpGroupsInput, UserUncheckedCreateWithoutLpGroupsInput>
  }

  export type InvestorGroupMemberCreateWithoutGroupInput = {
    id?: string
    assignedAt?: Date | string
    autoAssigned?: boolean
    investor: InvestorCreateNestedOneWithoutGroupMembershipsInput
  }

  export type InvestorGroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    investorId: string
    assignedAt?: Date | string
    autoAssigned?: boolean
  }

  export type InvestorGroupMemberCreateOrConnectWithoutGroupInput = {
    where: InvestorGroupMemberWhereUniqueInput
    create: XOR<InvestorGroupMemberCreateWithoutGroupInput, InvestorGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type InvestorGroupMemberCreateManyGroupInputEnvelope = {
    data: InvestorGroupMemberCreateManyGroupInput | InvestorGroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLpGroupsInput = {
    update: XOR<UserUpdateWithoutLpGroupsInput, UserUncheckedUpdateWithoutLpGroupsInput>
    create: XOR<UserCreateWithoutLpGroupsInput, UserUncheckedCreateWithoutLpGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLpGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLpGroupsInput, UserUncheckedUpdateWithoutLpGroupsInput>
  }

  export type UserUpdateWithoutLpGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    deals?: DealUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUpdateManyWithoutUserNestedInput
    communications?: CommunicationUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutUserNestedInput
    funds?: FundUpdateManyWithoutUserNestedInput
    investors?: InvestorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLpGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    firm?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    deals?: DealUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
    ownedContacts?: ContactUncheckedUpdateManyWithoutUserNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutUserNestedInput
    teamsChannels?: TeamsChannelUncheckedUpdateManyWithoutUserNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutUserNestedInput
    slackChannels?: SlackChannelUncheckedUpdateManyWithoutUserNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutUserNestedInput
    zoomParticipants?: ZoomParticipantUncheckedUpdateManyWithoutUserNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutUserNestedInput
    salesforceContacts?: SalesforceContactUncheckedUpdateManyWithoutUserNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutUserNestedInput
    funds?: FundUncheckedUpdateManyWithoutUserNestedInput
    investors?: InvestorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvestorGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: InvestorGroupMemberWhereUniqueInput
    update: XOR<InvestorGroupMemberUpdateWithoutGroupInput, InvestorGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<InvestorGroupMemberCreateWithoutGroupInput, InvestorGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type InvestorGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: InvestorGroupMemberWhereUniqueInput
    data: XOR<InvestorGroupMemberUpdateWithoutGroupInput, InvestorGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type InvestorGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: InvestorGroupMemberScalarWhereInput
    data: XOR<InvestorGroupMemberUpdateManyMutationInput, InvestorGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type InvestorCreateWithoutGroupMembershipsInput = {
    id?: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvestorsInput
    entities?: InvestorEntityCreateNestedManyWithoutInvestorInput
  }

  export type InvestorUncheckedCreateWithoutGroupMembershipsInput = {
    id?: string
    userId: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: InvestorEntityUncheckedCreateNestedManyWithoutInvestorInput
  }

  export type InvestorCreateOrConnectWithoutGroupMembershipsInput = {
    where: InvestorWhereUniqueInput
    create: XOR<InvestorCreateWithoutGroupMembershipsInput, InvestorUncheckedCreateWithoutGroupMembershipsInput>
  }

  export type LPGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLpGroupsInput
  }

  export type LPGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LPGroupCreateOrConnectWithoutMembersInput = {
    where: LPGroupWhereUniqueInput
    create: XOR<LPGroupCreateWithoutMembersInput, LPGroupUncheckedCreateWithoutMembersInput>
  }

  export type InvestorUpsertWithoutGroupMembershipsInput = {
    update: XOR<InvestorUpdateWithoutGroupMembershipsInput, InvestorUncheckedUpdateWithoutGroupMembershipsInput>
    create: XOR<InvestorCreateWithoutGroupMembershipsInput, InvestorUncheckedCreateWithoutGroupMembershipsInput>
    where?: InvestorWhereInput
  }

  export type InvestorUpdateToOneWithWhereWithoutGroupMembershipsInput = {
    where?: InvestorWhereInput
    data: XOR<InvestorUpdateWithoutGroupMembershipsInput, InvestorUncheckedUpdateWithoutGroupMembershipsInput>
  }

  export type InvestorUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvestorsNestedInput
    entities?: InvestorEntityUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutGroupMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: InvestorEntityUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type LPGroupUpsertWithoutMembersInput = {
    update: XOR<LPGroupUpdateWithoutMembersInput, LPGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<LPGroupCreateWithoutMembersInput, LPGroupUncheckedCreateWithoutMembersInput>
    where?: LPGroupWhereInput
  }

  export type LPGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: LPGroupWhereInput
    data: XOR<LPGroupUpdateWithoutMembersInput, LPGroupUncheckedUpdateWithoutMembersInput>
  }

  export type LPGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLpGroupsNestedInput
  }

  export type LPGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyUserInput = {
    id?: string
    provider: string
    type: string
    isActive?: boolean
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: IntegrationCreatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string | null
    syncStatus?: string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyUserInput = {
    id?: string
    company: string
    description?: string | null
    sector?: string | null
    stage: string
    status?: string
    value?: number | null
    probability?: number | null
    leadPartner?: string | null
    team?: DealCreateteamInput | string[]
    tags?: DealCreatetagsInput | string[]
    priority?: string
    targetClose?: Date | string | null
    actualClose?: Date | string | null
    nextStep?: string | null
    lastActivity?: Date | string | null
    source?: string | null
    geography?: string | null
    dealSize?: string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyUserInput = {
    id?: string
    dealId?: string | null
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateManyUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyUserInput = {
    id?: string
    dealId?: string | null
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsMessageCreateManyUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type TeamsChannelCreateManyUserInput = {
    id?: string
    channelId: string
    teamId: string
    name: string
    description?: string | null
    type: string
    webUrl?: string | null
    memberCount?: number | null
    isArchived?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackMessageCreateManyUserInput = {
    id?: string
    dealId?: string | null
    contactId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlackChannelCreateManyUserInput = {
    id?: string
    channelId: string
    name: string
    purpose?: string | null
    topic?: string | null
    isPrivate?: boolean
    isArchived?: boolean
    memberCount?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomMeetingCreateManyUserInput = {
    id?: string
    dealId?: string | null
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomParticipantCreateManyUserInput = {
    id?: string
    meetingId: string
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceAccountCreateManyUserInput = {
    id?: string
    dealId?: string | null
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceContactCreateManyUserInput = {
    id?: string
    contactId: string
    accountId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityCreateManyUserInput = {
    id?: string
    dealId?: string | null
    opportunityId: string
    accountId?: string | null
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FundCreateManyUserInput = {
    id?: string
    name: string
    type: string
    strategy?: string | null
    targetSize: number
    minimumCommitment?: number | null
    managementFee?: number | null
    carriedInterest?: number | null
    currency?: string
    vintage?: number | null
    investmentPeriod?: number | null
    fundTerm?: number | null
    geoFocus?: string | null
    sectorFocus?: string | null
    description?: string | null
    status?: string
    raisedAmount?: number
    investorCount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorCreateManyUserInput = {
    id?: string
    name: string
    type: string
    status?: string
    totalCommitment?: number | null
    totalCalled?: number | null
    description?: string | null
    website?: string | null
    location?: string | null
    founded?: Date | string | null
    aum?: number | null
    tags?: InvestorCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LPGroupCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    type?: string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: IntegrationUpdatescopeInput | string[]
    profile?: NullableJsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutDealNestedInput
    documents?: DocumentUpdateManyWithoutDealNestedInput
    activities?: ActivityUpdateManyWithoutDealNestedInput
    communications?: CommunicationUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutDealNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutDealNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutDealNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutDealNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutDealNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutDealNestedInput
    zoomMeetings?: ZoomMeetingUncheckedUpdateManyWithoutDealNestedInput
    salesforceAccounts?: SalesforceAccountUncheckedUpdateManyWithoutDealNestedInput
    salesforceOpportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    stage?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    leadPartner?: NullableStringFieldUpdateOperationsInput | string | null
    team?: DealUpdateteamInput | string[]
    tags?: DealUpdatetagsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    targetClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClose?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextStep?: NullableStringFieldUpdateOperationsInput | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    geography?: NullableStringFieldUpdateOperationsInput | string | null
    dealSize?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
    communications?: CommunicationUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutCommunicationsNestedInput
    contact?: ContactUpdateOneWithoutCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutTeamsMessagesNestedInput
    contact?: ContactUpdateOneWithoutTeamsMessagesNestedInput
  }

  export type TeamsMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsChannelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsChannelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsChannelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    webUrl?: NullableStringFieldUpdateOperationsInput | string | null
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutSlackMessagesNestedInput
    contact?: ContactUpdateOneWithoutSlackMessagesNestedInput
  }

  export type SlackMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackChannelUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackChannelUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackChannelUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    memberCount?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomMeetingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutZoomMeetingsNestedInput
    participants?: ZoomParticipantUpdateManyWithoutMeetingNestedInput
  }

  export type ZoomMeetingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ZoomParticipantUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type ZoomMeetingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: ZoomMeetingUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ZoomParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutSalesforceAccountsNestedInput
    contacts?: SalesforceContactUpdateManyWithoutAccountNestedInput
    opportunities?: SalesforceOpportunityUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: SalesforceContactUncheckedUpdateManyWithoutAccountNestedInput
    opportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: SalesforceAccountUpdateOneWithoutContactsNestedInput
  }

  export type SalesforceContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deal?: DealUpdateOneWithoutSalesforceOpportunitiesNestedInput
    account?: SalesforceAccountUpdateOneWithoutOpportunitiesNestedInput
  }

  export type SalesforceOpportunityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FundUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    strategy?: NullableStringFieldUpdateOperationsInput | string | null
    targetSize?: FloatFieldUpdateOperationsInput | number
    minimumCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    managementFee?: NullableFloatFieldUpdateOperationsInput | number | null
    carriedInterest?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    vintage?: NullableIntFieldUpdateOperationsInput | number | null
    investmentPeriod?: NullableIntFieldUpdateOperationsInput | number | null
    fundTerm?: NullableIntFieldUpdateOperationsInput | number | null
    geoFocus?: NullableStringFieldUpdateOperationsInput | string | null
    sectorFocus?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    raisedAmount?: FloatFieldUpdateOperationsInput | number
    investorCount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: InvestorEntityUpdateManyWithoutInvestorNestedInput
    groupMemberships?: InvestorGroupMemberUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: InvestorEntityUncheckedUpdateManyWithoutInvestorNestedInput
    groupMemberships?: InvestorGroupMemberUncheckedUpdateManyWithoutInvestorNestedInput
  }

  export type InvestorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalCommitment?: NullableFloatFieldUpdateOperationsInput | number | null
    totalCalled?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    founded?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    aum?: NullableFloatFieldUpdateOperationsInput | number | null
    tags?: InvestorUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LPGroupUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: InvestorGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type LPGroupUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: InvestorGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type LPGroupUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    criteria?: NullableJsonNullValueInput | InputJsonValue
    autoAssign?: BoolFieldUpdateOperationsInput | boolean
    emailPreferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyDealInput = {
    id?: string
    userId: string
    googleContactId?: string | null
    name: string
    email?: string | null
    phone?: string | null
    company?: string | null
    title?: string | null
    role?: string | null
    linkedinUrl?: string | null
    avatar?: string | null
    notes?: string | null
    tags?: ContactCreatetagsInput | string[]
    relationshipScore?: number | null
    lastContact?: Date | string | null
    status?: string
    isKeyContact?: boolean
    source?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyDealInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    type: string
    category?: string | null
    size?: number | null
    url?: string | null
    googleDriveId?: string | null
    path?: string | null
    version?: string
    isConfidential?: boolean
    uploadedBy?: string | null
    tags?: DocumentCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityCreateManyDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateManyDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsMessageCreateManyDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type SlackMessageCreateManyDealInput = {
    id?: string
    userId: string
    contactId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomMeetingCreateManyDealInput = {
    id?: string
    userId: string
    meetingId: string
    uuid?: string | null
    topic: string
    agenda?: string | null
    startTime: Date | string
    duration: number
    timezone: string
    status: string
    meetingType: string
    joinUrl?: string | null
    startUrl?: string | null
    password?: string | null
    hostEmail?: string | null
    participantCount?: number | null
    hasRecording?: boolean
    recordingUrl?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceAccountCreateManyDealInput = {
    id?: string
    userId: string
    accountId: string
    name: string
    type?: string | null
    industry?: string | null
    website?: string | null
    phone?: string | null
    billingCity?: string | null
    billingState?: string | null
    billingCountry?: string | null
    description?: string | null
    revenue?: number | null
    employees?: number | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityCreateManyDealInput = {
    id?: string
    userId: string
    opportunityId: string
    accountId?: string | null
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnedContactsNestedInput
    activities?: ActivityUpdateManyWithoutContactNestedInput
    communications?: CommunicationUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityUncheckedUpdateManyWithoutContactNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutContactNestedInput
    teamsMessages?: TeamsMessageUncheckedUpdateManyWithoutContactNestedInput
    slackMessages?: SlackMessageUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    googleContactId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactUpdatetagsInput | string[]
    relationshipScore?: NullableFloatFieldUpdateOperationsInput | number | null
    lastContact?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    isKeyContact?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    googleDriveId?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    contact?: ContactUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    contact?: ContactUpdateOneWithoutCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsMessagesNestedInput
    contact?: ContactUpdateOneWithoutTeamsMessagesNestedInput
  }

  export type TeamsMessageUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSlackMessagesNestedInput
    contact?: ContactUpdateOneWithoutSlackMessagesNestedInput
  }

  export type SlackMessageUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomMeetingUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutZoomMeetingsNestedInput
    participants?: ZoomParticipantUpdateManyWithoutMeetingNestedInput
  }

  export type ZoomMeetingUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ZoomParticipantUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type ZoomMeetingUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    uuid?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: StringFieldUpdateOperationsInput | string
    agenda?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    meetingType?: StringFieldUpdateOperationsInput | string
    joinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    startUrl?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    hostEmail?: NullableStringFieldUpdateOperationsInput | string | null
    participantCount?: NullableIntFieldUpdateOperationsInput | number | null
    hasRecording?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceAccountUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceAccountsNestedInput
    contacts?: SalesforceContactUpdateManyWithoutAccountNestedInput
    opportunities?: SalesforceOpportunityUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: SalesforceContactUncheckedUpdateManyWithoutAccountNestedInput
    opportunities?: SalesforceOpportunityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type SalesforceAccountUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    billingCity?: NullableStringFieldUpdateOperationsInput | string | null
    billingState?: NullableStringFieldUpdateOperationsInput | string | null
    billingCountry?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceOpportunitiesNestedInput
    account?: SalesforceAccountUpdateOneWithoutOpportunitiesNestedInput
  }

  export type SalesforceOpportunityUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    type: string
    title: string
    description?: string | null
    content?: string | null
    date: Date | string
    duration?: number | null
    location?: string | null
    attendees?: ActivityCreateattendeesInput | string[]
    status?: string
    priority?: string
    outcome?: string | null
    nextSteps?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: string | null
    syncedFrom?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationCreateManyContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    type: string
    subject?: string | null
    content?: string | null
    htmlContent?: string | null
    fromEmail?: string | null
    toEmails?: CommunicationCreatetoEmailsInput | string[]
    ccEmails?: CommunicationCreateccEmailsInput | string[]
    bccEmails?: CommunicationCreatebccEmailsInput | string[]
    threadId?: string | null
    messageId?: string | null
    status?: string
    direction: string
    isRead?: boolean
    isImportant?: boolean
    labels?: CommunicationCreatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: Date | string | null
    receivedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamsMessageCreateManyContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    messageId: string
    chatId?: string | null
    channelId?: string | null
    teamId?: string | null
    fromEmail: string
    fromName: string
    content: string
    contentType?: string
    importance?: string
    messageType: string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageCreatementionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentAt: Date | string
  }

  export type SlackMessageCreateManyContactInput = {
    id?: string
    userId: string
    dealId?: string | null
    messageId: string
    channelId: string
    channelName?: string | null
    fromUserId: string
    fromName: string
    text: string
    messageType?: string
    threadTs?: string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageCreatementionsInput | string[]
    sentAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
    deal?: DealUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    attendees?: ActivityUpdateattendeesInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    nextSteps?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    syncedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    deal?: DealUpdateOneWithoutCommunicationsNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    htmlContent?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: NullableStringFieldUpdateOperationsInput | string | null
    toEmails?: CommunicationUpdatetoEmailsInput | string[]
    ccEmails?: CommunicationUpdateccEmailsInput | string[]
    bccEmails?: CommunicationUpdatebccEmailsInput | string[]
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    direction?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    labels?: CommunicationUpdatelabelsInput | string[]
    attachments?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamsMessagesNestedInput
    deal?: DealUpdateOneWithoutTeamsMessagesNestedInput
  }

  export type TeamsMessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamsMessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    fromEmail?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    importance?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    attachments?: NullableJsonNullValueInput | InputJsonValue
    mentions?: TeamsMessageUpdatementionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSlackMessagesNestedInput
    deal?: DealUpdateOneWithoutSlackMessagesNestedInput
  }

  export type SlackMessageUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlackMessageUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    fromUserId?: StringFieldUpdateOperationsInput | string
    fromName?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    messageType?: StringFieldUpdateOperationsInput | string
    threadTs?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: NullableJsonNullValueInput | InputJsonValue
    reactions?: NullableJsonNullValueInput | InputJsonValue
    mentions?: SlackMessageUpdatementionsInput | string[]
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorEntityCreateManyInvestorInput = {
    id?: string
    name: string
    type: string
    investmentType: string
    commitment?: number | null
    called?: number | null
    status?: string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvestorGroupMemberCreateManyInvestorInput = {
    id?: string
    groupId: string
    assignedAt?: Date | string
    autoAssigned?: boolean
  }

  export type InvestorEntityUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorEntityUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorEntityUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    investmentType?: StringFieldUpdateOperationsInput | string
    commitment?: NullableFloatFieldUpdateOperationsInput | number | null
    called?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    fundInvestments?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorGroupMemberUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
    group?: LPGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type InvestorGroupMemberUncheckedUpdateWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvestorGroupMemberUncheckedUpdateManyWithoutInvestorInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ZoomParticipantCreateManyMeetingInput = {
    id?: string
    userId?: string | null
    zoomUserId?: string | null
    name: string
    email?: string | null
    joinTime: Date | string
    leaveTime?: Date | string | null
    duration?: number | null
    status: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoomParticipantUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutZoomParticipantsNestedInput
  }

  export type ZoomParticipantUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoomParticipantUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    zoomUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    joinTime?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactCreateManyAccountInput = {
    id?: string
    userId: string
    contactId: string
    name: string
    email?: string | null
    phone?: string | null
    title?: string | null
    department?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceOpportunityCreateManyAccountInput = {
    id?: string
    userId: string
    dealId?: string | null
    opportunityId: string
    name: string
    amount?: number | null
    stage: string
    probability?: number | null
    closeDate?: Date | string | null
    type?: string | null
    leadSource?: string | null
    description?: string | null
    ownerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesforceContactUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceContactsNestedInput
  }

  export type SalesforceContactUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceContactUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSalesforceOpportunitiesNestedInput
    deal?: DealUpdateOneWithoutSalesforceOpportunitiesNestedInput
  }

  export type SalesforceOpportunityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesforceOpportunityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    opportunityId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    probability?: NullableFloatFieldUpdateOperationsInput | number | null
    closeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    leadSource?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastSync?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvestorGroupMemberCreateManyGroupInput = {
    id?: string
    investorId: string
    assignedAt?: Date | string
    autoAssigned?: boolean
  }

  export type InvestorGroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
    investor?: InvestorUpdateOneRequiredWithoutGroupMembershipsNestedInput
  }

  export type InvestorGroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvestorGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    investorId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoAssigned?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}